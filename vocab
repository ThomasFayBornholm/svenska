<!DOCTYPE html>
<html lang="sv"></html>
<head>
	<meta char="UTF-8" name="viewport" content="width=device-width, initial-scale=1">
	<title>Ordbok</title>
	<link rel="stylesheet" href="svenska.css">
	<script src="jquery-3.6.0.js"></script>
	<script src="jquery-ui.js"></script>
	<link rel="stylesheet" href="jquery-ui.css">
	<script>
	$( function() {
		$( document ).tooltip();
	} );
	</script>
	<style>
	label {
		display: inline-block;
		width: 5em;
	}
	</style>	
</head>
<body onload="startup()">
<div >
<h1 id="iTitle" ondblclick="toggleTooltips()" oncontextmenu="toggleDebugEv(event)" title="Double click to toggle tooltip display on web-page controls">Ordbok</h1>
</div>
<div id="iCountDiv" class="centred" style="visibility: hidden">
	<span class="counts countLeft" id="iCnt">test</span>
	<span class="counts countTotal" id="iCntTotal" onclick="showToggle()" onmouseover="highlight(this,event)">Total</span>
	<span class="counts" "score" id="iScore">{Score}</span>
	<span class="counts" id="iCntRegex"></span>	
</div>
<div id="iControls">
	<p class="debug" id="iDebugTxt"></p>
	<form class="centred" onsubmit="newInputWrapper(event)">		
		<input id="iInput" oncontextmenu="onlineLookup(this,event)" class="inputSearch" autocomplete="off" onkeydown="processKeyDown(this,event)">				
		<img class="b2" src="img/leftArrow.svg" id="iLast" onclick="getLastWord()" oncontextmenu="hack(event)" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">
	</form>
	
</div>
<div id="iWordBox" class="wordBox firstColumn" onwheel="scrollWords(event)" onclick="clearDef()">
	<p id="iWords" class="fmtWords">Test<br>Words</p>
</div>
<div id="iInfo" class="secondColumn" onwheel="scrollView(event)" onclick="clickMiddle(event)" oncontextmenu="clickMiddle(event)">

	<div id="iDefDiv">
		 <textarea  class="defBox" id="iDefText" onkeydown="defEntry(event)"></textarea>			 
		 <div id="iPutDef">
		 <button class="putDefThree" id="iPut0" onclick="putDef('', 0)">0</button>			 			 
		 <button class="putDefThree" id="iPut1" onclick="putDef('', 1)">Put (1)</button>			 			 
		 <button class="putDefThree" id="iPut2" onclick="putDef('', 2)">2</button>			 			 
		 </div>
		 <div id="iDivMore">		
		 <button class="putDef" onclick="putMore()" id="iPutMore">Put More Information</button>		 
		 </div>
	</div>		
	<p class="pDef" id="iParDef" ondblclick="clearDef()"></p>			
	<div id="iNavDiv" onclick="scrollViewDown()" oncontextmenu="scrollViewUp(event)"></div>
</div>	
</body>
<script>


let INC = 0;
let N_INC= 8;
let SCROLL_INC=0
let N_FOUND=0;

let N_TOT=0;
let N_ADJ=0;
let N_VERB=0;
let N_ADVERB=0;
let N_FRASER=0;
let N_EN=0;
let N_ETT=0;
let N_PLURAL=0;
let N_PREPOSITION = 0;
let N_INTERJEKTION = 0;
let N_PRONOMEN = 0;
let N_PREFIX = 0;
let N_SLUTLED = 0;
let N_NUMMER = 0;
let N_SUBJUNKTION = 0;
let N_CUR=0;
let N_DEFS = 0;

let LAST_WORD="";
let CUR_WORD="";
let CUR_DEF="0";
let CLASS = "all";
var LAST_OBJ;
let DEBUG=false;
let LAST_DEF = "";
let LAST_CLASS = "all";
let CONTROLS_VISIBLE=true;
var TABS = [];
var REGEX_WORDS = [];
var N_REGEX = 0;
var CACHED_DEF_HTML = "";
var SCORE_COLOURS = ["darkred", "steelblue", "darkgreen"];

var CLASSES = ["Class (short name)","substantiv_en (en)","verb","adjektiv (adj)","substantiv_ett (ett)","adverb (adv)","fraser (fra)","plural (plu)","preposition (prep)","pronomen (pro)","interjektion (int)","förled (för)","slutled (slut)","subjunktion (sub)","konjunktion (kon)","räkneord (räk)"]
// Crude toggle on site load to show tool tips
let SHOW_HELP = false;
var TAB_DUMMY;
var TAB_LOOKUP
let ALL_DEFS = "";

document.addEventListener("visibilitychange", (event) => {
	if (TABS.length > 0) {
		if (document.visibilityState == "visible") {
			editDef();
		}
	}
});

function startup() {
	showTooltips();
	wordCount();		
	updateScore();
	randomWord();
	$('#iInput').focus();
}

function setN_CUR() {
	if (CLASS === "adjektiv") {
		N_CUR = N_ADJ;
	} else if (CLASS === "verb") {
		N_CUR = N_VERB;
	} else if (CLASS === "adverb") {
		N_CUR = N_ADVERB;
	} else if (CLASS === "substantiv_en") {
		N_CUR = N_EN;
	} else if (CLASS === "substantiv_ett") {
		N_CUR = N_ETT;
	} else if (CLASS === "fraser") {
		N_CUR = N_FRASER;
	} else if (CLASS === "preposition") {
		N_CUR = N_PREPOSITION;
	} else if (CLASS === "interjektion") {
		N_CUR = N_INTERJEKTION;
	} else if (CLASS === "pronomen") {
		N_CUR = N_PRONOMEN;
	} else if (CLASS === "förled") {
		N_CUR = N_PREFIX;
	} else if (CLASS === "plural") {
		N_CUR = N_PLURAL;
	} else if (CLASS === "slutled") {
		N_CUR = N_SLUTLED;
	} else if (CLASS === "räkneord") {
		N_CUR = N_NUMMER;
	} else if (CLASS === "konjunktion") {
		N_CUR = N_KONJUNKTION;
	} else if (CLASS === "subjunktion") {
		N_CUR = N_SUBJUNKTION;
	} else if (CLASS === "all") {
		N_CUR = N_ALL;
	}
	if (CLASS === "all") {
		$('#iCnt').text("");
		$('#iCntTotal').text(' [' + N_TOT.toLocaleString('sv') + ']');
	} else {
		$('#iCnt').text(N_CUR.toLocaleString('sv'));
		$('#iCntTotal').text("");
	}	
	
	if (DEBUG) console.log("setN_CUR(); N_CUR = " + N_CUR);
}

function fmtDef(def) {
	for (i = 0; i < 24; i++) {
		let old = " " + i + " ";
		let rep = "<br>" + i + " ";
		def = def.replace(old,rep)
	}
	return def;
}

function putDef(def, score) {	
	if (def.length === 0) {
		def = $('#iDefText').val();
	}
	if (DEBUG) console.log("START putDef(def, score); def = '" + def + ",score ´" + score + "; SCROLL_INC = " + SCROLL_INC);
	let processed = preProc(def);
	def = processed[0];
	meta = processed[1];
	
	fetch('backend/putDef.php?class=' + CLASS + '&word=' + CUR_WORD + '&def=' + def + '&meta=' + meta + "&score=" + score, {
		method: 'get',
		mode:	'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		$('#iDefText').val("");
		$('#iDefDiv').css("display", "none");
		// Reset highlighting of m	issing definition
		LAST_OBJ.innerHTML = LAST_OBJ.innerText;		
		// Find last non-null tabindex
		if (TABS.length > 0) {
			let tmpInd = parseInt(SCROLL_INC) + parseInt(1);		
			TABS[tmpInd].focus();
			scrollDown()
		}
		if (SCROLL_INC != N_FOUND-1) {
			updateDef();
			getWords();
			updateScore();	
		} else {
			updateDef();
			getWords();
			updateScore();	
		}
		displaySelection();
		// Race condition here between file write and def display	
		/*
		if (SCROLL_INC === (N_FOUND - 1)) {
			lookupWord(LAST_OBJ,true,true);
		}
		*/
	})
	updateScore();
}
function updateScore() {
	// Hash to prevent cached value being used by browser
	fetch('backend/getScore.php?class=' + CLASS + '&hash=' + makeHash(), {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		let score = 0;
		if (N_TOT > 0) {
			score = Math.round(json["total"]/(N_CUR*2) * 1000)/10;
		}
		if (CLASS === "all") {
			score = Math.round(json["total"]/(N_TOT*2) * 1000)/10;
			let tmp = N_TOT.toLocaleString('sv');
			tmp += " {" + score + "%}";						
			$('#iCntTotal').html(tmp);
			$('#iCntTotal').css("display","inline-block");
			$('#iScore').html("");
		} else {
			$('#iCntTotal').css("display","none");
			$('#iScore').html("{" + score + "%");
			$('#iScore').html($('#iScore').html() + " <span class='redWord' onclick=seekWord('redwords') oncontextmenu='nextWord(this,event)'>" + json["redCount"] + "</span>")
			$('#iScore').html($('#iScore').html() + ";<span class='blueWord' onclick=seekWord('bluewords') oncontextmenu='nextWord(this,event)'>" + json["blueCount"] + "</span>")
			$('#iScore').html($('#iScore').html() + "}");
		}
		// Only display counts once they are initialised.
		$('#iCountDiv').css("visibility","");
	})
	.catch(error => {
		console.log(error);
	})
}

function changeInc(delta) {
	if (INC + delta > N_CUR) {
		INC = INC;
	} else {
		if (N_REGEX > 0) {
			if (INC + delta < N_REGEX) {			
				INC += delta
			}
		} else {
			INC += delta
		}
	}

	if (INC < 0) {
		INC = 0;
	}
	if (DEBUG) console.log("changeInc(" + delta + ") -> INC: " + INC);
}
function nextID(id) {
	let num = id.replace("w","");
	if (++num < N_FOUND) {
		return "w" + num;
	} else {
		return id;
	}
}
function advance() {
	if (DEBUG) console.log("advance()");
	changeInc(N_INC)
	getWords(-1)
}
function retreat(e) {
	if (DEBUG) console.log("retreat()");
	e.preventDefault()
	changeInc(-N_INC)
	getWords(-1)
}
function getWords(ind = INC) {
	// Ind is used to highlight and lookup a given word index from the returned list
	// Global INC is used to get the starting index of the returned list	
	if (DEBUG) console.log("getWords(), ind = " + ind + ", INC = ", + INC);	
	SCROLL_INC= -1;
	N_FOUND=0;
	$('#iParDef').text("");
	if (N_REGEX > 0) {
		list = REGEX_WORDS[ind];	
		N_FOUND = N_REGEX - ind;
		if (N_FOUND > N_INC) N_FOUND = N_INC;	
		for (i = ind+1; i < N_FOUND + ind; i++) {
			list += "," + REGEX_WORDS[i];
		}
		displayWords(list,-1)
	} else {
		fetch("backend/getWords.php?class=" + CLASS + "&start=" + INC + "&num=" + N_INC, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json',
			}
		})
		.then(response => {
			return response.json()
		})
		.then(json => {			
			let lastJson = json;
			N_FOUND=json.length;
			if (N_FOUND > 0) {
				let list = json[0];
				let scores = [];
				for (i = 1; i < N_FOUND; i++) {
					list += "," + json[i];
				}			
				displayWords(list,ind)
			}
		})
		.catch(error => {
			console.log(error)
		})
	}
	if (DEBUG) console.log("END getWords(ind); ind = " + ind + ", N_FOUND = " + N_FOUND);
}

function displayWords(list,ind) {
	if (DEBUG) console.log("displayWords(), list = " + list + ", ind = " + ind)
	let out = ""
	fetch('backend/existsDef.php?class=' + CLASS + "&words=" + list, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		res = json["stat"];
		let score = json["score"];
		let del = "";
		let words = list.split(",");	
		N_FOUND = words.length;		
		for (let i = 0; i < N_FOUND; i++) {
			let tmp = 1 << i;
			let hasMeta = (res & tmp);
			out += del + popSpan(i, words[i],hasMeta) 
			del = "<br>";
		}
		$('#iWords').html(out);
		// Formatting to show score indicators
		if (CLASS != "all") {
			for (let i = 0; i < N_FOUND; i++) {
				let tmp = "#w" + i;
				if (score[i] > 1) {
					$(tmp).css("color","darkgreen");
				} else if (score[i] > 0) {
					$(tmp).css("color","steelblue");
				} else {
					$(tmp).css("color","darkred");
				}
			}
		}
		showWords();				
		countDefs();
		
		if (ind > -1) {
			let el = document.getElementById("w" + ind);
			CUR_WORD = el.innerText;
			lookupWord(el,false,true);
		}				
	})
	.catch(error => {
		console.log(error);
	})
}

function scrollViewDown() {
	if (DEBUG) console.log("scrollViewDown() begin");
	changeInc(N_INC);
	$('iDefDiv').css("display", "none");
	if (N_REGEX > 1) {
		getWords();
	} else {
		getWords(-1);
	}
	showWords();
}
function scrollViewUp(e) {
	e.preventDefault();
	if (DEBUG) console.log("scrollViewUp() begin");
	changeInc(-N_INC);
	if (N_REGEX > 1) {
		getWords();
	} else {
		getWords(-1);
	}
	showWords();
}
function scrollView(e) {
	if (DEBUG) console.log("scrollView() begin");
	e.preventDefault();
	showWords();
	if (e.deltaY > 0) {
		scrollViewDown();
	} else {
		scrollViewUp(e);
	}
	if (DEBUG) console.log("scrollView(); INC = " + INC)
}

function scrollWords(e) {
	e.preventDefault();
	if (event.deltaY > 0) {
		scrollDown();
	} else {
		scrollUp();
	}
	// Show local definition if available
	if (CLASS === "all") {	
		showWordMatches()
	} else {
		updateDef();
	}
	if (DEBUG) console.log("scrollWords() -> SCROLL_INC = " + SCROLL_INC);
}

function scrollDown() {
	if (SCROLL_INC < N_FOUND-1) {
		SCROLL_INC++;
	}
	if (DEBUG) console.log("scrollDown(); SCROLL_INC = " + SCROLL_INC);
}
function scrollUp() {
	if (SCROLL_INC > 0) {
		SCROLL_INC--;
	} else if (SCROLL_INC == -1) {
		SCROLL_INC = N_FOUND - 1;
	}
	if (DEBUG) console.log("scrollUp(); SCROLL_INC = " + SCROLL_INC);
}
function updateDef() {
	if (DEBUG) console.log("updateDef()");
	let id = "w" + SCROLL_INC;
	let el = document.getElementById(id);
	lookupWord(el,true,true);
}
function popSpan(i, w, hasMeta) {
	tmp = "<span id='w<i>' onclick='lookupWord(this,false,false)' oncontextmenu='onlineLookup(this,event)'><w></span>"
	if (DEBUG) console.log("popSpan(i=" + i + ",w=" + w + ",hasMeta=" + hasMeta + ")");
	tmp = tmp.replace("<i>",i)
	if (hasMeta || CLASS === "all") {
		tmp = tmp.replaceAll("<w>",w);
	} else { 
		tmp = tmp.replaceAll("<w>","<i>" + w + "</i>");
	}
	return tmp
}

// Only call when word class is "all"
function showWordMatches(follow) {
	if (DEBUG) console.log("showWordMatches()");
	if (CLASS != "all") {
		return;
	}
	let id = "w" + SCROLL_INC;
	let el = document.getElementById(id);
	let word = el.innerText;
	
	if (LAST_OBJ) {
		LAST_OBJ.style.fontWeight="";
	}
	
	el.style.fontWeight="bold";
	fetch('backend/getDefAll.php?word=' + word, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {		
		let keys = Object.keys(json);	
		if (keys.length === 1 && keys[0] != CLASS && follow) {			
			// Go direct to class if no ambiguity in found word(s)
			setClass(keys[0]);
			seekWord(word);
		}
		let def = "";
		let delim ="";			
		let tmp = "<span onmouseover=highlight(this,event) onclick=\"setClass(\'_k_\',\'_w_\')\"><i>_k_:</i></span><br>";			
		for (let i = 0; i < keys.length; i++) {		
			def += delim + tmp.replaceAll("_k_", keys[i]).replace("_w_",word) + makeLinks(json[keys[i]]);
			delim="<br>";
		}
		LAST_DEF = def;	
		LAST_WORD = word;
		displayDef("",def, word);						
		return;
	})
	.catch(error => {
		console.log(error);
	})
	LAST_OBJ = el;
}

function lookupWord(el,onlyLocal,inline) {	
	if (DEBUG) console.log("lookupWord(el,onlyLocal,linline), elid = " + el.id + ", onlyLocal = " + onlyLocal + ", inline = " + inline);
	$('#iPutDef').css("display","block");
	$('#iPutMore').css("display","none");

	if (el) {
		if (CLASS === "all") {
			SCROLL_INC = parseInt(el.id.replace("w",""));			
			let follow = false;

			if (el.innerText.indexOf(">") != -1) {
				follow = true;
			}
			showWordMatches(follow);			
			return;
		}
		if (LAST_OBJ) {
			LAST_OBJ.style.fontWeight="";
		}
		el.style.fontWeight="bold";
		let word = el.innerText;
		CUR_WORD=word;

		LAST_OBJ = el;
		
		if (DEBUG) console.log("lookupWord(), CUR_WORD = " + CUR_WORD);
		scroll_inc = el.id.replace("w","");
		if (scroll_inc > -1 && scroll_inc < N_INC) {
			SCROLL_INC = scroll_inc; 
		}
		if (CLASS === "all") {
			fetch('backend/getDefAll.php?word=' + word, {
				method: 'get',
				mode: 'cors',
				headers: {
					'Content-Type': 'application/json'
				}
			})
			.then(response => {
				return response.json();
			})
			.then(json => {
				let keys = Object.keys(json);						
				if (keys.length === 1 && keys[0] != CLASS) {			
					// Go direct to class if no ambiguity in found word(s)
					setClass(keys[0]);
					seekWord(word);
				}
				let def = "";
				let delim ="";			
				let tmp = "<span ";
				if (SHOW_HELP) {
					tmp += "title='Navigate to xxx'";
				}
				tmp += "onmouseover=highlight(this,event) onclick=\"setClass(\'_k_\',\'_w_\')\"><i>_k_:</i><br></span>";			
				for (let i = 0; i < keys.length; i++) {		
					def += delim + tmp.replaceAll("_k_", keys[i]).replace("_w_",word) + makeLinks(json[keys[i]]);
					delim="<br>";
				}
				LAST_DEF = def;				
				displayDef("",def, word);						
				return;
			})
			.catch(error => {
				console.log(error);
			})
		} else {
			fetch('backend/getDef.php?class=' + CLASS + '&word='+ word, {
				method: 'get',
				mode: 'cors',
				headers: {
					'Content-Type': 'application/json'
				}
			})
			.then(response => {
				return response.json()
			})
			.then(json => {			
				let meta = json["meta"];
				def = json["def"];
				LAST_DEF = json["def"];
				// Prefer local definition over 3rd party dictionary
				if (def != "No definition found" && def != "Could not read json") {
					if (def.includes("till '")) {
						getCompDef(meta,def);
						return;
					}
					def = makeLinks(def);
					displayDef(meta,def,word);											
					$('#iDefDiv').css("display", "none");
					if (!inline) {
						$('#iWords').css("visibility", "hidden");
					}
				} else {
					/*
					if (!onlyLocal) {
						let url = "https://svenska.se/tre?sok=" + word + "&pz=1";
						window.open(bulletProofUrl(url), '_blank');
					}
					*/
					seekWordSingleClass(word);
					$('#iParDef').html("");
					$('#iDefDiv').css("display", "block");
				}
			})
			.catch(error => {
				console.log(error)
			})
		}
		
		if (DEBUG) {
			if (word.length === 0) word = "__empty__";
			console.log("lookupWord(" +  word + ")");
		}
	}
}
function displayDef(meta, def,word) {
	if (DEBUG) console.log("displayDef(meta,def,word)");	
	let defRaw = def.split("<br>");
	let defLines = [];
	let iWrite = 0;
	for (i = 0; i < defRaw.length; i++) {
		if (defRaw[i].match(/^[1-9\u25CF]+[0-9]?.*/)) {
			defLines[iWrite] = defRaw[i];
			iWrite++;			
		} else {
			for (k = 1; k < 24; k++) {
				defRaw[i] = defRaw[i].replaceAll(k,"")				
			}
			defRaw[i] = defRaw[i].replaceAll(" </b>","</b>")
			if (defLines.length === 0) {
				defLines[0] = defRaw[i];
				iWrite++;
			} else {				
				defLines[iWrite-1] += "<br>" + defRaw[i];
			}
		}
	}
	let outDef = "";
	let delim = "";	
	for (j = 0; j < defLines.length; j++) {
		let key = word.replaceAll(" ","-") + "_" + j;
		let id = "iMore_" + key;	
		if (defLines[j].indexOf("<i>") === -1) {
			outDef += delim + defLines[j] + " <span id='" + id + "' onmouseover='highlight(this,event)'"
			if (SHOW_HELP) {
				outDef += "title='Show more information'"
			}
			outDef += "onclick=toggleMore('" + key + "') oncontextmenu=editMore(event,'" + key + "')> <i>++</i></span>";
		} else {
			outDef += delim + defLines[j];
		}
		delim = "<br>";
	}
	outDef = outDef.replaceAll(" </b>","</b>")
	let tmpSpan = "<span id='iMeta' oncontextmenu=editDefWrapper(event) onmouseover=editCursor(event,this)"
	if (SHOW_HELP) {
		console.log("test")
		tmpSpan += " title='Right click to edit definition'" 
	}	
	outDef = tmpSpan + ">" + fmtMeta(meta) + "</span>" + outDef;
	CACHED_DEF_HTML = outDef;
	$('#iParDef').html(outDef)
	
}
// Make links to referenced words
function makeLinks(def) {
	if (DEBUG) console.log("makeLinks()")
	def = linkSingleWord(def);	
	if (def.split("<br>").length == 1) {
		return def;
	}
	
	def = addLinks("MOTSATS", def);
	def = addLinks("JFR", def);
	def = addLinks("SYN.", def);
	def = addLinks("SE", def);		
	return def;
}
function linkSingleWord(def) {	
	if (DEBUG) console.log("linkSingleWord(def), def = " + def);
	if (def.substr(0,6) === "till '") return def;
	defArr = def.split("<br>");
	outDef = "";
	del = "";
	tmpSpan = "<span onclick=followLink(this) onmouseover=highlight(this,event)"
	if (SHOW_HELP) tmpSpan += "title='Navigate to \"_w_\"'"
	tmpSpan += "><b>_w_</b></span>";
	for (line of defArr) {		
		if (line.length > 0) {
			// Exclude explicitly predefined links and word class links e.g. "verb:"
			if (line[0].match(/[A-Z]/) != null || line.indexOf(":") != -1) {
				outDef += del + line;
				del = "<br>";
			} else {
				let tmp = line;
				tmp = tmp.substr(2);			

				// Strip away meta and grammer information
				let res = tmp.match(/(\[.*\])/);
				if (res) tmp = tmp.replace(res[0] + " ","");
				res = tmp.match(/(\(.*\))/);
				if (res) tmp = tmp.replace(res[0] + " ","");
				// Simple references to adjektives from substantive
				let ref = "det att vara ";
				if (tmp.indexOf(ref) === 0) tmp = tmp.replace(ref,"");
				ref = "det att ";
				// Simple references to verbs from substantive
				if (tmp.indexOf(ref) === 0) tmp = tmp.replace(ref,"");
				// Simple reference from adjektives to substantive
				ref = "som vållar ";
				if (tmp.indexOf(ref) === 0) tmp = tmp.replace(ref,"");
				ref = "som präglas av ";
				if (tmp.indexOf(ref) === 0) tmp = tmp.replace(ref,"");
				// Simple references to verbs from adjektive
				ref = "som ";
				if (tmp.indexOf(ref) === 0) {
					tmp = tmp.replace(ref,"");
					// remove trailing 'r' from verb conjugation
					if (tmp.slice(tmp.length-1) === 'r') {					
						tmp = tmp.slice(0,tmp.length-1);
					}
				}
				
				let cnt = tmp.match(/ /g);
				if (cnt === null) {
					let offset = 1;
					if (cnt === null) offset = 0
					let word = tmp.substr(offset).replaceAll("­","");
					line = line.replace(word, tmpSpan.replaceAll("_w_",word));				
				} 
				
				outDef += del + line;
				del = "<br>";
			}
		}
	}
	return outDef;
}

function addLinks(refClass,def) {	
	if (DEBUG) console.log("addLinks(), refClass = " + refClass + ", def = " + def);
	if (def.indexOf(refClass) === -1) return def;
	// Easiest to handle line by line and skip the lines without links
	// Expectation is each link class (JFR, SE etc.) has its own new line.
	defArr = def.split("<br>");
	def = "";
	m = refClass + " ";
	delim = "";
	beginSpan = "<span onclick=followLink(this)";
	beginSpan += " onmouseover=highlight(this,event)";
	if (SHOW_HELP) beginSpan += " title='Navigate to \"_w_\"'";
	beginSpan += ">"
	spanTmp = beginSpan + "<b>_w_</b></span>";
	for (line of defArr) {
		
		if (line.indexOf(m) != -1) {
			elArr = line.split(", ");
			for (el of elArr) {
				el = el.replaceAll("­","");
				if (el.includes(m)) {
					let rep = m + spanTmp.replaceAll("_w_",el.substr(m.length, el.length - m.length))
					line = line.replace(el, rep);
				} else {
					let rep = spanTmp.replaceAll("_w_", el);
					line = line.replace(", " + el, ", " + rep);
				}
			}
		}
		def += delim + line;
		delim = "<br>";
	}
	return def;
}
function followLink(el) {
	if (DEBUG) console.log("followLink");
	LAST_CLASS = CLASS;
	LAST_WORD = CUR_WORD;	
	N_REGEX = 0;
	REGEX_WORDS = [];
	let word = el.innerText;
	let rep = word.match(/\s/);
	if (rep != null) {
		word = word.replaceAll(rep[0], " ");
	}
	word = word.replace("!","");
	CUR_WORD = word;
	if (DEBUG) console.log("followLink(" + word + ")");	
	let oldINC = INC;
	seekWord(word, true);
}

function getCompDef(meta, def) {
	if (DEBUG) console.log("getCompDef(def); def = " + def);
	// Compose and output string that combines definition of multiple (usually two)
	// component words
	words = getRefs(def);
	let complete = false;
	let res = "";
	let out = [];
	let done = 0;
	for (let i = 0; i < words.length; i++) {
		let w = words[i];
		w = w.replace("-","");
		// Dispatch n fetches to get definitions
		// add an identifier to each result to enable correct ordering 
		fetch('backend/getDef.php?class=' + guessClass(w) + '&word='+ removeClassDesc(w), {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json();
		})
		.then(json => {
			// def - the original reference definition
			// tmp - original ref + link to the referenced word
			// json - the referenced definition
			let tmp = "<span onclick=\"followLink(this)\"><b>_w_</b></span>:";
			tmp = tmp.replaceAll("_w_",removeClassDesc(w));
			tmp = tmp + "<br>";
			out[done] = makeLinks(tmp + json["def"]);
			done++;
			if (done >= words.length) {
				// Perform any required ordering
				let txt = def + "<br>";
				let del = "";
				for (let i = 0; i < done; i++) {
					if (i != 0) del = "<br>"
					txt = txt + del + out[i];
				}
				$('#iParDef').html(fmtMeta(meta) + txt);
			}
		})
		.catch(error => {
			console.log(error);
		})
	}
}
function getRefs(def) {
	if (!def.includes("till ") || !def.includes("'")) {
		return "";
	}
	def = def.slice(2);
	def = def.replaceAll("till ", "");
	def = def.replaceAll("'","");
	arr = def.split(",");
	if (DEBUG) console.log("getRef(), arr = " + arr);
	return arr;
}

function onlineLookup(elHTML, ev) {	
	if (DEBUG) console.log("onlineLookup(elHTML, ev)");
	ev.preventDefault()
	word = elHTML.innerText;
	if (word.length === 0) word = elHTML.value;
	if (word.length > 0) {
		let url = "https://svenska.se/tre?sok=" + word + "&pz=1";		
		// Rebust escaping of special characters		
		TAB_LOOKUP = window.open(bulletProofUrl(url), '_blank');				
		//TAB_DUMMY.location.href = "http://localhost/svenska/dummy?word=test";
		TAB_DUMMY = window.open("http://localhost/svenska/dummy?word=" + word,"","toolbar=no, menubar=no, location=no, left=0, top=0, width=600,height=600");
		TAB_DUMMY.focus();
		
		setTimeout(switchTab, 1500);

	}
}

function switchTab() {	
	TAB_DUMMY.close()
	TAB_LOOKUP.focus();		
}

function wordCount() {
	// Hash to prevent cached result being returned.
	fetch('backend/wordCount.php?hash=' + makeHash(), {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		},
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		N_TOT = json["total"];
		N_ALL = json["all"];
		N_ADJ = json["adj"];
		N_VERB = json["verb"];
		N_ADVERB = json["adverb"];
		N_FRASER = json["fraser"];
		N_EN = json["substantiv_en"];
		N_ETT = json["substantiv_ett"];		
		N_PLURAL = json["plural"];		
		N_PREPOSITION = json["preposition"];
		N_INTERJEKTION = json["interjektion"];
		N_PRONOMEN = json["pronomen"];
		N_PREFIX = json["prefix"];
		N_SLUTLED = json["slutled"];
		N_NUMMER = json["nummer"];
		N_KONJUNKTION = json["konjunktion"];
		N_SUBJUNKTION = json["subjunktion"];
		setN_CUR();		
	})
	.catch(error => {
		console.log(error);
	})
}

function showToggle() {
	if (CONTROLS_VISIBLE) {
		// Hide controls 
		$('#iControls').css("display", "none");
		$('#iShowToggle').text("__");
		CONTROLS_VISIBLE=false;
	} else {
		// Make visible class selector and word seeker controls
		$('#iControls').css("display", "block");
		$('#iShowToggle').text("HIDE");
		$('#iInput').focus();
		CONTROLS_VISIBLE=true;
	}
	if (DEBUG) console.log("showToggle(); seek.v = " + $('#iInput').css("visibility") + ", sel.v = " + $('#iSelect').css("visibility"));
}
function newInputWrapper(e) {
	if (DEBUG) console.log("newInputWrapper()");
	e.preventDefault();
	let word = $('#iInput').val();
	if (word.indexOf("@") === 0) {
		let newClass  = fullClassName(word.substr(1));
		if (newClass != "list") {
			setClass(newClass);		
		} else {
			let delim = "";
			let out = "";
			for (let i = 0; i < CLASSES.length; i++) {
				out += delim + CLASSES[i];
				delim = "<br>";
			}
			$('#iWords').html(out);			
		}
		$('#iInput').val("");
		return;
	} else if (word.indexOf("@") != -1) {
		// Add word
		let tmp  = word.split("@");
		let tmp2 = tmp[1].split(",");
		let newClass = tmp2[0];
		word = tmp[0]
		if (tmp[1].indexOf(",") != -1) word += ",";
		
		setClass(fullClassName(newClass));
		$('#iInput').val(word);
		newInputWrapper(e);
		return;
	} else if (word.indexOf(",") === 0 || word.indexOf(",") === word.length-1) {	
		word = word.replaceAll(",","");
		$('#iInput').val(word);
		addWord();
		seekWordSingleClass(word);
		return;
	}
	seekWord(word);
}

function seekWordSingleClass(word) {	
	if (DEBUG) console.log("seekWordSingleClass(word), word = " + word)	
	if (word.length > 0) {
		LAST_WORD = CUR_WORD;
		fetch('backend/seekWord.php?class=' + CLASS + "&word=" + word + "&inc=" + INC, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json();
		})
		.then(json => {
			if (json > -1) {
				CUR_WORD = word;
				// Put selected word in the middle of the word collection				
				INC = json - 3;
				let ind = 3;
				let mid = N_INC/2;
				if (json < mid - 1) {					
					INC = 0;
					ind = json;
				}
				getWords(ind);
			}
		})
		.catch(error => {
			console.log(error);
		})		
	}	
}

/* Priorities for search
 1) Regex/match score
 2) Exact match within class
 3) Matches conjugation within class
 4) Matches conjugation within any class (first found).
 */
// Link is set if this seek is called from a clickable link
function seekWord(word, link = false) {	
	if (DEBUG) console.log("seekWord(word, link),word = " + word + ", link = " + link)
	REGEX_WORDS = [];
	if (word[word.length-1] === "." || word.indexOf('+') != -1) {		
		addWord();
		return;
	}
	// Strip trailing white space	
	while (word.substr(word.length-1) === " ") {
		word = word.substr(0,word.length-1)
	}

	$('#iCntRegex').html("");
	// Regex support
	reg1 = word.indexOf("*") != -1 || word.indexOf("+") != -1 || word.indexOf('?') != -1 || word.indexOf('^') != -1;
	reg2 = word.indexOf("$") != -1 || word.indexOf("[") != -1 || word.indexOf("]") != -1;
	scoreMatch = word.indexOf("redwords") != -1 || word.indexOf("bluewords") != - 1;
	if (reg1 || reg2) {				
		fetch('backend/regexSeek.php?class=' + CLASS + '&regex=' + word, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json()
		})
		.then(json => {
			REGEX_WORDS = json;			
			N_REGEX = json.length;			
			$('#iScore').html("");
			$('#iCntRegex').html("*" + N_REGEX + "*");			
			if (N_REGEX > 0) {
				INC = 0;
				SCROLL_INC = -1;
				getWords(INC)
			}			
		})
		.catch(error => {
			console.log(error);
		})
	} else if (scoreMatch) {
		let score = 0;
		if (word === "bluewords") score = 1;		
		fetch('backend/scoreMatch.php?class=' + CLASS + '&score=' + score, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json();
		})
		.then(json => {
			REGEX_WORDS = json;			
			N_REGEX = json.length;			
			$('#iScore').html("");
			$('#iCntRegex').html("*" + N_REGEX + "*");			
			if (N_REGEX > 0) {
				INC = 0;
				SCROLL_INC = -1;
				getWords(INC)
			}
		})
		.catch(error => {
			console.log(error);
		})
	} else {
		REGEX_WORDS = [];
		N_REGEX = 0;
		// Special exceptions to capitalisation rules
		if (word != "Ers" && word != "Eders" && word.indexOf("-") === -1) word = word.toLowerCase()

		if (word === '') {
			word = LAST_WORD;
			$('#iInput').val(word);
			setClass(LAST_CLASS);
		}
		if (!link) {
			//LAST_WORD = CUR_WORD;
		}
		CUR_WORD = word;
		if (DEBUG) console.log("seekWord(): LAST_WORD = " + LAST_WORD + ", CUR_WORD = " + CUR_WORD);
		// Special case of prefixes and suffices
		if (word.substr(word.length-1) === "-") {
			word = word.substr(0,word.length-1);
			setClass("förled");
		} else if (word.slice(0,1) === "-") {
			word = word.substr(1);
			setClass("slutled");
		}
		if (word.length > 0) {
			fetch('backend/seekWord.php?class=' + CLASS + "&word=" + word + "&inc=" + INC, {
				method: 'get',
				mode: 'cors',
				headers: {
					'Content-Type': 'application/json'
				}
			})
			.then(response => {
				return response.json();
			})
			.then(json => {
				if (json > -1) {
					// Put selected word in the middle of the word collection				
					INC = json - 3;
					let ind = 3;
					let mid = N_INC/2;
					if (json < mid - 1) {					
						INC = 0;
						ind = json;
					}
					getWords(ind);
				} else {
					// If no exact match then check for matching conjugations within class
					fetch('backend/getConj.php?word=' + word + '&class=' + CLASS, {
						method: 'get',
						mode: 'cors',
						headers: {
							'Content-Type': 'application/json'
						}
					})
					.then(response => {
						return response.json()
					})
					.then(json => {
						let res = json["word"];							
						if (res != "") {								
							setClass(json["class"],res);
						} else {
							let follow = false;
							if (word.indexOf("\\") != -1 || word.indexOf("<") != -1) {
								word = word.replaceAll("\\","");
								word = word.replaceAll("<","");
								follow = true;
							}
							// If no match in specific class useful to show matches in other classes.
							fetch('backend/getDefAll.php?word=' + word, {
								method: 'get',
								mode: 'cors',
								headers: {
									'Content-Type': 'application/json'
								}
							})
							.then(response => {
								return response.json();
							})
							.then(json => {
								if (Object.keys(json).length > 0) {
									let keys = Object.keys(json);	
									if (keys.length === 1 && keys[0] != CLASS) {			
										// Go direct to class if no ambiguity in found word(s)
										setClass(keys[0]);
										seekWord(word);
									}
									let def = "";
									let delim ="";									
									let tmp = "<span onmouseover=\"highlight(this,event)\""
									if (SHOW_HELP) tmp += "title='Navigate to class \"_k_\"'";
									tmp += "onclick=\"setClass(\'_k_\',\'_w_\')\"><i>_k_:</i></span><br>";						
									for (let i = 0; i < keys.length; i++) {			
										let compDef = json[keys[i]];															
										def += delim + tmp.replaceAll("_k_", keys[i]).replace("_w_",word) + makeLinks(compDef);
										delim="<br>";
									}
									LAST_DEF = def;
									$('#iParDef').html("<b>" + word + ":</b><br>" + def);
								} else {
									// If no match then try to find match in conjugations
									fetch('backend/getConj.php?word=' + word + "&class=all", {
										method: 'get',
										mode: 'cors',
										headers: {
											'Content-Type': 'application/json'							
										}
									})
									.then(response => {
										return response.json()
									})
									.then(json => {
										if (json["word"] != "") {									
											setClass(json["class"],json["word"]);
										} else {								
											$('#iParDef').html("No matches in any word class.");	
											$('#iInput').val(word);
										}
									})
									.catch(error => {
										console.log(error);
									})					
								}
							})
							.catch(error => {
								console.log(error);
							})
						}
					})
					.catch(error => {
						console.log(error);
					})										
				}
			})
			.catch(error => {
				console.log(error);
			})
		}
	}
	if (DEBUG) console.log("END seekWord(); word = " + word + " -> INC = " + INC);			
}
function drillDown() {
	if (DEBUG) console.log("drillDown()");
	
	let word = $('#iInput').val()
	fetch('backend/getDefAll.php?word=' + word, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		if (Object.keys(json).length > 0) {
			let keys = Object.keys(json);	
			if (keys.length === 1 && keys[0] != CLASS) {			
			// Go direct to class if no ambiguity in found word(s)
				setClass(keys[0]);
				seekWord(word);
				let def = "";
				let delim ="";									
				let tmp = "<span onmouseover=\"highlight(this,event)\"";
				if (SHOW_HELP) tmp += "title= 'Navigate to class \"_k_\"'";
				tmp += "onclick=\"setClass(\'_k_\',\'_w_\')\"><i>_k_:</i></span><br>";						
				for (let i = 0; i < keys.length; i++) {			
				let compDef = json[keys[i]];															
				def += delim + tmp.replaceAll("_k_", keys[i]).replace("_w_",word) + makeLinks(compDef);
				delim="<br>";
				LAST_DEF = def;
				$('#iParDef').html("<b>" + word + ":</b><br>" + def);
				}
			}
		}
	})
	.catch(error => {
		console.log(error);
	})
}
function setClass(c, seek = "") {
	
	if (DEBUG) console.log("setClass(c, seek), c = " + c + ", seek = " + seek);
	LAST_CLASS = CLASS;
	wordCount();
	if (c != CLASS) {
		REGEX_WORDS = [];
		REGEX_WORDS = [];
		N_REGEX = 0;
		$('#iCntRegex').html("");
		$('#iDefDiv').css("display", "none");
		$('#iWords').css("visibility", "visible");
		if (c != "all") {
			$('#iDefProgContainer').css("visibility","visible");
		} else {
			$('#iDefProgContainer').css("visibility","hidden");
		}
		CLASS = c;
		INC = 0;
		SCROLL_INC=-1;
		setN_CUR();	
		countDefs();
		getWords(-1);
		updateScore();
	}
	if (seek.length > 0) seekWordSingleClass(seek);
	if (DEBUG) console.log("setClass(c, seek); CLASS = " + CLASS + ", seek = " + seek + ", INC = " + INC + ", SCROLL_INC = " + SCROLL_INC + ", N_CUR = " + N_CUR);	
}
function getLastWord() {
	if (DEBUG) console.log("getLastWord()")	
	setClass(LAST_CLASS);
	$('#iInput').val(LAST_WORD);
	seekWordSingleClass(LAST_WORD);	
}
function countDefs() {
	N_DEFS = 0;
	fetch('backend/countDef.php?class=' + CLASS, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		if (json != "Failed to read definition file.") {	
			N_DEFS=json;
			if (DEBUG) console.log("countDefs(); N_DEFS = " + N_DEFS);
			$('#iDefProg').css("width", N_DEFS/N_CUR * 100 + "%");
		} else {
			if (DEBUG) console.log("countDefs(); N_DEFS = " + N_DEFS);
		}
	})
}

function editDef() {	
	if (DEBUG) console.log("editDef()")	
	if ($('#iParDef').text() != "") {
		showWords();
		$('#iDefDiv').css("display", "block");
		$('#iPutDef').css("display", "block");
		$('#iDivMore').css("display", "none");
		$('#iDefText').focus();		
	}
}
function editDefWrapper(e) {
	e.preventDefault()
	editDef()
}
function clearDef() {
	if (DEBUG) console.log("clearDef()");
	if ($('#iWords').css("visibility") === "hidden") {
		$('#iParDef').html("");
		$('#iWords').css("visibility", "visible");
		$('#iDefDiv').css("display", "none");
		SCROLL_INC = -1;
		for (let i = 0; i< N_FOUND; i++) {
			$('#w' + i).css("fontWeight", "");
		}
	}
}
function pretty(def) {
	if (DEBUG) console.log("pretty(def); def = " + def);
	let out = "";
	subdefs = def.split("<br>");
	for (let i = 0; i < subdefs.length; i++) {
		del = "<br>";
		if (i === 0) del="";
		s = subdefs[i];		
		pJFR = s.indexOf("JFR");
		pSE = s.indexOf("SE");
		pMOTS = s.indexOf("MOTSATS");
		pSYN = s.indexOf("SYN");
		let tot = pJFR + pSE + pMOTS + pSYN;
		if (tot === -4) {
			out = out + del + s;
		} else {
			// New line before the JFR, SE, MOTS indicators for styling
			if (pJFR === -1) pJFR = 999999;
			if (pSE === -1) pSE = 999999;
			if (pMOTS === -1) pMOTS = 999999;
			if (pSYN === -1) pSYN = 999999;
			let start = pSE;
			if (pJFR < start) start = pJFR;
			if (pMOTS < start) start = pMOTS;
			if (pSYN < start) start = pSYN;
			let def2 =  s.slice(start,s.length);
			s = s.slice(0,start) + "<br>"
			def2 = def2.replaceAll("1","").replaceAll("2","").replaceAll("3","").replaceAll("4","");
			def2 = def2.replaceAll(" ,",",").replaceAll("  ", " ");
			def2 = def2.replaceAll(" 1<br>","<br>");
			out = out + del + s + def2;
		}
	}
	out = out.replaceAll("<br><br>","<br>");
	for (let i = 1; i < 24; i++) {
		out = out.replaceAll(i + " " + i, i);
		out = out.replaceAll("<br>" + i + "<br>","<br>" );
		out = out.replaceAll("<br> " + i + "<br>","<br>" );
		out = out.replaceAll("<br>" + i + " <br>","<br>" );
	}
	// Strip any leading new line
	if (out.slice(0,3) === "<br>") {
		out = out.slice(4,out.length) 
	}
	const regex1 = /[a-z][1-9]/;
	match = out.match(regex1);
	if (match != null) {
		console.log(match);
		strMatch = match[0];
		rep = strMatch[0] + "<br> " + strMatch[1];
		out = out.replace(strMatch, rep);
	}
	if (out[0] === " ") out = out.slice(1,out.length);
	out = out.replace("partikelntill", "partikeln till;");
	if (out[out.length-1] === ",") out = out.slice(0,out.length-1)
	return out;
}
function fullClassName(name) {
	if (name === "") return "all"
	if (name === "a") return "all"
	if (name === "en") return "substantiv_en"
	if (name === "ett") return "substantiv_ett"
	if (name === "adj") return "adjektiv"
	if (name === "adv") return "adverb"
	if (name === "fra") return "fraser"
	if (name === "sub") return "subjunktion"	
	if (name === "plu") return "plural"
	if (name === "prep") return "preposition"
	if (name === "pro") return "pronomen"
	if (name === "for") return "förled"
	if (name === "för") return "förled"
	if (name === "slut") return "slutled"
	if (name === "slut") return "slutled"
	if (name === "räk") return "räkneord"
	if (name === "kon") return "konjunktion"
	if (name === "int") return "interjektion"
	return name
}
function guessClass(word) {
	// Prefer explicit definition of class
	if (word.includes('(') && word.includes(')')) {
		// grab class	
		let start = word.indexOf('(')
		let end = word.indexOf(')')	
		if (start > end || start === -1) return 
		let c = word.slice(start+1,end);
		c = fullClassName(c);
		return c;
	} 
	// Otherwise try and semi-intelligently guess word class
	if (word.endsWith('a')) return "verb"
	if (word.endsWith('as')) return "verb"
	if (word.includes(' ')) return "verb"
	if (word.endsWith("ig")) return "adjektiv"
	if (word.endsWith("lös")) return "adjektiv"
	if (word.endsWith("sam")) return "adjektiv"
	if (word.endsWith("full")) return "adjektiv"
	if (word.endsWith("ell")) return "adjektiv"
	if (word.endsWith("isk")) return "adjektiv"
	if (word.endsWith("ad")) return "adjektiv"
	if (word.endsWith("en")) return "adjektiv"
	if (word.endsWith("p")) return "substantiv_ett"
	if (word.endsWith("ism")) return "substantiv_en"
	return "substantiv_en"
}
function removeClassDesc(word) {
	let start = word.indexOf('(');
	let end = word.indexOf(')');
	if (start > end || start === -1) return word 	
	return word.slice(0,start-1)
			
}
function addWord() {	
	if (DEBUG) console.log("addWord()");	
	let word = $('#iInput').val();	
	if (word.indexOf('+') != -1) {
		tmp = word.split('+');
		word = tmp[0];
		tmpClass = tmp[1];
		if (tmpClass.length > 1) setClass(tmpClass);
		$('#iInput').val(word);
		
	}
	let del = word[word.length-1] === ".";
	if (word[0] === '.') word = word.slice(1,word.length);
	if (word[word.length-1] === '.') word = word.slice(0,word.length-1);
	if (word.length > 0) {
		let op = "add"	
		if (del) op = "remove"
		fetch('backend/' + op + 'Word.php?class=' + CLASS + "&word=" + word, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			if (op === "remove") {
				// If this was the last listing of this word delete from "all" listing also
				fetch('backend/getDefAll.php?class=all&word=' + word, {
					method: 'get',
					mode: 'cors',
					headers: {
						'Content-Type': 'application/json'
					}
				})
				.then(response => {
					return response.json();
				})
				.then(json => {
					// It was last reference
					if (json.length < 1) {
						fetch('backend/removeWord.php?class=all&word=' + word, {
							method: 'get',
							mode: 'cors',
							headers: {
								'Content-Type': 'application/json'
							}
						})
						.catch(error => {
							console.log(error);
						})
						getWords();
						wordCount();
					}
				})
				.catch(error => {
					console.log(error);
				})
			// Navigate to newly added word for convenience.
			} else if (op === "add") {
				seekWordSingleClass(word)
			}
		})
		.catch(error => {
			console.log(error);	
		})
	}
}

function addMeta(def, regx) {
	// If a known meta phrase is identified at start of definition line then enclose it in square bracket formatting
	if (DEBUG) console.log("addMeta(), regx =´" + regx);
	if (def.length < 3 || def[0].match(/A-Z/)) return def
	// Only apply one meta tag
	if (def[2] === "[" && def.indexOf("]") > 2) return def;	
	// Probably don't actual need regex but leave "ias is" for now
	let rawStr = regx.source;
	browserDependentDelim = "";
	if (navigator.userAgent.indexOf("Chrome") != -1 ) {
		browserDependentDelim = " ";
	}
	
	if (def.indexOf(rawStr) === 2) {
		def = def.replace(rawStr, "[" + rawStr + "]" + browserDependentDelim);
	}
	return def;
}

function grammer(def, rep) {
	// Only one grammer expression is permitted
	if (def.indexOf(rep) != -1) {
		end = def.indexOf(rep) + rep.length;
		let after = def.substring(end,end+1);
		if (after === ")") return def
	}
	return def.replace(" " + rep, " (" + rep + ")");
}
function preProc(def) {
	if (DEBUG) console.log("preProc(def(); def = '" + def + "'")
	// return def and meta components
	// " ++" is a user-control, remove is present in definition
	def = def.replaceAll(" ++","");
	// Check if any meta information exists		
	if (def[0] === " ") def = def.slice(1);
	let meta = "";
	
	let defArr = def.split("\n");
	// Concenate if multiple spellings are present
	
	if (defArr.length > 3 && defArr[1] === "eller" || defArr[1] === "även" || defArr[1] === "även åld." || defArr[1] === "även vardagligt" || defArr[1] === "eller vardagligt") {
		defArr[0] = defArr[0] + " </i>" + defArr[1] + " <i>" + defArr[2];
		// Move remaining items up two elements
		for (i = 3; i < defArr.length; i++) {
			defArr[i-2] = defArr[i]
		}
		defArr.pop();
		defArr.pop();		
	}

	let firstLine = defArr[0];
	let opts = firstLine.split(" ");
	let firstWord = opts[0];
	let twoWords = "";
	let threeWords = "";
	let fourWords = "";
	if (opts.length > 1) twoWords = firstWord + " " + opts[1];		
	if (opts.length > 2) threeWords = twoWords + " " + opts[2];
	if (opts.length > 3) fourWords = threeWords + " " + opts[3];
	
	var m;
	if (CLASS === "slutled") {
		m = "-" + CUR_WORD;
	} else if (CLASS === "förled") {
		m = CUR_WORD + "-";
	} else {
		m = CUR_WORD;
	}	
	
	if (firstWord === m || twoWords === m || threeWords === m || fourWords === m) {		
		meta = defArr[0].replaceAll("_"," ");		
		let del = "";
		def = "";
		for (let i = 1; i < defArr.length; i++) {		
			if (i < 3) {							
				if (defArr[i].indexOf('\u25cf') === 0) {
					def += del + defArr[i];
					del = "\n";
				} else {
					meta += "<br>" + defArr[i].replace("ORDKLASS: ","").replace("UTTAL: ","");
				}
			} else {
				def += del + defArr[i];
				del = "\n";
			}
		}
	}
	
	// Split definition
	def = def.replaceAll(" JFR", "\nJFR");
	def = def.replaceAll(" SE", "\nSE");
	def = def.replaceAll(" SYN.", "\nSYN.");
	def = def.replaceAll(" MOTSATS", "\nMOTSATS");	
	arr = def.split("\n");
	let outDef = "";
	// Grammer information - Support for partikel parters
	// Can be between 1 and 3 suggested partner words
	let regex1 = /skilt[a-zäöå]+/;
	let regex1_alt = /partikeln[a-zäöå]+/;
	let regex2 = /skilt[a-zäöå]+, [a-zäöå]+/;
	let regex3 = /skilt[a-zäöå]+, [a-zäöå]+, [a-zäöå]+/;
	// Delimiter is blank on first line
	let del = "";
	for (s of arr) {				
		if (s.length > 1) {
			// Remove any leading space(s)
			while (s[0] === " ") {
				s = s.slice(1,s.length)
			}
			// Defuault to "pretty" leading bullet point
			if (s[0].match(/[a-zäöå]+/) != null) {
				s = `\u25CF ` + s;
			}
			// Leading Meta tags
			// Beware the silent hyphens (\u00AD)			
			// ToDo Move the (many) regx definitions to the function body
			s = addMeta(s, /var­dagligt, kan upp­fattas som ned­sättande/);
			s = addMeta(s, /var­dagligt, något ålderdomligt; kan upp­fattas som ned­sättande/);
			s = addMeta(s, /var­dagligt; något ålderdomligt/);
			s = addMeta(s, /språk­vetenskap/);
			s = addMeta(s, /sär­skilt i affärs­mässiga och vetenskapliga samman­hang/);
			s = addMeta(s, /samman­fattande, formell beteckning/);
			s = addMeta(s, /nu­mera ej officiell benämning/);
			s = addMeta(s, /ofta i värderande ut­tryck/);
			s = addMeta(s,/ofta statistik/);
			s = addMeta(s, /ofta ironiskt/);
			s = addMeta(s,/mest i vetenskapliga samman­hang/);
			s = addMeta(s, /nu­mera sällan i fack­mässiga samman­hang/);
			s = addMeta(s, /nu­mera mindre brukligt i fack­mässiga samman­hang/);
			s = addMeta(s, /i fackspråkliga samman­hang/);
			s = addMeta(s, /nu­mera mindre brukligt/);
			s = addMeta(s,/ofta i religiösa samman­hang/);
			s = addMeta(s,/sär­skilt bibliskt; något ålderdomligt ut­om i vissa ut­tryck/);
			s = addMeta(s,/sär­skilt geometri/);
			s = addMeta(s, /ofta i bild­konst/);
			s = addMeta(s,/mest som marxistisk term/);
			s = addMeta(s,/sär­skilt medicin, psykologi/);
			s = addMeta(s,/sär­skilt medicin/);
			s = addMeta(s,/sär­skilt i handels­språk/);
			s = addMeta(s,/medicin/);
			s = addMeta(s,/något hög­tidligt ut\u00ADom i sammansättn./);
			s = addMeta(s, /hög­tidligt; mest bibliskt/);
			s = addMeta(s,/något hög­tidligt el. formellt/);			
			s = addMeta(s,/något hög­tidligt el. skämtsamt/);
			s = addMeta(s,/ibland något hög­tidligt/);		
			s = addMeta(s,/något hög­tidligt/);		
			s = addMeta(s,/hög­tidligt/);					
			s = addMeta(s,/något var­dagligt/);		
			s = addMeta(s,/var­dagligt; dialektalt/);
			s = addMeta(s,/var­dagligt; något ned­sättande/);
			s = addMeta(s,/var­dagligt; ned­sättande/);
			s = addMeta(s,/ibland något ned­sättande/);
			s = addMeta(s,/något ned­sättande/);
			s = addMeta(s,/ned­sättande; ålderdomligt/);
			s = addMeta(s, /var­dagligt; vanligen något ned­sättande/);
			s = addMeta(s,/var­dagligt; ned\u00ADsättande/);
			s = addMeta(s,/var­dagligt, ibland något ned­sättande/);
			s = addMeta(s,/var­dagligt; sär­skilt sport/);
			s = addMeta(s,/starkt var­dagligt/);
			s = addMeta(s,/var­dagligt/);
			s = addMeta(s,/dialektalt/);
			s = addMeta(s,/i fack­språk/);
			s = addMeta(s,/ofta i fackspråkliga samman­hang/);
			s = addMeta(s, /nu\u00ADmera ej i fack\u00ADmässiga samman\u00ADhang/);
			s = addMeta(s,/nu­mera mindre brukligt i fack\u00ADmässiga samman\u00ADhang/);
			s = addMeta(s,/mindre brukligt/);
			s = addMeta(s,/sär­skilt ekonomi/);
			s = addMeta(s,/sär­skilt i matematiskt fack­språk/);
			s = addMeta(s,/sär­skilt matematik/);
			s = addMeta(s,/matematisk/);
			s = addMeta(s,/fysik, kemi m.m./);
			s = addMeta(s,/fysik/);		
			s = addMeta(s,/sär­skilt i juridiska samman\u00ADhang/);
			s = addMeta(s,/sär­skilt juridik/);
			s = addMeta(s,/juridik/);	
			s = addMeta(s,/sär­skilt i lag­språk/);
			s = addMeta(s,/sär­skilt psykologi/);
			s = addMeta(s,/psykologi/);
			s = addMeta(s,/informations­teknik/);
			s = addMeta(s,/sär­skilt i fack­språk/);
			s = addMeta(s,/ofta i fack­språk/);
			s = addMeta(s,/mest i fack­mässiga samman­hang/);
			s = addMeta(s,/ålderdomligt ut\u00ADom i bibliska samman\u00ADhang/);
			s = addMeta(s,/ålderdomligt ut­om i vissa ut­tryck/);
			s = addMeta(s,/delvis något ålderdomligt/);
			s = addMeta(s,/något ålderdomligt/);
			s = addMeta(s,/något ålderdomligt el. ironiskt/);
			s = addMeta(s,/ålderdomligt/);
			s = addMeta(s,/sär­skilt vid beskrivning av ut­ländska förhållanden/);
			s = addMeta(s,/endast vid beskrivning av ut­ländska förhållanden/);
			s = addMeta(s,/något formellt/);
			s = addMeta(s,/formellt i konkret an­vändning/); 
			s = addMeta(s,/formellt/);			
			s = addMeta(s,/delvis historiskt/);
			s = addMeta(s,/mest historiskt/);
			s = addMeta(s,/historiskt i Sverige/);
			s = addMeta(s,/historiskt/);
			s = addMeta(s,/sär\u00ADskilt i barn\u00ADspråk och i imiterat barn\u00ADspråk/);			
			s = addMeta(s, /mest i fack\u00ADspråk/);
			s = addMeta(s, /mest i sport­jargong/);
			s = addMeta(s, /sär­skilt i vetenskapliga samman­hang/);
			s = addMeta(s, /ofta i tekniska el. vetenskapliga samman­hang/);
			s = addMeta(s, /i tekniska och vetenskapliga samman­hang/);
			s = addMeta(s, /i vetenskapliga samman­hang/);
			s = addMeta(s, /mest i tekniska samman­hang/);
			s = addMeta(s,/mest i vetenskapliga samman\u00ADhang/);
			s = addMeta(s,/sär­skilt i vetenskapliga samman\u00ADhang/);
			s = addMeta(s, /i vetenskapliga samman\u00ADhang/);
			s = addMeta(s, /ålderdomligt el. skämtsamt/);
			s = addMeta(s, /ofta klandrande/);
			s = addMeta(s,/mest vid beskrivning av äldre förhållanden/);
			s = addMeta(s,/sär­skilt vid beskrivning av äldre förhållanden/);
			s = addMeta(s,/äv. som musikalisk term/);
			s = addMeta(s,/musikalisk/);
			s = addMeta(s,/musik/);
			s = addMeta(s,/sär­skilt meteorologi/);
			s = addMeta(s,/sär­skilt i vänster­politisk debatt/);
			s = addMeta(s,/ofta i vänster­politisk debatt/);
			s = addMeta(s,/ofta ned­sättande/);
			s = addMeta(s,/ofta något ned­sättande/);
			s = addMeta(s,/ned­sättande; något ålderdomligt/);
			s = addMeta(s,/ned­sättande/);
			s = addMeta(s,/ibland skämtsamt/);
			s = addMeta(s,/ibland något skämtsamt/);
			s = addMeta(s,/sär­skilt statistik/);
			s = addMeta(s,/sär­skilt filosofi, biologi/);
			s = addMeta(s,/sär­skilt filosofi/);			
			s = addMeta(s,/filosofi/);			
			s = addMeta(s,/i allmän­språket/);
			s = addMeta(s,/sär­skilt sport/);
			s = addMeta(s,/sär­skilt militär­väsen och sport/);
			s = addMeta(s,/sär­skilt militär­väsen/);
			s = addMeta(s,/sär­skilt sjö­fart/);
			s = addMeta(s,/ibland något ironiskt/);
			s = addMeta(s,/sär­skilt arkeologi/);
			s = addMeta(s, /ej officiell svensk beteckning/);
			s = addMeta(s, /nu­mera ej officiell beteckning/);
			s = addMeta(s, /förskönande om­skrivning/);
			s = addMeta(s, /bibliskt/);
			s = addMeta(s,/ofta fysik och teknik/);
			// Remove any reference numbers other than that at line start
			let trail = s.slice(2,s.length);
			for (let i = 1; i < 24; i++) {				
				trail = trail.replaceAll(" " + i + " "," ");
				if (trail.indexOf(i) === 0) {
					trail = trail.replaceAll(i,"");
				}
			}
			s = s.slice(0,2) + trail;		
			s = s.replaceAll("  ", " ");
			s = s.replaceAll("  ", " ");
			let match = s.match(/[\s]+[,]+/i);
			if (match) {
				s = s.replaceAll(match[0],",");				
			}
			
			let m = s.match(regex1);
			let m_alt = s.match(regex1_alt);
			let m2 = s.match(regex2);
			let m3 = s.match(regex3);
			let rep = ""
			if (m3 != null) {
				let strMatch = m3[0];
				let rep = strMatch.slice(0,5) + " " + strMatch.slice(5,strMatch.length) + ")";
				s = s.replace(strMatch, rep);
			} else if (m2 != null) {
				let strMatch = m2[0];
				rep = strMatch.slice(0,5) + " " + strMatch.slice(5,strMatch.length) + ")";
				s = s.replace(strMatch, rep);
			} else if (m != null) {
				let strMatch = m[0];
				let rep = strMatch.slice(0,5) + " " + strMatch.slice(5,strMatch.length) + ")";
				s = s.replace(strMatch, rep);
			} else if (m_alt != null) {
				let strMatch = m_alt[0];
				let rep = strMatch.slice(0,9) + " " + strMatch.slice(9,strMatch.length) + ")";
				s = s.replace(strMatch, rep);
			}
			s = s.replace("ibland med partikel","(ibland med partikel");
			s = s.replace("vanligen med partikel","(vanligen med partikel");
			s = s.replace("ofta med partikel","(ofta med partikel");
			let f1 = "utan) större betydelse­skillnad";
			let f2 = "), utan större betydelse­förändring";
			let f3 = "), utan större betydelse­skillnad";
			let f4 = "utan) större betydelse­förändring";
			s = s.replace(f1, f1.replace(")","") + ")");
			s = s.replace(f2,f2.replace(")","") + ")");
			s = s.replace(f3,f3.replace(")","") + ")");
			s = s.replace(f4,f4.replace(")","") + ")");
			if (s.includes("((")) s = s.replace("((", "(");
			// Trailing spaces (or non-breaking space) can break links, remove
			let lastCh = s.charAt(s.length-1);			
			if (lastCh.charCodeAt(0) === 32 || lastCh.charCodeAt(0) === 160) {								
				s = s.slice(0,s.length-1)
			}
			// ToDo Move the (many) grammer pattern definitions to the function body
			// grammer information
			
			s = grammer(s, "ofta i substantivisk an­vändning")
			s = grammer(s, "nästan en­bart bestämd form sing.")
			s = grammer(s, "vanligen i böjda former");
			s = grammer(s, "nästan alltid bestämd form sing. och med versal");
			s = grammer(s, "ofta bestämd form sing. och med versal");
			s = grammer(s, "vanligen bestämd form sing. och med versal");
			s = grammer(s, "med subst. som för­led");
			s = grammer(s, "vanligen placerat efter huvud­ordet");
			s = grammer(s,"ofta med versal");
			s = grammer(s,"ofta med efter­följande bi­sats");
			s = grammer(s,"sär­skilt i pass. konstruktioner");
			s = grammer(s,"i konstruktion med komparativ");
			s = grammer(s,"ofta substantiverat");
			s = grammer(s, "ofta refl. el. pass.");
			s = grammer(s,"ofta refl.");			
			s = grammer(s,"med konjunktionen",);
			s = grammer(s,"vanligen pres.");
			s = grammer(s,"endast pres. el. pret.");
			s = grammer(s,"i bestämd form");
			s = grammer(s,"vanligen bestämd form sing.");
			s = grammer(s,"ofta bestämd form sing.");
			s = grammer(s,"vanligen bestämd form");
			s = grammer(s,"ofta plur.");
			s = grammer(s,"knappast plur.; i vissa ut\u00ADtryck");
			s = grammer(s,"knappast plur.");
			s = grammer(s,"vanligen plur.");
			s = grammer(s,"sällan plur.");
			s = grammer(s,"vanligen part.");
			// ToDo regex to get word reference	
			s = grammer(s,"ofta i sammansättn.");		
			s = grammer(s,"mest i sammansättn.");
			s = grammer(s,"nu­mera vanligen i sammansätt.");	
			s = grammer(s,"vanligen i sammansättn. och i vissa uttryck");
			s = grammer(s,"vanligen i sammansättn.");
			s = grammer(s,"vanligen i vissa sammansätt.");			
			s = grammer(s,"i vissa ut­tryck och sammansättn.");			
			s = grammer(s,"i sammansättn.");
			// ToDo regex this one			
			s = grammer(s,"vanligen i vissa ut\u00ADtryck");
			s = grammer(s,"utan böjning, i vissa ut\u00ADtryck");
			s = grammer(s,"i vissa ut\u00ADtryck");
			s = grammer(s,"i några ut\u00ADtryck");
			s = grammer(s, "ofta pass. el. perfekt particip");
			s = grammer(s,"ofta pass.");			
			s = grammer(s,"vanligen pass. el. presens particip");
			s = grammer(s,"vanligen pass. el. perfekt particip");
			s = grammer(s,"vanligen pass. och perfekt particip");
			s = grammer(s,"vanligen pass. el. part.");
			s = grammer(s,"vanligen refl. el. pass.");
			s = grammer(s,"ofta bestämd form");
			s = grammer(s,"ofta perfekt particip");
			s = grammer(s,"ofta presens particip");
			s = grammer(s, "nästan en­bart pres. el. pret.");
			s = grammer(s,"vanligen perfekt particip");			
			s = grammer(s,"vanligen obestämd form sing.");
			s = grammer(s,"vanligen obestämd form");
			s = grammer(s,"ibl. två ord");
			s = grammer(s,"äv. två ord");
			s = grammer(s,"vanl. två ord");
			s = grammer(s,"äv. tre ord");
			s = grammer(s,"ofta tre ord");
			s = grammer(s,"vanl. tre ord");
			s = grammer(s,"nästan en\u00ADbart i sammansättn.");
			s = grammer(s,"nästan en­bart predikativt");
			s = grammer(s,"endast predikativt");
			s = grammer(s,"vanligen i konstruktioner");
			s = grammer(s,"vanligen i konstruktion");
			s = grammer(s,"vanligen i opersonliga konstruktioner");			
			s = grammer(s,"i opersonliga konstruktioner");			
			s = grammer(s,"vanligen opersonlig konstruktion");
			s = grammer(s,"vanligen koll.");
			s = grammer(s, "ofta koll.");
			s = grammer(s,"i nekande ut­tryck");
			s = grammer(s,"ofta i nekande el. frågande ut­tryck");
			s = grammer(s,"ofta i nekande konstruktion");
			s = grammer(s,"vanligen i nekande el. frågande ut­tryck");
			s = grammer(s,"ofta i nekande ut­tryck");
			s = grammer(s,"vanligen i nekande ut­tryck");
			s = grammer(s,"nästan en­bart plur.");
			s = grammer(s,"i plur.");
			s = grammer(s,"vanligen predikativt");
			s = grammer(s,"äv. två ord");
			s = grammer(s,"ofta två ord");
			s = grammer(s,"i negerade samman­hang");
			s = grammer(s,"ofta i negerade ut­tryck");	
			s = grammer(s,"i negerade ut­tryck");
			s = grammer(s, "i ett få­tal ut­tryck");
			s = grammer(s, "i negerade el. frågande samman­hang");
			s = grammer(s, "vanligen supinum");
			s = grammer(s, "ofta best. form sing.");
			s = grammer(s, "ej predikativt");
			s = grammer(s, "vanligen pass.");
			s = grammer(s, "vanligen presens particip");
			s = s.replace("vanligen med pronomenetsjälv","(vanligen med pronomenet själv)");
			// ToDo Regex this to include the multi-word verbs			
			s = fmtVerbApart(s,/(äv. lös förbindelse, se )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = s.replace("formerna", "formerna ");
			s = s.replace("formen", "formen ");
			s = fmtVerbApart(s,/(äv. lös förbindelse i formen )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = fmtVerbApart(s,/(äv. lös förbindelse, jfr )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = fmtVerbApart(s,/(ofta lös förbindelse i formen )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = fmtVerbApart(s,/(ofta lös förbindelse, se )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = fmtVerbApart(s,/(ofta lös förbindelse se )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = fmtVerbApart(s,/(ofta lös förbindelse, jfr )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = fmtVerbApart(s,/(vanligen lös förbindelse, se )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = fmtVerbApart(s,/(vanligen lös förbindelse, jfr )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = fmtVerbApart(s,/(äv. lös sammansättn., se )([a-zöäå]+)(\s[a-zöäå_]+)/);			
			// Format "fast sammansättn." grammer
			s = fmtVerbTogether(s,/(vanligen fast sammansättn., se )([a-zöäå_]+)/);
			s = fmtVerbTogether(s,/(vanligen fast sammansättn., jfr )([a-zöäå_]+)/);
			s = fmtVerbTogether(s,/(någon gång fast sammansättn., se )([a-zöäå_]+)/);
			s = fmtVerbTogether(s,/(ofta fast sammansättn., se )([a-zöäå_]+)/);
			s = fmtVerbTogether(s,/(ofta fast sammansättn., jfr )([a-zöäå_]+)/);
			s = fmtVerbTogether(s,/(äv. fast sammansättn., se )([a-zöäå_]+)/);			
			s = fmtVerbTogether(s,/(äv. fast sammansättn., jfr )([a-zöäå_]+)/);			
			s = simpleRef(s);		
			s = simpleBold(s);		
			// ToDo Regex this to include the verb
			//s = grammer(s,"vanligen i förbindelse");
			s = handlePrep(s);
			s = s.replaceAll("_","");
			s = simpleLink(s);
			outDef += del + s;			
			// HTML newline separator bon lines subsequent to the first
			del = "<br>";
		}
	}
	var out = []
	out[0] = outDef;
	out[1] = meta;
	// That's it!
	return out;
}
function fmtVerbTogether(s,regx) {
	if (DEBUG) console.log("fmtVerbTogether(s,regx), s = " + s + ", regx = " + regx);	
	m = s.match(regx);
	
	if (m != null) {
		if (m.length === 3) {			
			let link = "<span onmouseover=highlight(this,event)";
			if (SHOW_HELP) link += "title='Navigate to \"_w_\"'"
			link += "onclick=followLink(this)><b>_w_</b></span>".replaceAll("_w_",m[2]);				
			// Allow user to extend the verb to include another partikel e.g. "sig"
			link = link.replaceAll("__"," ");
			s = s.replace(m[0],"(" + m[1] + link + ")");
		}
	}
	return s
}
function  fmtVerbApart(s,regx) {
	if (DEBUG) console.log("fmtVerbApart(s,regx), s = " + s + ", regx = " + regx);
	m = s.match(regx);
	if (m != null) {
		if (DEBUG) console.log("fmtVerbApart: Match!");
		if (m.length === 4) {
			let repWord = m[2] + " " + m[3].substring(1);
			
			// remove leading space from second word and replace with regular space.
			let link = "<span onmouseover=highlight(this,event)";
			if (SHOW_HELP) {
				link += "title ='Navigate to \"_w_\"'";
			}
			link += "onclick=followLink(this)><b>_w_</b></span>";
			link = link.replaceAll("_w_", repWord);
			// Allow user to match only a single verb word
			link = link.replaceAll(" __","");
			link = link.replaceAll("___", " ");
			s = s.replace(m[0],"(" + m[1] + link + ")");			
		}
	}
	return s	
}
function simpleRef(s) {
	regx = "/\(se äv. ([a-zöäå]+)\)/"
	let link = "<span onmouseover=highlight(this,event)"
	if (SHOW_HELP) {
		link += "title ='Navigate to \"_w_\"'" 
	}
	link += "onclick=followLink(this)><b>_w_</b></span>"
	m = s.match(regx);
	if (m) {
		s = s.replace(m[0],"(se äv. " + link.replaceAll("_w_",m[2]) + ")");
	}
	return s;
}
function simpleBold(s) {
	regx = "((vanligen (?:med )?komparativ)([a-zöäå]+))"
	let bold = "<b>_w_</b>";
	m = s.match(regx);
	if (m) {
		s = s.replace(m[0],"(" + m[2] + " " + bold.replaceAll("_w_"," " + m[3]) + ")");
	}	
	return s;
}
function withParticle(s) {
	rep = "ibland with partikel";
	s = s.replace(rep, "(" + rep);
	rep = "ofta with partikel";
	s = s.replace(rep, "(" + rep)
	rep = "vanligen with partikel";
	s = s.replace(rep, "(" + rep);
	repo = "vanligen med någon av partiklarna";
	s = s.replace(rep, "(" + rep);
	return s;
}

function showWords() {
	if ($('#iWords').css("visibility") == "hidden") {
		$('#iWords').css("visibility", "visible");
	}
}
function highlight(el,event) {
	if (event.type === "mouseover") {
		el.style.cursor = "pointer";
	} else {
		el.style.cursor = "";
	}
}
function editCursor(event,el) {
	if (event.type === "mouseover") {
		el.style.cursor = "text";
	} else {
		el.style.cursor = "";
	}
}
function toggleDebugEv(e) {
	e.preventDefault();
	toggleDebug();
}
function toggleDebug() {
	DEBUG = !DEBUG;
	if (DEBUG) {
		console.log("Entering debug mode...");
		$('#iDebugTxt').text("DEBUG");
		$('#iDebug').css("color","gray");
	}  else {
		$('#iDebug').css("color","");
		$('#iDebugTxt').text("");
		console.log("Leaving debug mode...");
	}
}
function setClassGuessWrapper(ev) {
	ev.preventDefault();
	let word = $('#iInput').val();
	setClassGuess();	
	seekWord(word);
}
function setClassGuess() {
	let word = $('#iInput').val();
	let c = guessClass(word);
	if (DEBUG) console.log("setClassGuess, Class guessed as " + c)
	setClass(c);
	seekWord(CUR_WORD);
}
function lookupManyWords() {	
	// Clear existing tabs collection
	TABS.length = 0;
	let n = 8;			
	let start = parseInt(INC) + parseInt(SCROLL_INC);	
	if (start === -1) start = 0
	fetch('backend/getWords.php?&class=' + CLASS + "&start=" + start.toString() + "&num=" + n, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json()
	})
	.then(json => {
		if (json.length < n) n = json.length
		for (let i = 0; i < n; i++) {			
			let word = json[i]
			let url = "https://svenska.se/tre?sok=" + word + "&pz=1";
			// Manual unicode percentage escaping as some browsers misbehave here	
			TABS.push(window.open(bulletProofUrl(url), '_blank'));		
		}	
	})
	.catch(error => {
		console.log(error);
	})
}

function fmtMeta(meta) {
	let rep = "<span id='iWordRoot'"
	rep += " onmouseover=highlight(this,event)";
	rep += " onclick='changeScore(1)'";	
	if (SHOW_HELP) {
		rep += " title='Change score'"
	}
	rep += "><b>" + CUR_WORD + "</b></span>"
	meta = meta.replace(CUR_WORD,rep);
	metaArr = meta.split("<br>");
	let tmpMeta = "";
	delMeta = "";
	for (let i = 0; i < metaArr.length; i++) {						
		if (i == 0) {
			delMeta = "";
		} else if (i === 1) {
			delMeta = "<br>ORDKLASS: ";
		} else if (i === 2) {
			delMeta = "<br>UTTAL: ";
		} else {
			delMeta = "<br>";
		}
		tmpMeta += delMeta + metaArr[i];
	}
	tmpMeta = "<i>" + tmpMeta + "</i><br>"
	return tmpMeta;
}
function ScrollViewDownWrapper() {

	if (false && $('#iDefDiv').css("display") === "none") {
		scrollViewDown();
	}
}
function handlePrep(s) {
	// Can have 0, 1 or more preposition words
	// Works for a single preposition word
	// Maybe support multiple words later
	regx = /med prep.[a-zöäå]/;
	let m = s.match(regx);
	if (m != null) {
		s = s.replace(m[0], "(" + m[0] + ")");
		s = s.replace("prep.", "prep. ");		
	}
	return s;
}
function bulletProofUrl(url) {
	// Manually do escaping of Swedish unicode characters as browsers can misbehave here
	
	url = url.replaceAll("ä","%C3%A4");			
	url = url.replaceAll("å","%C3%A5");			
	url = url.replaceAll("ö","%C3%B6");	
	url = url.replaceAll("é","%C3%A9");
	return url
}
function closeDefs() {
	if (TABS.length === 0) {
		setClass("all");
	}
	for (i = 0; i < TABS.length; i++) {
		TABS[i].close();
	}
	TABS.length = 0;
}
function keyNav(ev) {
	ev.preventDefault();
	console.log("nav");
}
function editNext() {
	if (DEBUG) console.log("editNext()")
	if (SCROLL_INC < N_FOUND-1) {
		SCROLL_INC++;
	}
	let cur = "#w" + SCROLL_INC;
	CUR_WORD = $(cur).text();
	editDef();
	// ToDo show any current definition
}
function displaySelection() {
	for (let i = 0; i < N_FOUND; i++) {
		let tmp = "#w" + i;
		$(tmp).css("font-weight", "")
	}
	let cur = "#w" + SCROLL_INC;
	$(cur).css("font-weight", "bold");
}
function clickMiddle(ev) {
	if (DEBUG) console.log("clickMiddle()");
	ev.preventDefault();			
	if (ev.target.style.cursor != "pointer" && ev.target.className != "redWord" && ev.target.className != "blueWord") {
		if ($('#iDefDiv').css("display") === "none" && $('#iParDef').text() === "") { 
			let btn = ev.button;
			if (btn === 0) {
				scrollViewDown()
			} else {
				scrollViewUp(ev)
			}	
		}
	}
}
function getCurr() {
	if (SCROLL_INC === -1) {
		return INC
	} else {
		return (parseInt(INC) + parseInt(SCROLL_INC))
	}
}
function nextWord(el,ev) {
	ev.preventDefault();
	if (DEBUG) console.log("nextWord()")
	// Find the next word with the relevant score
	updateScore();
	let score = 0;
	if (el.className === "blueWord") score = 1
	let back = ev.button === 2;
	fetch('backend/getNextWord.php?class=' + CLASS + '&start=' + getCurr() + '&score=' + score + '&back=' + back, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json()
	})
	.then(json => {
		seekWord(json);
	})
	.catch(error => {
		console.log(error)
	})		
}
function putMore() {
	if (DEBUG) console.log("putMore()")	
	let more = $('#iDefText').val();
	more = more.replaceAll("\n","<br>");	
	if (more.substring(0,4) === "<br>") {
		more = more.substring(4);
	}
	if (more.indexOf("HISTORIK") == -1) {
		if (more.indexOf("<h>") != -1) {
			more = more.replace("<h>","HISTORIK:");
		} else {
			more = more.replace("belagt","HISTORIK:<br>belagt");
		}
	}
	let key = CUR_WORD.replaceAll(" ","-") + "_" + CUR_DEF;
	fetch('backend/putMore.php?key=' + key + '&class=' + CLASS + '&more=' + more, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		//Done
		$('#iDefText').val("");
		$('#iDefDiv').css("display", "none");
		$('#iDivMore').css("display", "none");
		toggleMore(key,true)
	})
	.catch(error => {
		console.log(error)
	})
}
// 1-based indices instead of 0-based for storage
function keyForUser(key) {
	start = key.indexOf("_");
	let res = key;
	if (start === -1) return key
	zero_based_ind = parseInt(key.substring(start+1));
	one_based_ind = zero_based_ind + 1
	res = key.replace("_" + zero_based_ind, "_" + one_based_ind);	

	return res
}
function toggleMore(key, show = false) {	
	if (DEBUG) console.log("toggleMore(key), key = " + key);		
	if (show === false)  {
		CACHED_DEF_HTML = $('#iParDef').html();		
	}		
	
	let start = key.indexOf("_");
	if (start != -1) CUR_DEF = key.substring(start+1);
	let id = "#iMore_" + key;
	let showMore = $(id).text() === " ++";

	if (showMore === true || show) {
		if (SHOW_HELP) {
			$(id).attr("title","Left: Hide\nRight: Add/Edit information");
		} else {
			$(id).attr("title","");
		}
		fetch('backend/showMore.php?class=' + CLASS + '&word=' + key, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json()
		})
		.then(json => {								
			if (json.length === 0) {
				$(id).html(" --<br>No more information to show");				
			} else {								
				let tmp = "<span onclick='showCachedDef(this)'"
				tmp += " oncontextmenu=editMore(event,'" + key + "')";
				if (SHOW_HELP) {
					tmp += " title = 'Left click = back to definition(s) "
					tmp += "\nRight click = edit information'";
				}
				tmp += " onmouseover='highlight(this,event)'>_more_</span>".replace("_more_","<b>" + keyForUser(key) +  "</b><br>" + json);
								
				$('#iParDef').html(tmp);						
			}		
			//$('#iParDef').text("");
		})
		.catch(error => {
			console.log(error);
		})
	} else {
		$('#iMore').remove();
		$(id).text(" ++");
		if (SHOW_HELP) {
			$(id).attr("title","Show more information");
		} else {
			$(id).attr("title","");
		}
	}	
}

function editMore(ev,key) {
	ev.preventDefault();
	let tmp = $('#iParDef').html();
	if (tmp.indexOf(" ++") != -1) {
		CACHED_DEF_HTML = $('#iParDef').html();
	}
	$("#iPutDef").css("display", "none");
	$('#iDefDiv').css("display", "block");
	$("#iDivMore").css("display", "block");	
	$("#iPutMore").css("display", "block");	
	$('#iDefText').focus();
}
function processKeyDown(elHTML,ev) {
	if (DEBUG) console.log("processKeyDown(ev)")	
	if (ev.key === "Escape") {
		$('#iInput').val("");
	}
	if (ev.key === "ArrowUp") {
		onlineLookup(elHTML,ev);
		$('#iDefText').focus();
	} else if (ev.key === "ArrowDown" && CLASS === "all") {
		drillDown()
	}
	if (ev.location === 2) {
		if (ev.key === "Control") {			
			if (CLASS != "all") {
				setClass("all");
				randomWord();
			} else {
				$('#iInput').val("");
			}
		}
	}
	if (ev.key === "PageDown") {
		scrollViewDown();
	} else if (ev.key === "PageUp") {
		scrollViewUp(ev);
	}
	
}
function clearMore() {
	let key = CUR_WORD.replaceAll(" ","-") + "_" + CUR_DEF;
	if (DEBUG) console.log("clearMore(key), key = " + key)
	fetch('backend/clearMore.php?key=' + key + '&class=' + CLASS, {
		method: 'get',
		mode: 'cors',
		heaaders: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		
	})
	.catch(error => {
		console.log(error)
	})
	toggleMore(key,true);
	$('#iDefDiv').css("display", "none");
	$('#iDivMore').css("display", "none");
}
function hack(ev) {
	if (DEBUG) console.log("hack()");
	ev.preventDefault();
	$('#iDefDiv').css("display","block");
}
function showTooltips() {
	if (DEBUG) console.log("showTooltips()");
	if (!SHOW_HELP) {
		$('#iInput').attr("title","");
		$('#iWordBox').attr("title","");
		$('#iInfo').attr("title","");		
		$('#iLast').attr("title","");
		$('#iParDef').attr("title","");
		$('#iCntTotal').attr("title","");
		$('#iDefText').attr("title","");
		$('#iPut0').attr("title","");
		$('#iPut1').attr("title","");
		$('#iPut2').attr("title","");
		$('#iPutMore').attr("title","");		
	} else {
		$('#iInput').attr("title","Search for word, has regex support.\nRight-click or 'down arrow' for svenska.se lookup" );
		$('#iWordBox').attr("title","Scroll with mouse wheel to navigate individual words\nLeft click word = get definition\nRight click word = lookup@svensk.se");
		$('#iInfo').attr("title","Mouse wheel/ or click left/right to navigate");
		$('#iLast').attr("title","Back to last view");
		$('#iParDef').attr("title","Double click to hide");
		$('#iCntTotal').attr("title","Click to toggle control view");
		$('#iDefText').attr("title","Enter definition text");
		$('#iPut0').attr("title","Add/edit definition with score of '0/2'");
		$('#iPut1').attr("title","Add/edit definition with score of '1/2'");
		$('#iPut2').attr("title","Add/edit definition with score of '2/2'");
		$('#iPutMore').attr("title","Add/edit example text");
	}
}
function toggleTooltips() {
	if (DEBUG) console.log("toggleTooltips()");
	SHOW_HELP = !SHOW_HELP;	
	showTooltips();
	if (SHOW_HELP) {
		$('#iTitle').html($('#iTitle').html() + " - with Tooltips");
	} else {
		$('#iTitle').html($('#iTitle').html().replace(" - with Tooltips",""));
	}
}
function defEntry(ev) {
	if (ev.location === 2) {
		if (ev.key === "Control") {			
			if ($('#iPutDef').css("display") === "block") {
				putDef('',2);
				$('#iInput').val("");
				$('#iInput').focus();
				seekWord(CUR_WORD);
			}
			if ($('#iPutMore').css("display") === "block") { 
				putMore()
			}
		}
	} else if (ev.location === 3) {
		if (ev.key === "0") {
			ev.preventDefault();
			putDef('',0);
			$('#iInput').val("");
			$('#iInput').focus();
			seekWord(CUR_WORD);
		} else if (ev.key === "1") {
			ev.preventDefault();
			putDef('',1);
			$('#iInput').val("");
			$('#iInput').focus();
			seekWord(CUR_WORD);
		}
	}	
	if (ev.key === "Escape") {		
		$('#iDefDiv').css("display","none");
	}
}
function showLast(caller) {
	console.log("*** Caller = " + caller + "***")
	console.log("LAST_CLASS = " + LAST_CLASS)
	console.log("LAST_WORD = " + LAST_WORD)
	console.log("CLASS = " + CLASS)
	console.log("CUR_WORD = " + CUR_WORD)
}
function showCachedDef(el) {
	if (DEBUG) console.log("showCachedDef(el), el = " + el);
	
	el.innerHTML = CACHED_DEF_HTML;
}
function simpleLink(defLine) {	
	if (DEBUG) console.log("simpleLink()");
	// Support mulitple links per line. 
	while (defLine.indexOf("<l>") != -1) {
		pos1 = defLine.indexOf("<l>")
		pos2 = defLine.indexOf("</l>")
		if (pos1 != 1 && pos2 > pos1) {
			let old = defLine.substr(pos1, pos2-pos1+4)
			let word = defLine.substr(pos1 + 3,pos2-pos1-3)
			let link = "<span onmouseover=highlight(this,event)";
			link += " onclick=followLink(this)";
			if (SHOW_HELP) {
				link += " title='Navigate to '";
			}	
			link += "><b>" + word;
			link += "</b></span>";
			defLine = defLine.replace(old,link)
		// Bail out if ill-formed element detected
		} else {
			return defLine;
		}
	}
	return defLine;
}

function changeScore(diff) {
	fetch('backend/changeScore.php?word=' + CUR_WORD + '&class=' + CLASS + '&diff=' + diff, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-type': 'application/json'
		}		
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		if (json["res"] === "success") {		
			let newScore = json["new"];
			let id = "#w" + parseInt(SCROLL_INC);
			$(id).css("color",SCORE_COLOURS[newScore]);			
			updateScore();
		}
	})
}
function randomWord() {
	// Hash is to prevent caching of the url by the browser. Server ignores the hash	
	fetch('backend/randomWord.php?class=verb&hash=' + makeHash(), {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}		
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		INC = json["ind"]-4;
		CUR_WORD = json["word"];
		$('#iInput').val(CUR_WORD);
		getWords(3);
	})
	.catch(error => {
		console.log(error);
	})	
}
function makeHash() {
	let dt = new Date();
	let hash = dt.getDate() + "/" + dt.getMonth() + "/" + dt.getFullYear() + " " + dt.getHours() + ":" + dt.getMinutes() + ":" + dt.getSeconds();
	return hash;
}
</script>
</html>
<!DOCTYPE html>
<head>
	<link rel="stylesheet" href="svenska.css">
	<script src="jquery-3.4.1.min.js"></script>
	<meta char="UTF-8" name="viewport" content="width=device-width, initial-scale=1">
</head>
<body onload="startup()">
<div class="row columns_4">
<!--progress bar-->
	<div id="iWordBox" class="wordBox column" onwheel="scrollWords(event)" onclick="clearDef()" title="Scroll with mouse wheel to navigate individual words&#10;Left click word = get definition&#10;Right click word = lookup@svensk.se ">
		<div id="iControls">
			<div class="dropdown">
				<img title="Class selector. Left click to select all. Right click to lookup all display words" id="iSelect" class="dropdown b2" src="img/Sandhammaren.jpg" onclick="closeDefs()" oncontextmenu="lookupManyWords()" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">				
				<div class="dropdown-content">
					<p class="dropEl" onclick="setClass('substantiv_en')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">En</p>
					<p class="dropEl" onclick="setClass('verb')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Verb</p>
					<p class="dropEl" onclick="setClass('adjektiv')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Adjektiv</p>
					<p class="dropEl" onclick="setClass('substantiv_ett')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Ett</p>
					<p class="dropEl" onclick="setClass('adverb')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Adverb</p>
				</div>
			</div>
			<div class="dropdown">
				<img title="Class selector #2 (rarer classes), left click to select all, right-click to toggle debug mode" id="iSelectRare" class="dropdown b2" src="img/Oresundsbron.jpg" onclick="closeDefs()" oncontextmenu="toggleDebugEv(event)" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">
				<div class="dropdown-content">
					<p class="dropEl" onclick="setClass('plural')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Plural</p>
					<p class="dropEl" onclick="setClass('superlativ')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Superlativ</p>
					<p class="dropEl" onclick="setClass('preposition')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Preposition</p>					
					<p class="dropEl" onclick="setClass('pronomen')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Pronomen</p>
					<p class="dropEl" onclick="setClass('interjektion')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Interjektion</p>										
				</div>
			</div>						
			<div class="dropdown">
				<img title="Class selector #3 (rarer classes), left click to select all, right-click to toggle debug mode" id="iSelectRare" class="dropdown b2" src="img/TurningTorso.jpg" onclick="closeDefs()" oncontextmenu="toggleDebugEv(event)" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">
				<div class="dropdown-content">		
					<p class="dropEl" onclick="setClass('förled')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Förled</p>
					<p class="dropEl" onclick="setClass('slutled')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Slutled</p>
					<p class="dropEl" onclick="setClass('räkneord')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Räkneord</p>
					<p class="dropEl" onclick="setClass('konjunktion')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Konjunktion</p>
					<p class="dropEl" onclick="setClass('subjunktion')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Subjunktion</p>
				</div>
			</div>		
			<p class="debug" id="iDebugTxt"></p>
			<form onsubmit="seekWordWrapper(event)">
				<input title="Search for word, has regex support.&#10Right-click for svenska.se lookup" id="iSeek" oncontextmenu="onlineLookup(this,event)" class="inputSearch">		
				<img title="Left click: add word to store*&#10;Right click: guess class&#10;*(suffix word with '.' char to delete from current word class listing" class="b2" src="img/add.svg" id="iAdd" onclick="addWord()" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)" oncontextmenu="setClassGuessWrapper(event)">
				<img title="Back to last view" class="b2" src="img/leftArrow.png" id="iLast" onclick="seekWord('')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">
			</form>				
		</div>
		<p id="iWords" class="fmtWords">Test<br>Words</p>
	</div>
	<div id="iMiddle" class="column" onwheel="scrollView(event)" onclick="ScrollViewDownWrapper()" title="Mouse wheel/ or click left/right to navigate&#10;Right click definition to edit.&#10;Double left click definition to hide def&#10;Words referenced as SE, JFR, MOTSATS etc can be clicked for instant navigation&#10;Word classes in italics can also be clicked to change class selection directly">
		<span class="counts" id="iCnt">test</span>
		<span class="counts" id="iCntTotal" onclick="showToggle()" title="Click to toggle control view" onmouseover="highlight(this,event)">Total</span>
		<span class="counts" id="iScore">{Score}</span>
		<span class="counts" id="iCntRegex"></span>
		<div id="iDefDiv">
			 <textarea  class="defBox" id="iDefText"></textarea>			 
			 <button id = "iSetScore" class="putDef" onclick="ScoreUp()", oncontextmenu="ScoreDown(event)">Score</button>
			 <button class="putDef" onclick="putDef('')">Put</button>			 			 
		</div>
		<p class="pDef" id="iParDef" ondblclick="clearDef()" oncontextmenu="editDefWrapper(event)"></p>		
		<div id="iNavDiv" onclick="scrollViewDown()" oncontextmenu="scrollViewUp(event)"></div>
	</div>
	<div id="iRight" class="column" onwheel="scrollView(event)" onclick="scrollViewDown()" oncontextmenu="scrollViewUp(event)" title="Navigation: left/scroll down = forward, right click/scroll up = back"></div>	
</div>
</body>
<script>

let INC = 0;
let N_INC= 8;
let SCROLL_INC=0
let N_FOUND=0;

let N_TOT=0;
let N_ADJ=0;
let N_VERB=0;
let N_ADVERB=0;
let N_EN=0;
let N_ETT=0;
let N_PLURAL=0;
let N_PREPOSITION = 0;
let N_INTERJEKTION = 0;
let N_PRONOMEN = 0;
let N_PREFIX = 0;
let N_SUPERLATIV = 0;
let N_SLUTLED = 0;
let N_NUMMER = 0;
let N_SUBJUNKTION = 0;
let N_CUR=0;
let N_DEFS = 0;

let LAST_WORD="";
let CUR_WORD="";
let CLASS = "all";
var LAST_OBJ;
let DEBUG=false;
let LAST_DEF = "";
let LAST_CLASS = "all";
let CONTROLS_VISIBLE=true;

let CUR_SCORE = 5;
var TABS = [];

var COLORS = ["red", "blue", "green"];


document.addEventListener("visibilitychange", (event) => {
	if (TABS.length > 0) {
		if (document.visibilityState == "visible") {
			editDef();
		}
	}
});

function startup() {
	wordCount();
	getWords(-1);
	updateScore();
}

function setN_CUR() {
	if (CLASS === "adjektiv") {
		N_CUR = N_ADJ;
	} else if (CLASS === "verb") {
		N_CUR = N_VERB;
	} else if (CLASS === "adverb") {
		N_CUR = N_ADVERB;
	} else if (CLASS === "substantiv_en") {
		N_CUR = N_EN;
	} else if (CLASS === "substantiv_ett") {
		N_CUR = N_ETT;
	} else if (CLASS === "preposition") {
		N_CUR = N_PREPOSITION;
	} else if (CLASS === "interjektion") {
		N_CUR = N_INTERJEKTION;
	} else if (CLASS === "pronomen") {
		N_CUR = N_PRONOMEN;
	} else if (CLASS === "förled") {
		N_CUR = N_PREFIX;
	} else if (CLASS === "plural") {
		N_CUR = N_PLURAL;
	} else if (CLASS === "superlativ") {
		N_CUR = N_SUPERLATIV;
	} else if (CLASS === "slutled") {
		N_CUR = N_SLUTLED;
	} else if (CLASS === "räkneord") {
		N_CUR = N_NUMMER;
	} else if (CLASS === "konjunktion") {
		N_CUR = N_KONJUNKTION;
	} else if (CLASS === "subjunktion") {
		N_CUR = N_SUBJUNKTION;
	} else if (CLASS === "all") {
		N_CUR = N_TOT;
	}
	if (CLASS === "all") {
		$('#iCnt').text("");
	} else {
		$('#iCnt').text(N_CUR.toLocaleString('sv'));
	}
	$('#iCntTotal').text(' [' + N_TOT.toLocaleString('sv') + ']');
	if (DEBUG) console.log("setN_CUR(); N_CUR = " + N_CUR);
}

function fmtDef(def) {
	for (i = 0; i < 24; i++) {
		let old = " " + i + " ";
		let rep = "<br>" + i + " ";
		def = def.replace(old,rep)
	}
	return def;
}
function putDef(def) {	
	if (def.length === 0) {
		def = $('#iDefText').val();
	}
	if (DEBUG) console.log("START putDef(def); def = '" + def + "'; SCROLL_INC = " + SCROLL_INC);
	let processed = preProc(def);
	def = processed[0];
	meta = processed[1];
	
	fetch('backend/putDef.php?class=' + CLASS + '&word=' + CUR_WORD + '&def=' + def + '&meta=' + meta + "&score=" + CUR_SCORE, {
		method: 'get',
		mode:	'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		$('#iDefText').val("");
		$('#iDefDiv').css("display", "none");
		// Reset highlighting of m	issing definition
		LAST_OBJ.innerHTML = LAST_OBJ.innerText;		
		// Find last non-null tabindex
		if (TABS.length > 0) {
			let tmpInd = parseInt(SCROLL_INC) + parseInt(1);		
			TABS[tmpInd].focus();
			scrollDown()
		}
		if (SCROLL_INC != N_FOUND-1) {
			editNext()				
		} else {
			updateDef();
			getWords();
			updateScore();	
		}
		displaySelection();
		// Race condition here between file write and def display	
		/*
		if (SCROLL_INC === (N_FOUND - 1)) {
			lookupWord(LAST_OBJ,true,true);
		}
		*/
	})
	updateScore();
}
function updateScore() {
	fetch('backend/getScore.php?class=' + CLASS, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		let score = 0;
		if (N_TOT > 0) {
			score = Math.round(json/(N_CUR*2) * 10000)/100;
		}
		if (CLASS === "all") {
			$('#iScore').html("");
		} else {
			$('#iScore').html("{" + score + "%}");
		}
	})
	.catch(error => {
		console.log(error);
	})
}

function changeInc(delta) {
	if (INC + delta > N_CUR) {
		INC = INC;
	} else {
		INC += delta
	}
	if (INC < 0) {
		INC = 0;
	}
	if (DEBUG) console.log("changeInc(" + delta + ") -> INC: " + INC);
}
function nextID(id) {
	let num = id.replace("w","");
	if (++num < N_FOUND) {
		return "w" + num;
	} else {
		return id;
	}
}
function advance() {
	changeInc(N_INC)
	getWords(-1)
}
function retreat(e) {
	e.preventDefault()
	changeInc(-N_INC)
	getWords(-1)
}
function getWords(ind = INC) {
	// Ind is used to highlight and lookup a given word index from the returned list
	// Global INC is used to get the starting index of the returned list
	
	if (DEBUG) console.log("getWords(), ind = " + ind + ", INC = ", + INC);
	SCROLL_INC=-1;
	N_FOUND=0;
	$('#iParDef').text("");
	fetch("backend/getWords.php?class=" + CLASS + "&start=" + INC + "&num=" + N_INC, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json',
		}
	})
	.then(response => {
		return response.json()
	})
	.then(json => {
		let lastJson = json;
		let out = ""
		N_FOUND=json.length;
		if (N_FOUND > 0) {
			let list = json[0];
			let scores = [];
			for (i = 1; i < N_FOUND; i++) {
				list += "," + json[i];
			}			
			fetch('backend/existsDef.php?class=' + CLASS + "&words=" + list, {
				method: 'get',
				mode: 'cors',
				headers: {
					'Content-Type': 'application/json'
				}
			})
			.then(response => {
				return response.json();
			})
			.then(json => {
				res = json["stat"];
				let score = json["score"];
				let del = "";
				for (let i = 0; i < N_FOUND; i++) {
					let tmp = 1 << i;
					let hasDef = (res & tmp);
					out += del + popSpan(i, lastJson[i],hasDef) 
					del = "<br>";
				}
				$('#iWords').html(out);
				// Formwatting to show score indicators
				if (CLASS != "all") {
					for (let i = 0; i < N_FOUND; i++) {
						let tmp = "#w" + i;
						if (score[i] > 1) {
							$(tmp).css("color","darkgreen");
						} else if (score[i] > 0) {
							$(tmp).css("color","steelblue");
						} else {
							$(tmp).css("color","darkred");
						}
					}
				}
				showWords();				
				countDefs();
				if (ind > -1) {
					let el = document.getElementById("w" + ind);
					lookupWord(el,false,true);
				}
				if (DEBUG) console.log("getWords(ind); ind = " + ind + ", N_FOUND = " + N_FOUND);
			})
			.catch(error => {
				console.log(error);
			})
		}
	})
}

function scrollViewDown() {
	if (DEBUG) console.log("scrollViewDown() begin");
	changeInc(N_INC);
	$('iDefDiv').css("display", "none");
	getWords(-1);
	showWords();
}
function scrollViewUp(e) {
	e.preventDefault();
	if (DEBUG) console.log("scrollViewUp() begin");
	changeInc(-N_INC);
	getWords(-1);
	showWords();
}
function scrollView(e) {
	if (DEBUG) console.log("scrollView() begin");
	e.preventDefault();
	showWords();
	if (e.deltaY > 0) {
		scrollViewDown();
	} else {
		scrollViewUp(e);
	}
	if (DEBUG) console.log("scrollView(); INC = " + INC)
}

function scrollWords(e) {
	e.preventDefault();
	if (event.deltaY > 0) {
		scrollDown();
	} else {
		scrollUp();
	}
	// Show local definition if available
	updateDef();
	if (DEBUG) console.log("scrollWords() -> SCROLL_INC = " + SCROLL_INC);
}

function scrollDown() {
	if (SCROLL_INC < N_FOUND-1) {
		SCROLL_INC++;
	}
	if (DEBUG) console.log("scrollDown(); SCROLL_INC = " + SCROLL_INC);
}
function scrollUp() {
	if (SCROLL_INC > 0) {
		SCROLL_INC--;
	} else if (SCROLL_INC == -1) {
		SCROLL_INC = N_FOUND - 1;
	}
	if (DEBUG) console.log("scrollUp(); SCROLL_INC = " + SCROLL_INC);
}
function updateDef() {
	if (DEBUG) console.log("updateDef()");
	let id = "w" + SCROLL_INC;
	let el = document.getElementById(id);
	lookupWord(el,true,true);
}
function popSpan(i, w, hasDef) {
	tmp = "<span id='w<i>' onclick='lookupWord(this,false,false)' oncontextmenu='onlineLookup(this,event)'><w></span>"
	if (DEBUG) console.log("popSpan(i=" + i + ",w=" + w + ",hasDef=" + hasDef + ")");
	tmp = tmp.replace("<i>",i)
	if (hasDef || CLASS === "all") {
		tmp = tmp.replaceAll("<w>",w);
	} else { 
		tmp = tmp.replaceAll("<w>","<i>" + w + "</i>");
	}
	return tmp
}

function lookupWord(el,onlyLocal,inline) {
	if (el) {
		if (LAST_OBJ) {
			LAST_OBJ.style.fontWeight="";
		}
		el.style.fontWeight="bold";
		let word = el.innerText;
		CUR_WORD=word;
		LAST_OBJ = el;
		if (DEBUG) console.log("lookupWord(), CUR_WORD = " + CUR_WORD);
		scroll_inc = el.id.replace("w","");
		if (scroll_inc > -1 && scroll_inc < N_INC) {
			SCROLL_INC = scroll_inc; 
		}
		if (CLASS === "all") {
			fetch('backend/getDefAll.php?word=' + word, {
				method: 'get',
				mode: 'cors',
				headers: {
					'Content-Type': 'application/json'
				}
			})
			.then(response => {
				return response.json();
			})
			.then(json => {
				let keys = Object.keys(json);						
				if (keys.length === 1 && keys[0] != CLASS) {			
					// Go direct to class if no ambiguity in found word(s)
					setClass(keys[0]);
					seekWord(word);
				}
				let def = "";
				let delim ="";			
				let tmp = "<span onmouseover=highlight(this,event) onclick=\"setClass(\'_k_\',\'_w_\')\"><i>_k_:</i><br></span>";			
				for (let i = 0; i < keys.length; i++) {		
					def += delim + tmp.replaceAll("_k_", keys[i]).replace("_w_",word) + makeLinks(json[keys[i]]);
					delim="<br>";
				}
				LAST_DEF = def;
				$('#iParDef').html("<b>" + word + ":</b><br>" + def);
				return;
			})
			.catch(error => {
				console.log(error);
			})
		} else {
			fetch('backend/getDef.php?class=' + CLASS + '&word='+ word, {
				method: 'get',
				mode: 'cors',
				headers: {
					'Content-Type': 'application/json'
				}
			})
			.then(response => {
				return response.json()
			})
			.then(json => {			
				let meta = json["meta"];
				def = json["def"];
				LAST_DEF = json["def"];
				// Prefer local definition over 3rd party dictionary
				if (def != "No definition found" && def != "Could not read json") {
					if (def.includes("till '")) {
						getCompDef(meta,def);
						return;
					}
					def = makeLinks(def);
					if (meta.length > 0) {										
						def = fmtMeta(meta) + def;
						$('#iParDef').html(def);
					} else {
						$('#iParDef').html("<b>" + word + ":</b><br>" + def);
					}					
					if (json["score"]) {
						$('#iParDef').html($('#iParDef').html() + "<br>Score: <b>" + json["score"] + "</br>")
						CUR_SCORE = parseInt(json["score"]);
					}
					$('#iDefDiv').css("display", "none");
					if (!inline) {
						$('#iWords').css("visibility", "hidden");
					}
				} else {
					if (!onlyLocal) {
						let url = "https://svenska.se/tre?sok=" + word + "&pz=1";
						window.open(bulletProofUrl(url), '_blank');
					}
					$('#iParDef').html("");
					$('#iDefDiv').css("display", "block");
					$('#iDefText').focus();
				}
			})
			.catch(error => {
				console.log(error)
			})
		}
		
		if (DEBUG) {
			if (word.length === 0) word = "__empty__";
			console.log("lookupWord(" +  word + ")");
		}
	}
}
// Make links to referenced words
function makeLinks(def) {
	if (DEBUG) console.log("makeLinks()")
	def = linkSingleWord(def);	
	if (def.split("<br>").length == 1) {
		return def;
	}
	
	def = addLinks("MOTSATS", def);
	def = addLinks("JFR", def);
	def = addLinks("SYN.", def);
	def = addLinks("SE", def);	
	return def;
}
function linkSingleWord(def) {	
	if (DEBUG) console.log("linkSingleWord(def), def " + def);
	if (def.substr(0,6) === "till '") return def;
	defArr = def.split("<br>");
	outDef = "";
	del = "";
	tmpSpan = "<span onclick=followLink(this) onmouseover=highlight(this,event) title='Navigate to \"_w_\"'><b>_w_</b></span>";
	for (line of defArr) {		
		if (line.length > 0) {
			// Excluse explicitly predefined links and word class links e.g. "verb:"
			if (line[0].match(/[A-Z]/) != null || line.indexOf(":") != -1) {
				outDef += del + line;
				del = "<br>";
			} else {
				let tmp = line;
				tmp = tmp.substr(2);			

				// Strip away meta and grammer information
				let res = tmp.match(/(\[.*\])/);
				if (res) tmp = tmp.replace(res[0] + " ","");
				res = tmp.match(/(\(.*\))/);
				if (res) tmp = tmp.replace(res[0] + " ","");
				// Simple references to adjektives from substantive
				let ref = "det att vara ";
				if (tmp.indexOf(ref) === 0) tmp = tmp.replace(ref,"");
				ref = "det att ";
				// Simple references to verbs from substantive
				if (tmp.indexOf(ref) === 0) tmp = tmp.replace(ref,"");
				// Simple reference from adjektives to substantive
				ref = "som vållar ";
				if (tmp.indexOf(ref) === 0) tmp = tmp.replace(ref,"");
				ref = "som präglas av ";
				if (tmp.indexOf(ref) === 0) tmp = tmp.replace(ref,"");
				// Simple references to verbs from adjektive
				ref = "som ";
				if (tmp.indexOf(ref) === 0) {
					tmp = tmp.replace(ref,"");
					// remove trailing 'r' from verb conjugation
					if (tmp.slice(tmp.length-1) === 'r') {					
						tmp = tmp.slice(0,tmp.length-1);
					}
				}
				
				let cnt = tmp.match(/ /g);
				if (cnt === null) {
					let offset = 1;
					if (cnt === null) offset = 0
					let word = tmp.substr(offset).replaceAll("­","");
					line = line.replace(word, tmpSpan.replaceAll("_w_",word));				
				} 
				
				outDef += del + line;
				del = "<br>";
			}
		}
	}
	return outDef;
}

function addLinks(refClass,def) {	
	if (DEBUG) console.log("addLinks(), refClass = " + refClass + ", def = " + def);
	if (def.indexOf(refClass) === -1) return def;
	// Easiest to handle line by line and skip the lines without links
	// Expectation is each link class (JFR, SE etc.) has its own new line.
	defArr = def.split("<br>");
	def = "";
	m = refClass + " ";
	delim = "";
	beginSpan = "<span onclick=followLink(this)";
	beginSpan += " onmouseover=highlight(this,event)";
	beginSpan += " title='Navigate to \"_w_\"'";
	beginSpan += ">"
	spanTmp = beginSpan + "<b>_w_</b></span>";
	for (line of defArr) {
		
		if (line.indexOf(m) != -1) {
			elArr = line.split(", ");
			for (el of elArr) {
				el = el.replaceAll("­","");
				if (el.includes(m)) {
					let rep = m + spanTmp.replaceAll("_w_",el.substr(m.length, el.length - m.length))
					line = line.replace(el, rep);
				} else {
					let rep = spanTmp.replaceAll("_w_", el);
					line = line.replace(", " + el, ", " + rep);
				}
			}
		}
		def += delim + line;
		delim = "<br>";
	}
	return def;
}
function followLink(el) {
	let word = el.innerText;
	let rep = word.match(/\s/);
	if (rep != null) {
		word = word.replaceAll(rep[0], " ");
	}
	word = word.replace("!","");
	if (DEBUG) console.log("followLink(" + word + ")");
	$('#iSeek').val(word);	
	let oldINC = INC;
	seekWord(word);
}

function getCompDef(meta, def) {
	if (DEBUG) console.log("getCompDef(def); def = " + def);
	// Compose and output string that combines definition of multiple (usually two)
	// component words
	words = getRefs(def);
	let complete = false;
	let res = "";
	let out = [];
	let done = 0;
	for (let i = 0; i < words.length; i++) {
		let w = words[i];
		w = w.replace("-","");
		// Dispatch n fetches to get definitions
		// add an identifier to each result to enable correct ordering 
		fetch('backend/getDef.php?class=' + guessClass(w) + '&word='+ removeClassDesc(w), {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json();
		})
		.then(json => {
			// def - the original reference definition
			// tmp - original ref + link to the referenced word
			// json - the referenced definition
			let tmp = "<span onclick=\"followLink(this)\"><b>_w_</b></span>:";
			tmp = tmp.replaceAll("_w_",removeClassDesc(w));
			tmp = tmp + "<br>";
			out[done] = makeLinks(tmp + json["def"]);
			done++;
			if (done >= words.length) {
				// Perform any required ordering
				let txt = def + "<br>";
				let del = "";
				for (let i = 0; i < done; i++) {
					if (i != 0) del = "<br>"
					txt = txt + del + out[i];
				}
				$('#iParDef').html(fmtMeta(meta) + txt);
			}
		})
		.catch(error => {
			console.log(error);
		})
	}
}
function getRefs(def) {
	if (!def.includes("till ") || !def.includes("'")) {
		return "";
	}
	def = def.slice(2);
	def = def.replaceAll("till ", "");
	def = def.replaceAll("'","");
	arr = def.split(",");
	if (DEBUG) console.log("getRef(), arr = " + arr);
	return arr;
}

function onlineLookup(el, e) {
	e.preventDefault()
	word = el.innerText;
	if (word.length === 0) word = el.value;
	let url = "https://svenska.se/tre?sok=" + word + "&pz=1";		
	window.open(bulletProofUrl(url), '_blank');
}

function wordCount() {
	fetch('backend/wordCount.php', {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		},
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		N_TOT = json["total"];
		N_ADJ = json["adj"];
		N_VERB = json["verb"];
		N_ADVERB = json["adverb"];
		N_EN = json["substantiv_en"];
		N_ETT = json["substantiv_ett"];		
		N_PLURAL = json["plural"];
		N_SUPERLATIV = json["superlativ"];
		N_PREPOSITION = json["preposition"];
		N_INTERJEKTION = json["interjektion"];
		N_PRONOMEN = json["pronomen"];
		N_PREFIX = json["prefix"];
		N_SLUTLED = json["slutled"];
		N_NUMMER = json["nummer"];
		N_KONJUNKTION = json["konjunktion"];
		N_SUBJUNKTION = json["subjunktion"];
		setN_CUR();		
	})
	.catch(error => {
		console.log(error);
	})
}

function showToggle() {
	if (CONTROLS_VISIBLE) {
		// Hide controls 
		$('#iControls').css("display", "none");
		$('#iShowToggle').text("__");
		CONTROLS_VISIBLE=false;
	} else {
		// Make visible class selector and word seeker controls
		$('#iControls').css("display", "block");
		$('#iShowToggle').text("HIDE");
		$('#iSeek').focus();
		CONTROLS_VISIBLE=true;
	}
	if (DEBUG) console.log("showToggle(); seek.v = " + $('#iSeek').css("visibility") + ", sel.v = " + $('#iSelect').css("visibility"));
}
function seekWordWrapper(e) {
	e.preventDefault();
	let word = $('#iSeek').val();
	seekWord(word);
}
function seekWord(word) {	
	if (word[0] === "." || word[word.length-1] === "." || word.indexOf('+') != -1) {		
		addWord();
		return;
	}
	$('#iCntRegex').html("");
	// Regex support
	reg1 = word.indexOf("*") != -1 || word.indexOf("+") != -1 || word.indexOf('?') != -1 || word.indexOf('^') != -1;
	reg2 = word.indexOf("$") != -1 || word.indexOf("[") != -1 || word.indexOf("]") != -1;
	if (reg1 || reg2) {
		// Will return first match
		
		fetch('backend/regexSeek.php?class=' + CLASS + '&regex=' + word, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json()
		})
		.then(json => {
			if (json.length > 0) {
				// Write the first n matches to the page
				N_FOUND = json.length;			
				let del = "";
				let out = "";
				for (let i = 0; i < N_FOUND; i++) {				
					let tmp = 1 << i;
					let hasDef = (res & tmp);
					out += del + popSpan(i, json[i],hasDef) 
					del = "<br>"
				}
				$('#iCntRegex').html("*" + N_FOUND + "*");
				$('#iWords').html(out);
				showWords();				
				countDefs();
			}
		})
		.catch(error => {
			console.log(error);
		})
	} else {
		// Special exception for two special pronouns
		if (word != "Ers" && word != "Eders") word = word.toLowerCase()
		if (word === '') {
			word = LAST_WORD;
			$('#iSeek').val(word);
		}
		
		LAST_WORD = CUR_WORD;
		CUR_WORD = word;
		if (DEBUG) console.log("seekWord(): LAST_WORD = " + LAST_WORD + ", CUR_WORD = " + CUR_WORD);
		// Special case of prefixes and suffices
		if (word.substr(word.length-1) === "-") {
			word = word.substr(0,word.length-1);
			setClass("förled");
		} else if (word.slice(0,1) === "-") {
			word = word.substr(1);
			setClass("slutled");
		}
		if (word.length > 0) {
			fetch('backend/seekWord.php?class=' + CLASS + "&word=" + word + "&inc=" + INC, {
				method: 'get',
				mode: 'cors',
				headers: {
					'Content-Type': 'application/json'
				}
			})
			.then(response => {
				return response.json();
			})
			.then(json => {
				if (json > -1) {
					// Put selected word in the middle of the word collection				
					INC = json - 3;
					let ind = 3;
					let mid = N_INC/2;
					if (json < mid - 1) {					
						INC = 0;
						ind = json;
					}
					getWords(ind);
				} else {
					// If no match in specific class useful to show matches in other classes.
					fetch('backend/getDefAll.php?word=' + word, {
						method: 'get',
						mode: 'cors',
						headers: {
							'Content-Type': 'application/json'
						}
					})
					.then(response => {
						return response.json();
					})
					.then(json => {
						if (Object.keys(json).length > 0) {
							let keys = Object.keys(json);	
							if (keys.length === 1 && keys[0] != CLASS) {			
								// Go direct to class if no ambiguity in found word(s)
								setClass(keys[0]);
								seekWord(word);
							}
							let def = "";
							let delim ="";
							let tmp = "<span onmouseover=\"highlight(this,event)\" title='Navigate to class \"_k_\"' onclick=\"setClass(\'_k_\',\'_w_\')\"><i>_k_:</i><br></span>";						
							for (let i = 0; i < keys.length; i++) {			
								let compDef = json[keys[i]];															
								def += delim + tmp.replaceAll("_k_", keys[i]).replace("_w_",word) + makeLinks(compDef);
								delim="<br>";
							}
							LAST_DEF = def;
							$('#iParDef').html("<b>" + word + ":</b><br>" + def);
						} else {
							$('#iParDef').html("No matches in any word class.");
						}
					})
					.catch(error => {
						console.log(error);
					})
				}
			})
			.catch(error => {
				console.log(error);
			})
		}
	}
	if (DEBUG) console.log("seekWord(); word = " + word + " -> INC = " + INC);
}

function setClass(c, seek = "") {
	LAST_CLASS = CLASS;
	$('#iDefDiv').css("display", "none");
	$('#iWords').css("visibility", "visible");
	if (c != "all") {
		$('#iDefProgContainer').css("visibility","visible");
	} else {
		$('#iDefProgContainer').css("visibility","hidden");
	}
	CLASS = c;
	INC = 0;
	SCROLL_INC=-1;
	setN_CUR();	
	countDefs();
	getWords(-1);
	updateScore();
	if (seek.length > 0) seekWord(seek);
	if (DEBUG) console.log("setClass(c, seek); CLASS = " + CLASS + ", seek = " + seek + ", INC = " + INC + ", SCROLL_INC = " + SCROLL_INC + ", N_CUR = " + N_CUR);
}
function countDefs() {
	N_DEFS = 0;
	fetch('backend/countDef.php?class=' + CLASS, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		if (json != "Failed to read definition file.") {	
			N_DEFS=json;
			if (DEBUG) console.log("countDefs(); N_DEFS = " + N_DEFS);
			$('#iDefProg').css("width", N_DEFS/N_CUR * 100 + "%");
		} else {
			if (DEBUG) console.log("countDefs(); N_DEFS = " + N_DEFS);
		}
	})
}

function editDef() {	
	if (DEBUG) console.log("editDef()")
	showWords();
	$('#iDefDiv').css("display", "block");
	$('#iDefText').focus();
	$('#iSetScore').html(CUR_SCORE);
}
function editDefWrapper(e) {
	e.preventDefault()
	editDef()
}
function clearDef() {
	if (DEBUG) console.log("clearDef()");
	$('#iParDef').html("");
	$('#iWords').css("visibility", "visible");
	$('#iDefDiv').css("display", "none");
	SCROLL_INC = -1;
	for (let i = 0; i< N_FOUND; i++) {
		$('#w' + i).css("fontWeight", "");
	}
}
function pretty(def) {
	if (DEBUG) console.log("pretty(def); def = " + def);
	let out = "";
	subdefs = def.split("<br>");
	for (let i = 0; i < subdefs.length; i++) {
		del = "<br>";
		if (i === 0) del="";
		s = subdefs[i];		
		pJFR = s.indexOf("JFR");
		pSE = s.indexOf("SE");
		pMOTS = s.indexOf("MOTSATS");
		pSYN = s.indexOf("SYN");
		let tot = pJFR + pSE + pMOTS + pSYN;
		if (tot === -4) {
			out = out + del + s;
		} else {
			// New line before the JFR, SE, MOTS indicators for styling
			if (pJFR === -1) pJFR = 999999;
			if (pSE === -1) pSE = 999999;
			if (pMOTS === -1) pMOTS = 999999;
			if (pSYN === -1) pSYN = 999999;
			let start = pSE;
			if (pJFR < start) start = pJFR;
			if (pMOTS < start) start = pMOTS;
			if (pSYN < start) start = pSYN;
			let def2 =  s.slice(start,s.length);
			s = s.slice(0,start) + "<br>"
			def2 = def2.replaceAll("1","").replaceAll("2","").replaceAll("3","").replaceAll("4","");
			def2 = def2.replaceAll(" ,",",").replaceAll("  ", " ");
			def2 = def2.replaceAll(" 1<br>","<br>");
			out = out + del + s + def2;
		}
	}
	out = out.replaceAll("<br><br>","<br>");
	for (let i = 1; i < 24; i++) {
		out = out.replaceAll(i + " " + i, i);
		out = out.replaceAll("<br>" + i + "<br>","<br>" );
		out = out.replaceAll("<br> " + i + "<br>","<br>" );
		out = out.replaceAll("<br>" + i + " <br>","<br>" );
	}
	// Strip any leading new line
	if (out.slice(0,3) === "<br>") {
		out = out.slice(4,out.length) 
	}
	const regex1 = /[a-z][1-9]/;
	match = out.match(regex1);
	if (match != null) {
		console.log(match);
		strMatch = match[0];
		rep = strMatch[0] + "<br> " + strMatch[1];
		out = out.replace(strMatch, rep);
	}
	if (out[0] === " ") out = out.slice(1,out.length);
	out = out.replace("partikelntill", "partikeln till;");
	if (out[out.length-1] === ",") out = out.slice(0,out.length-1)
	return out;
}
function fullClassName(name) {
	if (name === "en") return "substantiv_en"
	if (name === "ett") return "substantiv_ett"
	return name
}
function guessClass(word) {
	// Prefer explicit definition of class
	if (word.includes('(') && word.includes(')')) {
		// grab class	
		let start = word.indexOf('(')
		let end = word.indexOf(')')	
		if (start > end || start === -1) return 
		let c = word.slice(start+1,end);
		c = fullClassName(c);
		return c;
	} 
	// Otherwise try and semi-intelligently guess word class
	if (word.endsWith('a')) return "verb"
	if (word.endsWith('as')) return "verb"
	if (word.includes(' ')) return "verb"
	if (word.endsWith("ig")) return "adjektiv"
	if (word.endsWith("lös")) return "adjektiv"
	if (word.endsWith("sam")) return "adjektiv"
	if (word.endsWith("full")) return "adjektiv"
	if (word.endsWith("ad")) return "adjektiv"
	if (word.endsWith("en")) return "adjektiv"
	if (word.endsWith("p")) return "substantiv_ett"
	return "substantiv_en"
}
function removeClassDesc(word) {
	let start = word.indexOf('(');
	let end = word.indexOf(')');
	if (start > end || start === -1) return word 	
	return word.slice(0,start-1)
			
}
function addWord() {
	if (DEBUG) console.log("addWord()");
	let word = $('#iSeek').val();	
	if (word.indexOf('+') != -1) {
		tmp = word.split('+');
		word = tmp[0];
		tmpClass = tmp[1];
		if (tmpClass.length > 1) setClass(tmpClass);
		$('#iSeek').val(word);
		
	}
	let del = word[0] === '.' || word[word.length-1] === ".";
	if (word[0] === '.') word = word.slice(1,word.length);
	if (word[word.length-1] === '.') word = word.slice(0,word.length-1);
	if (word.length > 0) {
		let op = "add"	
		if (del) op = "remove"
		fetch('backend/' + op + 'Word.php?class=' + CLASS + "&word=" + word, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			// If this was the last listing of this word delete from "all" listing also
			fetch('backend/getDefAll.php?class=all&word=' + word, {
				method: 'get',
				mode: 'cors',
				headers: {
					'Content-Type': 'application/json'
				}
			})
			.then(response => {
				return response.json();
			})
			.then(json => {
				// It was last reference
				if (json.length < 1) {
					fetch('backend/removeWord.php?class=all&word=' + word, {
						method: 'get',
						mode: 'cors',
						headers: {
							'Content-Type': 'application/json'
						}
					})
					.catch(error => {
						console.log(error);
					})
				}
			})
			.catch(error => {
				console.log(error);
			})
			getWords();
			wordCount();
		})
		.catch(error => {
			console.log(error);	
		})
	}
}

function addMeta(def, regx) {
	// If a known meta phrase is identified at start of definition line then enclose it in square bracket formatting
	if (DEBUG) console.log("addMeta(), regx =´" + regx);
	if (def.length < 3 || def[0].match(/A-Z/)) return def
	// Only apply one meta tag
	if (def[2] === "[" && def.indexOf("]") > 2) return def;	
	// Probably don't actual need regex but leave "ias is" for now
	let rawStr = regx.source;
	browserDependentDelim = "";
	if (navigator.userAgent.indexOf("Chrome") != -1 ) {
		browserDependentDelim = " ";
	}
	
	if (def.indexOf(rawStr) === 2) {
		def = def.replace(rawStr, "[" + rawStr + "]" + browserDependentDelim);
	}
	return def;
}

function grammer(def, rep) {
	// Only one grammer expression is permitted
	if (def.indexOf(rep) != -1) {
		end = def.indexOf(rep) + rep.length;
		let after = def.substring(end,end+1);
		if (after === ")") return def
	}
	return def.replace(" " + rep, " (" + rep + ")");
}
function preProc(def) {
	if (DEBUG) console.log("preProc(def(); def = '" + def + "'")
	// return def and meta components
	// Check if any meta information exists	
	if (def[0] === " ") def = def.slice(1);
	let meta = "";
	
	let defArr = def.split("\n");
	// Concenate if multiple spellings are present
	
	if (defArr.length > 3 && defArr[1] === "eller" || defArr[1] === "även" || defArr[1] === "även åld." || defArr[1] === "även vardagligt" || defArr[1] === "eller vardagligt") {
		defArr[0] = defArr[0] + " </i>" + defArr[1] + " <i>" + defArr[2];
		// Move remaining items up two elements
		for (i = 3; i < defArr.length; i++) {
			defArr[i-2] = defArr[i]
		}
		defArr.pop();
		defArr.pop();		
	}

	let firstLine = defArr[0];
	let opts = firstLine.split(" ");
	let firstWord = opts[0];
	let twoWords = "";
	let threeWords = "";
	let fourWords = "";
	if (opts.length > 1) twoWords = firstWord + " " + opts[1];		
	if (opts.length > 2) threeWords = twoWords + " " + opts[2];
	if (opts.length > 3) fourWords = threeWords + " " + opts[3];
	
	var m;
	if (CLASS === "slutled") {
		m = "-" + CUR_WORD;
	} else if (CLASS === "förled") {
		m = CUR_WORD + "-";
	} else {
		m = CUR_WORD;
	}	
	
	if (firstWord === m || twoWords === m || threeWords === m || fourWords === m) {		
		meta = defArr[0].replaceAll("_"," ");		
		let del = "";
		def = "";
		for (let i = 1; i < defArr.length; i++) {		
			if (i < 3) {							
				if (defArr[i].indexOf('\u25cf') === 0) {
					def += del + defArr[i];
					del = "\n";
				} else {
					meta += "<br>" + defArr[i].replace("ORDKLASS: ","").replace("UTTAL: ","");
				}
			} else {
				def += del + defArr[i];
				del = "\n";
			}
		}
	}
	
	// Split definition
	def = def.replaceAll(" JFR", "\nJFR");
	def = def.replaceAll(" SE", "\nSE");
	def = def.replaceAll(" SYN.", "\nSYN.");
	def = def.replaceAll(" MOTSATS", "\nMOTSATS");	
	arr = def.split("\n");
	let outDef = "";
	// Grammer information - Support for partikel parters
	// Can be between 1 and 3 suggested partner words
	let regex1 = /skilt[a-zäöå]+/;
	let regex1_alt = /partikeln[a-zäöå]+/;
	let regex2 = /skilt[a-zäöå]+, [a-zäöå]+/;
	let regex3 = /skilt[a-zäöå]+, [a-zäöå]+, [a-zäöå]+/;
	// Delimiter is blank on first line
	let del = "";
	for (s of arr) {				
		if (s.length > 1) {
			// Remove any leading space(s)
			while (s[0] === " ") {
				s = s.slice(1,s.length)
			}
			// Defuault to "pretty" leading bullet point
			if (s[0].match(/[a-zäöå]+/) != null) {
				s = `\u25CF ` + s;
			}
			// Leading Meta tags
			// Beware the silent hyphens (\u00AD)			
			// ToDo Move the (many) regx definitions to the function body
			s = addMeta(s, /var­dagligt, kan upp­fattas som ned­sättande/);
			s = addMeta(s, /var­dagligt, något ålderdomligt; kan upp­fattas som ned­sättande/);
			s = addMeta(s, /var­dagligt; något ålderdomligt/);
			s = addMeta(s, /språk­vetenskap/);
			s = addMeta(s, /sär­skilt i affärs­mässiga och vetenskapliga samman­hang/);
			s = addMeta(s, /samman­fattande, formell beteckning/);
			s = addMeta(s, /nu­mera ej officiell benämning/);
			s = addMeta(s, /ofta i värderande ut­tryck/);
			s = addMeta(s,/ofta statistik/);
			s = addMeta(s, /ofta ironiskt/);
			s = addMeta(s,/mest i vetenskapliga samman­hang/);
			s = addMeta(s, /nu­mera sällan i fack­mässiga samman­hang/);
			s = addMeta(s, /nu­mera mindre brukligt i fack­mässiga samman­hang/);
			s = addMeta(s, /i fackspråkliga samman­hang/);
			s = addMeta(s, /nu­mera mindre brukligt/);
			s = addMeta(s,/ofta i religiösa samman­hang/);
			s = addMeta(s,/sär­skilt bibliskt; något ålderdomligt ut­om i vissa ut­tryck/);
			s = addMeta(s,/sär­skilt geometri/);
			s = addMeta(s, /ofta i bild­konst/);
			s = addMeta(s,/mest som marxistisk term/);
			s = addMeta(s,/sär­skilt medicin, psykologi/);
			s = addMeta(s,/sär­skilt medicin/);
			s = addMeta(s,/sär­skilt i handels­språk/);
			s = addMeta(s,/medicin/);
			s = addMeta(s,/något hög­tidligt ut\u00ADom i sammansättn./);
			s = addMeta(s, /hög­tidligt; mest bibliskt/);
			s = addMeta(s,/något hög­tidligt el. formellt/);			
			s = addMeta(s,/något hög­tidligt el. skämtsamt/);
			s = addMeta(s,/ibland något hög­tidligt/);		
			s = addMeta(s,/något hög­tidligt/);		
			s = addMeta(s,/hög­tidligt/);					
			s = addMeta(s,/något var­dagligt/);		
			s = addMeta(s,/var­dagligt; dialektalt/);
			s = addMeta(s,/var­dagligt; ned­sättande/);
			s = addMeta(s,/något ned­sättande/);
			s = addMeta(s,/ned­sättande; ålderdomligt/);
			s = addMeta(s, /var­dagligt; vanligen något ned­sättande/);
			s = addMeta(s,/var­dagligt; ned\u00ADsättande/);
			s = addMeta(s,/var­dagligt, ibland något ned­sättande/);
			s = addMeta(s,/var­dagligt; sär­skilt sport/);
			s = addMeta(s,/starkt var­dagligt/);
			s = addMeta(s,/var­dagligt/);
			s = addMeta(s,/dialektalt/);
			s = addMeta(s,/i fack­språk/);
			s = addMeta(s,/ofta i fackspråkliga samman­hang/);
			s = addMeta(s, /nu\u00ADmera ej i fack\u00ADmässiga samman\u00ADhang/);
			s = addMeta(s,/nu­mera mindre brukligt i fack\u00ADmässiga samman\u00ADhang/);
			s = addMeta(s,/mindre brukligt/);
			s = addMeta(s,/sär­skilt ekonomi/);
			s = addMeta(s,/sär­skilt i matematiskt fack­språk/);
			s = addMeta(s,/sär­skilt matematik/);
			s = addMeta(s,/matematisk/);
			s = addMeta(s,/fysik, kemi m.m./);
			s = addMeta(s,/fysik/);		
			s = addMeta(s,/sär­skilt i juridiska samman\u00ADhang/);
			s = addMeta(s,/sär­skilt juridik/);
			s = addMeta(s,/juridik/);	
			s = addMeta(s,/sär­skilt i lag­språk/);
			s = addMeta(s,/sär­skilt psykologi/);
			s = addMeta(s,/psykologi/);
			s = addMeta(s,/informations­teknik/);
			s = addMeta(s,/sär­skilt i fack­språk/);
			s = addMeta(s,/ofta i fack­språk/);
			s = addMeta(s,/mest i fack­mässiga samman­hang/);
			s = addMeta(s,/ålderdomligt ut\u00ADom i bibliska samman\u00ADhang/);
			s = addMeta(s,/ålderdomligt ut­om i vissa ut­tryck/);
			s = addMeta(s,/delvis något ålderdomligt/);
			s = addMeta(s,/något ålderdomligt/);
			s = addMeta(s,/något ålderdomligt el. ironiskt/);
			s = addMeta(s,/ålderdomligt/);
			s = addMeta(s,/sär­skilt vid beskrivning av ut­ländska förhållanden/);
			s = addMeta(s,/endast vid beskrivning av ut­ländska förhållanden/);
			s = addMeta(s,/något formellt/);
			s = addMeta(s,/formellt i konkret an­vändning/); 
			s = addMeta(s,/formellt/);			
			s = addMeta(s,/delvis historiskt/);
			s = addMeta(s,/mest historiskt/);
			s = addMeta(s,/historiskt i Sverige/);
			s = addMeta(s,/historiskt/);
			s = addMeta(s,/sär\u00ADskilt i barn\u00ADspråk och i imiterat barn\u00ADspråk/);			
			s = addMeta(s, /mest i fack\u00ADspråk/);
			s = addMeta(s, /mest i sport­jargong/);
			s = addMeta(s, /sär­skilt i vetenskapliga samman­hang/);
			s = addMeta(s, /ofta i tekniska el. vetenskapliga samman­hang/);
			s = addMeta(s, /i tekniska och vetenskapliga samman­hang/);
			s = addMeta(s, /i vetenskapliga samman­hang/);
			s = addMeta(s, /mest i tekniska samman­hang/);
			s = addMeta(s,/mest i vetenskapliga samman\u00ADhang/);
			s = addMeta(s,/sär­skilt i vetenskapliga samman\u00ADhang/);
			s = addMeta(s, /i vetenskapliga samman\u00ADhang/);
			s = addMeta(s, /ålderdomligt el. skämtsamt/);
			s = addMeta(s, /ofta klandrande/);
			s = addMeta(s,/mest vid beskrivning av äldre förhållanden/);
			s = addMeta(s,/sär­skilt vid beskrivning av äldre förhållanden/);
			s = addMeta(s,/äv. som musikalisk term/);
			s = addMeta(s,/musik/);
			s = addMeta(s,/sär­skilt meteorologi/);
			s = addMeta(s,/sär­skilt i vänster­politisk debatt/);
			s = addMeta(s,/ofta i vänster­politisk debatt/);
			s = addMeta(s,/ofta ned­sättande/);
			s = addMeta(s,/ofta något ned­sättande/);
			s = addMeta(s,/ned­sättande; något ålderdomligt/);
			s = addMeta(s,/ned­sättande/);
			s = addMeta(s,/ibland skämtsamt/);
			s = addMeta(s,/ibland något skämtsamt/);
			s = addMeta(s,/sär­skilt statistik/);
			s = addMeta(s,/sär­skilt filosofi, biologi/);
			s = addMeta(s,/sär­skilt filosofi/);			
			s = addMeta(s,/filosofi/);			
			s = addMeta(s,/i allmän­språket/);
			s = addMeta(s,/sär­skilt sport/);
			s = addMeta(s,/sär­skilt militär­väsen och sport/);
			s = addMeta(s,/sär­skilt militär­väsen/);
			s = addMeta(s,/sär­skilt sjö­fart/);
			s = addMeta(s,/ibland något ironiskt/);
			s = addMeta(s,/sär­skilt arkeologi/);
			s = addMeta(s, /ej officiell svensk beteckning/);
			s = addMeta(s, /nu­mera ej officiell beteckning/);
			s = addMeta(s, /förskönande om­skrivning/);
			s = addMeta(s, /bibliskt/);
			s = addMeta(s,/ofta fysik och teknik/);
			// Remove any reference numbers other than that at line start
			let trail = s.slice(2,s.length);
			for (let i = 1; i < 24; i++) {
				trail = trail.replaceAll(" " + i + " "," ");
				trail = trail.replaceAll(i,"");				
			}
			s = s.slice(0,2) + trail;		
			s = s.replaceAll("  ", " ");
			s = s.replaceAll("  ", " ");
			let match = s.match(/[\s]+[,]+/i);
			if (match) {
				s = s.replaceAll(match[0],",");				
			}
			
			let m = s.match(regex1);
			let m_alt = s.match(regex1_alt);
			let m2 = s.match(regex2);
			let m3 = s.match(regex3);
			let rep = ""
			if (m3 != null) {
				let strMatch = m3[0];
				let rep = strMatch.slice(0,5) + " " + strMatch.slice(5,strMatch.length) + ")";
				s = s.replace(strMatch, rep);
			} else if (m2 != null) {
				let strMatch = m2[0];
				rep = strMatch.slice(0,5) + " " + strMatch.slice(5,strMatch.length) + ")";
				s = s.replace(strMatch, rep);
			} else if (m != null) {
				let strMatch = m[0];
				let rep = strMatch.slice(0,5) + " " + strMatch.slice(5,strMatch.length) + ")";
				s = s.replace(strMatch, rep);
			} else if (m_alt != null) {
				let strMatch = m_alt[0];
				let rep = strMatch.slice(0,9) + " " + strMatch.slice(9,strMatch.length) + ")";
				s = s.replace(strMatch, rep);
			}
			s = s.replace("ibland med partikel","(ibland med partikel");
			s = s.replace("vanligen med partikel","(vanligen med partikel");
			s = s.replace("ofta med partikel","(ofta med partikel");
			let f1 = "utan) större betydelse­skillnad";
			let f2 = "), utan större betydelse­förändring";
			let f3 = "), utan större betydelse­skillnad";
			let f4 = "utan) större betydelse­förändring";
			s = s.replace(f1, f1.replace(")","") + ")");
			s = s.replace(f2,f2.replace(")","") + ")");
			s = s.replace(f3,f3.replace(")","") + ")");
			s = s.replace(f4,f4.replace(")","") + ")");
			if (s.includes("((")) s = s.replace("((", "(");
			// Trailing spaces (or non-breaking space) can break links, remove
			let lastCh = s.charAt(s.length-1);			
			if (lastCh.charCodeAt(0) === 32 || lastCh.charCodeAt(0) === 160) {								
				s = s.slice(0,s.length-1)
			}
			// ToDo Move the (many) grammer pattern definitions to the function body
			// grammer information
			
			s = grammer(s, "ofta i substantivisk an­vändning")
			s = grammer(s, "nästan en­bart bestämd form sing.")
			s = grammer(s, "vanligen i böjda former");
			s = grammer(s, "nästan alltid bestämd form sing. och med versal");
			s = grammer(s, "ofta bestämd form sing. och med versal");
			s = grammer(s, "vanligen bestämd form sing. och med versal");
			s = grammer(s, "med subst. som för­led");
			s = grammer(s, "vanligen placerat efter huvud­ordet");
			s = grammer(s,"ofta med versal");
			s = grammer(s,"ofta med efter­följande bi­sats");
			s = grammer(s,"sär­skilt i pass. konstruktioner");
			s = grammer(s,"i konstruktion med komparativ");
			s = grammer(s,"ofta substantiverat");
			s = grammer(s, "ofta refl. el. pass.");
			s = grammer(s,"ofta refl.");			
			s = grammer(s,"med konjunktionen",);
			s = grammer(s,"vanligen pres.");
			s = grammer(s,"endast pres. el. pret.");
			s = grammer(s,"i bestämd form");
			s = grammer(s,"vanligen bestämd form sing.");
			s = grammer(s,"ofta bestämd form sing.");
			s = grammer(s,"vanligen bestämd form");
			s = grammer(s,"ofta plur.");
			s = grammer(s,"knappast plur.; i vissa ut\u00ADtryck");
			s = grammer(s,"knappast plur.");
			s = grammer(s,"vanligen plur.");
			s = grammer(s,"sällan plur.");
			s = grammer(s,"vanligen part.");
			// ToDo regex to get word reference	
			s = grammer(s,"ofta i sammansättn.");		
			s = grammer(s,"mest i sammansättn.");
			s = grammer(s,"nu­mera vanligen i sammansätt.");	
			s = grammer(s,"vanligen i sammansättn.");
			s = grammer(s,"vanligen i vissa sammansätt.");			
			s = grammer(s,"i vissa ut­tryck och sammansättn.");			
			s = grammer(s,"i sammansättn.");
			// ToDo regex this one			
			s = grammer(s,"vanligen i vissa ut\u00ADtryck");
			s = grammer(s,"utan böjning, i vissa ut\u00ADtryck");
			s = grammer(s,"i vissa ut\u00ADtryck");
			s = grammer(s,"i några ut\u00ADtryck");
			s = grammer(s, "ofta pass. el. perfekt particip");
			s = grammer(s,"ofta pass.");			
			s = grammer(s,"vanligen pass. el. perfekt particip");
			s = grammer(s,"vanligen pass. och perfekt particip");
			s = grammer(s,"vanligen pass. el. part.");
			s = grammer(s,"vanligen refl. el. pass.");
			s = grammer(s,"ofta bestämd form");
			s = grammer(s,"ofta perfekt particip");
			s = grammer(s,"ofta presens particip");
			s = grammer(s, "nästan en­bart pres. el. pret.");
			s = grammer(s,"vanligen perfekt particip");			
			s = grammer(s,"vanligen obestämd form sing.");
			s = grammer(s,"vanligen obestämd form");
			s = grammer(s,"ibl. två ord");
			s = grammer(s,"äv. två ord");
			s = grammer(s,"vanl. två ord");
			s = grammer(s,"äv. tre ord");
			s = grammer(s,"ofta tre ord");
			s = grammer(s,"vanl. tre ord");
			s = grammer(s,"nästan en\u00ADbart i sammansättn.");
			s = grammer(s,"nästan en­bart predikativt");
			s = grammer(s,"endast predikativt");
			s = grammer(s,"vanligen i konstruktioner");
			s = grammer(s,"vanligen i konstruktion");
			s = grammer(s,"vanligen i opersonliga konstruktioner");			
			s = grammer(s,"i opersonliga konstruktioner");			
			s = grammer(s,"vanligen opersonlig konstruktion");
			s = grammer(s,"vanligen koll.");
			s = grammer(s, "ofta koll.");
			s = grammer(s,"ofta i nekande el. frågande ut­tryck");
			s = grammer(s,"ofta i nekande konstruktion");
			s = grammer(s,"vanligen i nekande el. frågande ut­tryck");
			s = grammer(s,"ofta i nekande ut­tryck");
			s = grammer(s,"vanligen i nekande ut­tryck");
			s = grammer(s,"nästan en­bart plur.");
			s = grammer(s,"i plur.");
			s = grammer(s,"vanligen predikativt");
			s = grammer(s,"äv. två ord");
			s = grammer(s,"ofta två ord");
			s = grammer(s,"i negerade samman­hang");
			s = grammer(s,"i negerade ut­tryck");
			s = grammer(s, "i ett få­tal ut­tryck");
			s = grammer(s, "i negerade el. frågande samman­hang");
			s = grammer(s, "vanligen supinum");
			s = grammer(s, "ofta best. form sing.");
			s = grammer(s, "ej predikativt");
			s = grammer(s, "vanligen pass.");
			s = grammer(s, "vanligen presens particip");
			s = s.replace("vanligen med pronomenetsjälv","(vanligen med pronomenet själv)");
			// ToDo Regex this to include the multi-word verbs			
			s = fmtVerbApart(s,/(äv. lös förbindelse, se )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = s.replace("formerna", "formerna ");
			s = s.replace("formen", "formen ");
			s = fmtVerbApart(s,/(äv. lös förbindelse i formen )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = fmtVerbApart(s,/(äv. lös förbindelse, jfr )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = fmtVerbApart(s,/(ofta lös förbindelse, se )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = fmtVerbApart(s,/(ofta lös förbindelse, jfr )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = fmtVerbApart(s,/(vanligen lös förbindelse, se )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = fmtVerbApart(s,/(vanligen lös förbindelse, jfr )([a-zöäå]+)(\s[a-zöäå_]+)/);
			// Format "fast sammansättn." grammer
			s = fmtVerbTogether(s,/(vanligen fast sammansättn., se )([a-zöäå_]+)/);
			s = fmtVerbTogether(s,/(vanligen fast sammansättn., jfr )([a-zöäå_]+)/);
			s = fmtVerbTogether(s,/(någon gång fast sammansättn., se )([a-zöäå_]+)/);
			s = fmtVerbTogether(s,/(ofta fast sammansättn., se )([a-zöäå_]+)/);
			s = fmtVerbTogether(s,/(ofta fast sammansättn., jfr )([a-zöäå_]+)/);
			s = fmtVerbTogether(s,/(äv. fast sammansättn., se )([a-zöäå_]+)/);			
			s = fmtVerbTogether(s,/(äv. fast sammansättn., jfr )([a-zöäå_]+)/);			
			s = simpleRef(s);		
			s = simpleBold(s);		
			// ToDo Regex this to include the verb
			//s = grammer(s,"vanligen i förbindelse");
			s = handlePrep(s);
			s = s.replaceAll("_","");
			outDef += del + s;			
			// HTML newline separator bon lines subsequent to the first
			del = "<br>";
		}
	}
	var out = []
	out[0] = outDef;
	out[1] = meta;
	// That's it!
	return out;
}
function fmtVerbTogether(s,regx) {
	if (DEBUG) console.log("fmtVerbTogether(s,regx), s = " + s + ", regx = " + regx);	
	m = s.match(regx);
	
	if (m != null) {
		if (m.length === 3) {			
			let link = "<span onmouseover=highlight(this,event) title='Navigate to \"_w_\"' onclick=followLink(this)><b>_w_</b></span>".replaceAll("_w_",m[2]);				
			// Allow user to extend the verb to include another partikel e.g. "sig"
			link = link.replaceAll("__"," ");
			s = s.replace(m[0],"(" + m[1] + link + ")");
		}
	}
	return s
}
function  fmtVerbApart(s,regx) {
	if (DEBUG) console.log("fmtVerbApart(s,regx), s = " + s + ", regx = " + regx);
	m = s.match(regx);
	if (m != null) {
		if (m.length === 4) {
			let repWord = m[2] + " " + m[3].substring(1);
			
			// remove leading space from second word and replace with regular space.
			let link = "<span onmouseover=highlight(this,event) title ='Navigate to \"_w_\"' onclick=followLink(this)><b>_w_</b></span>".replaceAll("_w_", repWord);
			// Allow user to match only a single verb word
			link = link.replaceAll(" __","");
			s = s.replace(m[0],"(" + m[1] + link + ")");			
		}
	}
	return s	
}
function simpleRef(s) {
	regx = "/\(se äv. ([a-zöäå]+)\)/"
	let link = "<span onmouseover=highlight(this,event) title ='Navigate to \"_w_\"' onclick=followLink(this)><b>_w_</b></span>"
	m = s.match(regx);
	if (m) {
		s = s.replace(m[0],"(se äv. " + link.replaceAll("_w_",m[2]) + ")");
	}
	return s;
}
function simpleBold(s) {
	regx = "((vanligen (?:med )?komparativ)([a-zöäå]+))"
	let bold = "<b>_w_</b>";
	m = s.match(regx);
	if (m) {
		s = s.replace(m[0],"(" + m[2] + " " + bold.replaceAll("_w_"," " + m[3]) + ")");
	}	
	return s;
}
function withParticle(s) {
	rep = "ibland with partikel";
	s = s.replace(rep, "(" + rep);
	rep = "ofta with partikel";
	s = s.replace(rep, "(" + rep)
	rep = "vanligen with partikel";
	s = s.replace(rep, "(" + rep);
	repo = "vanligen med någon av partiklarna";
	s = s.replace(rep, "(" + rep);
	return s;
}

function showWords() {
	if ($('#iWords').css("visibility") == "hidden") {
		$('#iWords').css("visibility", "visible");
	}
}
function highlight(el,event) {
	if (event.type === "mouseover") {
		el.style.cursor = "pointer";
		el.style.borderColor = "blue";
		if (el.nodeName === "P") el.style.backgroundColor="gray" 
	} else {
		el.style.cursor = "";
		el.style.borderColor = "";
		if (el.nodeName === "P") el.style.backgroundColor=""
	}
}
function toggleDebugEv(e) {
	e.preventDefault();
	toggleDebug();
}
function toggleDebug() {
	DEBUG = !DEBUG;
	if (DEBUG) {
		console.log("Entering debug mode...");
		$('#iDebugTxt').text("DEBUG");
		$('#iDebug').css("color","gray");
	}  else {
		$('#iDebug').css("color","");
		$('#iDebugTxt').text("");
		console.log("Leaving debug mode...");
	}
}
function setClassGuessWrapper(ev) {
	ev.preventDefault();
	let word = $('#iSeek').val();
	setClassGuess();	
	seekWord(word);
}
function setClassGuess() {
	let word = $('#iSeek').val();
	let c = guessClass(word);
	if (DEBUG) console.log("setClassGuess, Class guessed as " + c)
	setClass(c);
	seekWord(CUR_WORD);
}
function lookupManyWords() {	
	// Clear existing tabs collection
	TABS.length = 0;
	let n = 8;			
	let start = parseInt(INC) + parseInt(SCROLL_INC);	
	if (start === -1) start = 0
	fetch('backend/getWords.php?&class=' + CLASS + "&start=" + start.toString() + "&num=" + n, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json()
	})
	.then(json => {
		if (json.length < n) n = json.length
		for (let i = 0; i < n; i++) {			
			let word = json[i]
			let url = "https://svenska.se/tre?sok=" + word + "&pz=1";
			// Manual unicode percentage escaping as some browsers misbehave here	
			TABS.push(window.open(bulletProofUrl(url), '_blank'));		
		}	
	})
	.catch(error => {
		console.log(error);
	})
}

function fmtMeta(meta) {
	meta = meta.replace(CUR_WORD,"<b>" + CUR_WORD + "</b>");
	metaArr = meta.split("<br>");
	let tmpMeta = "";
	delMeta = "";
	for (let i = 0; i < metaArr.length; i++) {						
		if (i == 0) {
			delMeta = "";
		} else if (i === 1) {
			delMeta = "<br>ORDKLASS: ";
		} else if (i === 2) {
			delMeta = "<br>UTTAL: ";
		} else {
			delMeta = "<br>";
		}
		tmpMeta += delMeta + metaArr[i];
	}
	tmpMeta = "<i>" + tmpMeta + "</i><br>"
	return tmpMeta;
}
function ScrollViewDownWrapper() {

	if (false && $('#iDefDiv').css("display") === "none") {
		scrollViewDown();
	}
}
function handlePrep(s) {
	// Can have 0, 1 or more preposition words
	// Works for a single preposition word
	// Maybe support multiple words later
	regx = /med prep.[a-zöäå]/;
	let m = s.match(regx);
	if (m != null) {
		s = s.replace(m[0], "(" + m[0] + ")");
		s = s.replace("prep.", "prep. ");		
	}
	return s;
}
function bulletProofUrl(url) {
	// Manually do escaping of Swedish unicode characters as browsers can misbehave here
	
	url = url.replaceAll("ä","%C3%A4");			
	url = url.replaceAll("å","%C3%A5");			
	url = url.replaceAll("ö","%C3%B6");	
	url = url.replaceAll("é","%C3%A9");
	return url
}
function closeDefs() {
	if (TABS.length === 0) {
		setClass("all");
	}
	for (i = 0; i < TABS.length; i++) {
		TABS[i].close();
	}
	TABS.length = 0;
}
function ScoreDown(ev) {
	if (DEBUG) console.log("ScoreDown()")
	ev.preventDefault();
	if (CUR_SCORE <= 0) {
		CUR_SCORE = 2;
	} else {
		CUR_SCORE -= 1;
	}
	$('#iSetScore').html(CUR_SCORE);
}
function ScoreUp() {
	if (DEBUG) console.log("ScoreUp()")
	if (CUR_SCORE >=  2) {
		CUR_SCORE = 0;
	} else {
		CUR_SCORE += 1;
	}

	$('#iSetScore').html(CUR_SCORE);
}
function keyNav(ev) {
	ev.preventDefault();
	console.log("nav");
}
function editNext() {
	if (DEBUG) console.log("editNext()")
	if (SCROLL_INC < N_FOUND-1) {
		SCROLL_INC++;
	}
	let cur = "#w" + SCROLL_INC;
	CUR_WORD = $(cur).text();
	editDef();
	// ToDo show any current definition
}
function displaySelection() {
	for (let i = 0; i < N_FOUND; i++) {
		let tmp = "#w" + i;
		$(tmp).css("font-weight", "")
	}
	let cur = "#w" + SCROLL_INC;
	$(cur).css("font-weight", "bold");
}
</script>
</html>
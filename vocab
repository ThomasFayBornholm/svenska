<!DOCTYPE html>
<html lang="sv"></html>
<head>
	<meta char="UTF-8" name="viewport" content="width=device-width, initial-scale=1">
	<title>Ordbok</title>
	<link rel="stylesheet" href="svenska.css">
	<script src="jquery-3.6.0.js"></script>
	<script src="jquery-ui.js"></script>
	<link rel="stylesheet" href="jquery-ui.css">
	<link rel="icon" type="image/x-icon" href="img/Flag_of_Sweden.png">
	<script>
	$( function() {
		$( document ).tooltip();
	} );
	</script>
	<style>
	label {
		display: inline-block;
		width: 5em;
	}
	</style>	
</head>
<body onload="startup()" onkeydown="bodyListener(event)">
<div >
<div class="titleLeft">
<span class="counts" id="iCntTotal">xx xxx</span>
</div>
<div class="titleCentre">
<h1 id="iTitle" oncontextmenu="toggleDebugEv(event)" title="Double click to toggle tooltip display on web-page controls">Ordbok</h1>
</div>
<div class="titleRight">
<span class="counts" id="iTotalScore">xx.xx%</span>
</div>
</div>
<div id="iCountDiv" class="centred" style="visibility: hidden">
	<span class="counts countLeft" id="iCnt">test</span>	
	<span class="counts" "score" id="iScore">{Score}</span>
	<span class="counts" id="iCntRegex"></span>
</div>
<div id="iControls">
	<p class="debug" id="iDebugTxt"></p>
	<form class="centred" onsubmit="newInputWrapper(event)">	
		<img class="b2" src="img/leftArrow.svg" id="iLast" onclick="getLastWord()" oncontextmenu="hack(event)" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">
		<input id="iInput" oncontextmenu="onlineLookup(this,event)" ondblclick="toggleRegexMode()" class="inputSearch" autocomplete="off" onkeydown="processKeyDown(event)">				
		<img class="b2" src="img/Mute.png" id="iToggleSounds" onclick="toggleSounds()" onmouseover="highlight(this,event)"></img>
		<img class="b2" src ="img/Shakespeare.png" onclick="fromEnglish()" onmouseover="highlight(this,event)">
		<div id="dialog" title="Basic dialog">
			<p id="iSummary" class="summary"></p>
		</div>
	</form>		
</div>
<div id="iWordBox" class="wordBox firstColumn" onwheel="scrollWords(event)" onclick="clearDef()">
	<p id="iWords" class="fmtWords">Test<br>Words</p>
	<p id="iAux" class="fmtAuxClass"></p>
</div>
<div id="iInfo" class="secondColumn" onwheel="scrollView(event)" onclick="clickMiddle(event)" oncontextmenu="clickMiddle(event)">

	<div id="iDefDiv">
		 <textarea  class="defBox" id="iDefText" onkeydown="defEntry(event)"></textarea>			 
		 <div id="iPutDef">
		 <button class="putDefThree" id="iPut0" onclick="putDef('', 0)">0</button>			 			 
		 <button class="putDefThree" id="iPut1" onclick="putDef('', 1)">Put (1)</button>			 			 
		 <button class="putDefThree" id="iPut2" onclick="putDef('', 2)">2</button>			 			 
		 </div>
		 <div id="iDivMore">		
		 <button class="putDef" onclick="putMore()" id="iPutMore">Put More Information</button>		 
		 </div>
	</div>			
	<p class="pDef" id="iMeta"</p>					
	<p class="pDef" id="iParDef" ondblclick="clearDef()"></p>					
	<p class="pMore" id="iMoreTxt"</p>					
	<div id="iNavDiv" onclick="scrollViewDown()" oncontextmenu="scrollViewUp(event)"></div>
</div>	
</body>
<script>
$(window).focus(function() {
	focusDef();		
});

function focusDef() {
	if ($('#iDefDiv').css("display") != "none") {
		$('#iDefText').get(0).focus();
	}
}

function focusInput() {
	if ($('#iDefDiv').css("display") === "none") {
		$('#iInput').focus();
	}
}

let INC = 0;
let N_INC= 8;
let SCROLL_INC=0
let N_FOUND=0;

let N_TOT=0;
let N_ADJ=0;
let N_VERB=0;
let N_ADVERB=0;
let N_FRASER=0;
let N_EN=0;
let N_ETT=0;
let N_PLURAL=0;
let N_PREPOSITION = 0;
let N_INTERJEKTION = 0;
let N_PRONOMEN = 0;
let N_PREFIX = 0;
let N_SLUTLED = 0;
let N_NUMMER = 0;
let N_SUBJUNKTION = 0;
let N_INFINITIV = 0;
let N_CUR=0;

let N_LEMMAS = 0;
let N_DEFS = 0; // Number of definitions for current word lemma

let LAST_WORD=""; // Allow user to go back to previous word
let LAST_DEF_ENUM = 1; // The viewed definition is also remembered when recalling the previous word
let LAST_SCROLL_Y = 0;
let CUR_WORD="";
let CUR_DEF = "";
let CUR_DEF_ENUM = 1;
let N_DEF = 0;
let CLASS = "all";
var LAST_OBJ;
let DEBUG=false;
let SOUNDS=false;
let LAST_DEF = "";
let LAST_CLASS = "all";
let CONTROLS_VISIBLE=true;
var TABS = [];
var REGEX_WORDS = [];
var N_REGEX = 0;
var CACHED_DEF_HTML = "";
var SCORE_COLOURS = ["darkred", "steelblue", "darkgreen"];
let REGEX_MODE = false;
var CLASSES = ["en","verb","adj","ett","adv","fra","plu","prep","pro","int","för","slut","sub","kon","räk","inf","art"]
var CLASS_LIST = ["substantiv_en","verb","adjektiv","substantiv_ett","adverb","fraser","plural","preposition","pronomen","interjektion","förled","slutled","subjunktion","konjunktion","räkneord","infinitiv","artikel"]
// Crude toggle on site load to show tool tips
var TAB_DUMMY;
var TAB_LOOKUP
let ALL_DEFS = "";

let TOTAL_SCORE = 0;
let TARGET_DAILY = 0;
let TARGET_MONDAY = 0;
let RATE = 0;
let SHOW_SUMMARY = true;

document.addEventListener("visibilitychange", (event) => {
	if (TABS.length > 0) {
		if (document.visibilityState == "visible") {
			editDef();
		}
	}
});

function startup() {
	if (DEBUG) log("startup()")
	wordCount();		
	updateScore();
	randomWord();
	focusInput();
	setTimeout(setTargets,1000);
	$('#iCntRegex').on("dblclick", resetFilter);
}

function clearSummary() {
    debug("clearSummary");
    $('#iSummary').text("");
}
function getInput() {
	if (DEBUG) log("getInput()");
	let word = $('#iInput').val();
	if (word.length === 0) word = "0";
	if (word === "~") word = CUR_WORD;
	$('#iInput').val(word);
	return word;
}

function setCUR_WORD(word) {
	if (word != CUR_WORD) {
		LAST_WORD = CUR_WORD;
		CUR_WORD = word;			
	}	
	$('#iInput').val("");
}

function setN_DEF(n_def) {
	N_DEF = n_def;
}

function setN_CUR() {
	if (DEBUG) log("setN_CUR()")
	if (CLASS === "adjektiv") {
		N_CUR = N_ADJ;
	} else if (CLASS === "verb") {
		N_CUR = N_VERB;
	} else if (CLASS === "adverb") {
		N_CUR = N_ADVERB;
	} else if (CLASS === "substantiv_en") {
		N_CUR = N_EN;
	} else if (CLASS === "substantiv_ett") {
		N_CUR = N_ETT;
	} else if (CLASS === "fraser") {
		N_CUR = N_FRASER;
	} else if (CLASS === "preposition") {
		N_CUR = N_PREPOSITION;
	} else if (CLASS === "interjektion") {
		N_CUR = N_INTERJEKTION;
	} else if (CLASS === "pronomen") {
		N_CUR = N_PRONOMEN;
	} else if (CLASS === "förled") {
		N_CUR = N_PREFIX;
	} else if (CLASS === "plural") {
		N_CUR = N_PLURAL;
	} else if (CLASS === "slutled") {
		N_CUR = N_SLUTLED;
	} else if (CLASS === "räkneord") {
		N_CUR = N_NUMMER;
	} else if (CLASS === "konjunktion") {
		N_CUR = N_KONJUNKTION;
	} else if (CLASS === "subjunktion") {
		N_CUR = N_SUBJUNKTION;
	} else if (CLASS === "infinitiv") {
		N_CUR = N_INFINITIV;
	} else if (CLASS === "artikel") {
		N_CUR = N_ARTIKEL;
	} else if (CLASS === "all") {
		N_CUR = N_ALL;
	} else {
		N_CUR = N_ALL;
	}
	
	if (CLASS === "all") {
		$('#iCnt').text("");		
	} else {
		$('#iCnt').text(N_CUR.toLocaleString('sv'));		
	}	
	
	if (DEBUG) log("setN_CUR(); N_CUR = " + N_CUR);
}

function fmtDef(def) {
	if (DEBUG) log("fmtDef()")
	for (i = 0; i < 24; i++) {
		let old = " " + i + " ";
		let rep = "<br>" + i + " ";
		def = def.replace(old,rep)
	}
	return def;
}

function putMoreMany(moreArr, cur) {
	if (DEBUG) log("putMoreMany()");
	let moreLen = moreArr.length;
	// Don't forget no spaces in storage keys, use "-" instead
	fetch('backend/putMore.php?key=' + CUR_WORD.replaceAll(" ","-") + "_" + cur + '&more=' + moreArr[cur] + '&class=' + CLASS, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		cur++;
		if (cur < moreLen) putMoreMany(moreArr, cur);
	})
	.catch(error => {
		log(error);
	})
}

function addDef(key, meta, def, more) {
	if (DEBUG) log("addDef(meta,def,more)");
	$('#iMeta').html("adding... '<b>" + key + "</b>'");
	$('#iParDef').html("");
	$('#iMore').html("");
	let moreArr = more.split("||");	
	moreLen = moreArr.length;
	if (moreLen > 4) {
		more = "";
		putMoreMany(moreArr, 0);
	}
	//fetch('backend/addDef.php?word=' + CUR_WORD + '&meta=' + meta + '&def=' + def.replaceAll("%20"," ") + '&more=' + more + '&class=' + CLASS, {
	let url = 'backend/addDef.php?word=' + key + '&meta=' + meta + '&def=' + def + '&more=' + more + '&class=' + CLASS; 
	fetch(url, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		if (CLASS === "fraser") $('#iInput').val(key);
		updateScore();
		CUR_DEF_ENUM = 1;
		setTimeout(updateDef(),2000);
	})
	.catch(error => {
		log(error);
	})
}


function putDef(def, score) {
	if (def.length === 0) {
		def = $('#iDefText').val();
	}
	if (DEBUG) log("START putDef(def, score); def = '" + def + ",score ´" + score + "; SCROLL_INC = " + SCROLL_INC);
	if (CLASS === "fraser") {
		putFrasDef(score);
		return;
	}
	
	if (def.slice(0,1) === "\n") def = def.slice(1);
	
	
	let processed = preProc(def);
	def = processed[0];	
	meta = processed[1];
	more = processed[2];
	fetch('backend/putDef.php?class=' + CLASS + '&word=' + CUR_WORD + '&def=' + def + '&meta=' + meta + "&score=" + score + "&more=" + more, {
		method: 'get',
		mode:	'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		$('#iDefText').val("");
		$('#iDefDiv').css("display", "none");
		// Reset highlighting of missing definition
		LAST_OBJ.innerHTML = LAST_OBJ.innerText;		
		// Find last non-null tabindex
		if (TABS.length > 0) {
			let tmpInd = parseInt(SCROLL_INC) + parseInt(1);		
			TABS[tmpInd].focus();
			scrollDown()
		}		
		updateDef();
		getWords();
		updateScore();	
		wordCount();
		displaySelection();
		// Race condition here between file write and def display	
		/*
		if (SCROLL_INC === (N_FOUND - 1)) {
			lookupWord(LAST_OBJ,true,true);
		}
		*/
		focusInput()
	})
	getDiff();
}

function putFrasDef(score) {
	if (DEBUG) log("putFrasDef()")
	let def = $('#iDefText').val();
	if (def.indexOf("%%") == -1) {
		return;
	}
	let tmp = def.split("%% ");
	CUR_WORD = tmp[0];
	let meta = tmp[0] + "<br>fras";	
	
	let processed = preProc(tmp[1]);	
	def = processed[0];	
	def = def.replace("2", "<br>2");
	def = def.replace("3","<br>3");
	
	fetch('backend/putDef.php?class=fraser&word=' + CUR_WORD + '&def=' + def + '&meta=' + meta + "&score=" + score, {
		method: 'get',
		mode:	'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	fetch('backend/addWord.php?word=' + CUR_WORD + '&class=fraser', {
		method: 'get',
		mode:	'cors',
		headers: {
			'Content-Type': 'application/json'
		}	
	})
	$('#iDefText').val("");
	setTimeout(seekWordSingleClass,500);		
	wordCount();
	updateScore();
}


function updateScore() {
	if (DEBUG) log("updateScore()")
	// Hash to prevent cached value being used by browser
	fetch('backend/getScore.php?id=0&class=' + CLASS + '&hash=' + makeHash(), {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		let score = 0;
		if (N_TOT > 0) {
			score = Math.round(json["total"]/(N_CUR*2) * 1000)/10;
		}
		// Score for all classes is already available for "all" class
		if (CLASS != "all") {			
			$('#iScore').html("{" + score + "%");
			$('#iScore').html($('#iScore').html() + " <span class='redWord' onclick=seekWord('redwords') oncontextmenu='nextWord(this,event)'>" + json["redCount"] + "</span>")
			$('#iScore').html($('#iScore').html() + ";<span class='blueWord' onclick=seekWord('bluewords') oncontextmenu='nextWord(this,event)'>" + json["blueCount"] + "</span>")
			$('#iScore').html($('#iScore').html() + "}");
		} else {
			$('#iScore').html("");
		}
		// Only display counts once they are initialised.
		$('#iCountDiv').css("visibility","");		
		fetch('backend/getScore.php?id=0&class=all&hash=' + makeHash(), {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json();
		})
		.then(json => {			
			TOTAL_SCORE = round(json["percent"]*N_ALL/100,0);								
			getDiff();			
		})
		.catch(error => {
			log(error);
		})
	})
	.catch(error => {
		log(error);
	})
}

function changeInc(delta) {
	if (DEBUG) log("changeInc()")
	if (INC + delta > N_CUR) {
		INC = INC;
	} else {
		if (N_REGEX > 0) {
			if (INC + delta < N_REGEX) {			
				INC += delta
			}
		} else {
			INC += delta
		}
	}

	if (INC < 0) {
		INC = 0;
	}
	if (DEBUG) log("changeInc(" + delta + ") -> INC: " + INC);
}
function nextID(id) {
	if (DEBUG) log("nextId()")
	let num = id.replace("w","");
	if (++num < N_FOUND) {
		return "w" + num;
	} else {
		return id;
	}
}

function advance() {	
	if (DEBUG) log("advance()");
	changeInc(N_INC)
	getWords(-1)
}

function retreat(e) {
	if (DEBUG) log("retreat()");
	e.preventDefault()
	changeInc(-N_INC)
	getWords(-1)
}

function getWords(ind = INC) {
	// Ind is used to highlight and lookup a given word index from the returned list
	// Global INC is used to get the starting index of the returned list		
	if (DEBUG) log("getWords(), ind = " + ind + ", INC = ", + INC);	
	SCROLL_INC= -1;
	N_FOUND=0;
	$('#iParDef').text("");
	if (N_REGEX > 0) {
		list = REGEX_WORDS[ind];	
		N_FOUND = N_REGEX - ind;		
		if (N_FOUND > N_INC) N_FOUND = N_INC;	
		for (i = ind + 1; i < N_FOUND + ind; i++) {
			list += "|" + REGEX_WORDS[i];
		}
		if (N_REGEX === 1) {
			displayWords(list,0)
		} else {
			displayWords(list,-1)
		}
	} else {
		fetch("backend/getWords.php?class=" + CLASS + "&start=" + INC + "&num=" + N_INC, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json',
			}
		})
		.then(response => {
			return response.json()
		})
		.then(json => {			
			let lastJson = json;
			N_FOUND=json.length;
			if (N_FOUND > 0) {
				let list = json[0];
				let scores = [];
				for (i = 1; i < N_FOUND; i++) {
					list += "|" + json[i];
				}			
				displayWords(list,ind)
			}
		})
		.catch(error => {
			log(error)
		})
	}
	if (DEBUG) log("END getWords(ind); ind = " + ind + ", N_FOUND = " + N_FOUND);
}

// Enables to updating of the selected word without refreshing the whole screen
function moveSelected() {
    debug("moveSelected()");
    // Clear all highlights
    if (LAST_OBJ) LAST_OBJ.style.fontWeight="";
    // Highlight new selection
    let id = "#w" + SCROLL_INC;
    $(id).css("font-weight", "bold");
    LAST_OBJ = $(id)[0];
    // Retrieve definition
    lookupWord(LAST_OBJ,true,true); 
}
// Create listing of words for display on left side of screen
function displayWords(list,ind) {
	if (DEBUG) log("displayWords(), list = " + list + ", ind = " + ind)
	let out = ""
	list = list.replaceAll("  "," ");	
	fetch('backend/existsDef.php?class=' + CLASS + "&words=" + list + "&caller=displayWords", {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		list = list.replaceAll("-2","<sup>2</sup>");
		res = json["stat"];
		let score = json["score"];
		let del = "";
		let words = list.split("|");	
		N_FOUND = words.length;		
		for (let i = 0; i < N_FOUND; i++) {
			let tmp = 1 << i;
			let hasMeta = (res & tmp);
			out += del + popSpan(i, words[i],hasMeta) 
			del = "<br>";
		}
		out = out.replaceAll("-2</span>","<sup>2</sup></span>");
		$('#iWords').html(out);
		// Formatting to show score indicators
		if (CLASS != "all") {
			for (let i = 0; i < N_FOUND; i++) {
				let tmp = "#w" + i;
				if (score[i] > 1) {
			 		$(tmp).css("color","darkgreen");
				} else if (score[i] > 0) {
					$(tmp).css("color","steelblue");
				} else {
					$(tmp).css("color","darkred");
				}
			}
		}
		
		showWords();				
		
		if (ind > -1) {
			let el = document.getElementById("w" + ind);
			if (el)  {
				//setCUR_WORD(el.innerText);
				lookupWord(el,false,true);
			}
		}				
	})
	.catch(error => {
		log(error);
	})
}

function scrollViewDown() {
	if (DEBUG) log("scrollViewDown() begin");
	changeInc(N_INC);
	$('iDefDiv').css("display", "none");
	
	if (N_REGEX > 1) {
		getWords();
	} else {
		getWords(-1);
	}
	showWords();
}
function scrollViewUp(e) {
	e.preventDefault();
	if (DEBUG) log("scrollViewUp() begin");
	changeInc(-N_INC);
	if (N_REGEX > 1) {
		getWords();
	} else {
		getWords(-1);
	}
	showWords();
}
function scrollView(e) {
	if (DEBUG) log("scrollView() begin");
	e.preventDefault();
	showWords();
	if (e.deltaY > 0) {
		scrollViewDown();
	} else {
		scrollViewUp(e);
	}
	if (DEBUG) log("scrollView(); INC = " + INC)
}

function scrollWords(e) {
	e.preventDefault();
	if (event.deltaY > 0) {
		scrollDown();
	} else {
		scrollUp();
	}
	// Show local definition if available
	if (CLASS === "all") {	
		showWordMatches()
	} else {
		updateDef();
	}
	if (DEBUG) log("scrollWords() -> SCROLL_INC = " + SCROLL_INC);
}

function scrollDown() {
	CUR_DEF_ENUM = 1;
	if (SCROLL_INC < N_FOUND-1) {
		SCROLL_INC++;
	}
	if (DEBUG) log("scrollDown(); SCROLL_INC = " + SCROLL_INC);
}
function scrollUp() {
	CUR_DEF_ENUM = 1;
	if (SCROLL_INC > 0) {
		SCROLL_INC--;
	} else if (SCROLL_INC == -1) {
		SCROLL_INC = N_FOUND - 1;
	}
	if (DEBUG) log("scrollUp(); SCROLL_INC = " + SCROLL_INC);
}

function updateDef() {
	if (DEBUG) log("updateDef()");
	if (SCROLL_INC != -1) {		
		let id = "w" + SCROLL_INC;
		let el = document.getElementById(id);
		lookupWord(el,true,true);
	}
}

function popSpan(i, w, hasMeta) {
	tmp = "<span id='w<i>' onclick='lookupWord(this,false,false)' oncontextmenu='onlineLookup(this,event)'><w></span>"
	if (DEBUG) log("popSpan(i=" + i + ",w=" + w + ",hasMeta=" + hasMeta + ")");
	tmp = tmp.replace("<i>",i)
	if (hasMeta || CLASS === "all") {
		tmp = tmp.replaceAll("<w>",w);
	} else { 
		tmp = tmp.replaceAll("<w>","<i>" + w + "</i>");
	}
	return tmp
}

// Only call when word class is "all"
function showWordMatches(follow) {
	if (DEBUG) log("showWordMatches()");
	if (CLASS != "all") {
		return;
	}
	let id = "w" + SCROLL_INC;
	let el = document.getElementById(id);
	let word = el.innerText;	
	
	if (LAST_OBJ) {
		LAST_OBJ.style.fontWeight="";
	}
	
	el.style.fontWeight="bold";
	fetch('backend/getDefAll.php?word=' + word, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {		
		let keys = Object.keys(json);	
		if (keys.length === 1 && keys[0] != CLASS && follow) {			
			// Go direct to class if no ambiguity in found word(s)
			setClass(keys[0]);
			seekWordSingleClass(word);
		}
		let def = "";
		let delim ="";			
		let tmp = "<span onmouseover=highlight(this,event) onclick=\"setClass(\'_k_\',\'_w_\')\"><i>_k_:</i></span><br>";			
		for (let i = 0; i < keys.length; i++) {		
			def += delim + tmp.replaceAll("_k_", keys[i]).replace("_w_",word) + makeLinks(json[keys[i]]);
			delim="<br>";
		}
		LAST_DEF = def;	
		LAST_WORD = word;
		displayDef("",def, word);						
		return;
	})
	.catch(error => {
		log(error);
	})
	LAST_OBJ = el;
}

function lookupWord(el,onlyLocal,inline) {	
	if (DEBUG) log("lookupWord(el,onlyLocal,inline), elid = " + el.id + ", onlyLocal = " + onlyLocal + ", inline = " + inline);
	$('#iPutDef').css("display","block");
	$('#iPutMore').css("display","none");
	// Cleanup
	$('#iMoreTxt').html("");
	$('#iMeta').html("");

	if (el) {
		if (CLASS === "all") {
			SCROLL_INC = parseInt(el.id.replace("w",""));			
			let follow = false;

			if (el.innerText.indexOf(">") != -1) {
				follow = true;
			}
			showWordMatches(follow);			
			return;
		}
		if (LAST_OBJ) {
			LAST_OBJ.style.fontWeight="";
		}
		el.style.fontWeight="bold";
		let word = el.innerText;
		if (el.innerHTML.indexOf("<sup>") != -1) {
			word = word.replace("2","-2");
		}
		CUR_WORD=word;
		LAST_OBJ = el;
		
		if (DEBUG) log("lookupWord(), CUR_WORD = " + CUR_WORD);
		scroll_inc = el.id.replace("w","");
		if (scroll_inc > -1 && scroll_inc < N_INC) {
			SCROLL_INC = scroll_inc; 
		}
		if (CLASS === "all") {
			wordFromAll(word);
		} else {
			fetch('backend/getDef.php?class=' + CLASS + '&word='+ word, {
				method: 'get',
				mode: 'cors',
				headers: {
					'Content-Type': 'application/json'
				}
			})
			.then(response => {
				return response.json()
			})
			.then(json => {			
				let meta = json["meta"];
				CUR_DEF = json["def"];
				N_DEFS = nDefs();				
				def = getDefInd(CUR_DEF_ENUM);
				LAST_DEF = CUR_DEF; // Is this cached for some reason, check
				// Prefer local definition over 3rd party dictionary
				if (def != "No definition found" && def != "Could not read json") {
					if (def.includes("till '")) {
						getCompDef(meta,def);
						return;
					}
					pronounce(word);
					displayMeta(meta);
					displayDef(def,word);											
					$('#iDefDiv').css("display", "none"); // ?!
					if (!inline) {
						$('#iWords').css("visibility", "hidden");
					}
					
					getMore(CUR_DEF_ENUM);
				} else {					
					$('#iParDef').html("");
					$('#iDefDiv').css("display", "block");
				}
			})
			.catch(error => {
				log(error)
			})
		}
		
		if (DEBUG) {
			if (word.length === 0) word = "__empty__";
			log("lookupWord(" +  word + ")");
		}
	}
}
function displayMeta(meta, word) {
	if (meta.length > 0) $('#iMeta').html(fmtMeta(meta));
	if (CLASS === "fraser") $('#iMeta').html(fmtMeta(CUR_WORD));
}

function displayDef(def,word) {	
	if (DEBUG) log("displayDef(def,word)");	
	def = makeLinks(def);
	let defRaw = def.split("<br>");	
	let defLines = [];
	let iWrite = 0;
	for (i = 0; i < defRaw.length; i++) {
		// Formatted
		if (defRaw[i].match(/^[1-9\u25CF]+[0-9]?.*/)) {			
			defLines[iWrite] = defRaw[i];
			iWrite++;			
		} else {			
			for (k = 1; k < 24; k++) {
				defRaw[i] = defRaw[i].replaceAll(k,"")				
			}
			defRaw[i] = defRaw[i].replaceAll(" </b>","</b>")
			if (defLines.length === 0) {
				defLines[0] = defRaw[i];
				iWrite++;
			} else {				
				defLines[iWrite-1] += "<br>" + defRaw[i];
			}
		}
	}	
	let outDef = "";
	let delim = "";	
	setN_DEF(defLines.length);
	for (j = 0; j < defLines.length; j++) {
		let key = word.replaceAll(" ","-") + "_" + j;		
		if (defLines[j].indexOf("<i>") === -1) {
			outDef += delim + defLines[j]						
		} else {
			outDef += delim + defLines[j];
		}
		delim = "<br>";
	}
	outDef = outDef.replaceAll(" </b>","</b>")
	// Dynamise links
	outDef = outDef.replaceAll("<l>","<span onclick=followLink(this.innerText) onmouseover=highlight(this,event)><b>");
	outDef = outDef.replaceAll("</l>","</b></span>");
	let tmpSpan = "<span id='iMeta' oncontextmenu=editDefWrapper(event) onmouseover=editCursor(event,this)"

		
	if (CLASS != "all" && CLASS != "fraser") outDef = outDef.replace(CUR_DEF_ENUM + " ", CUR_DEF_ENUM + "/" + N_DEFS + " ");	
	$('#iParDef').html(outDef);
}

// Make links to referenced words
function makeLinks(def) {
	if (DEBUG) log("makeLinks()")
	def = linkSingleWord(def);	
	if (def.split("<br>").length == 1) {
		return def;
	}
	
	def = addLinks("MOTSATS", def);
	def = addLinks("JFR", def);
	def = addLinks("SYN.", def);
	def = addLinks("SE", def);		
	return def;
}

function linkSingleWord(def) {	
	if (DEBUG) log("linkSingleWord(def), def = " + def);
	if (def.substr(0,6) === "till '") return def;
	defArr = def.split("<br>");
	outDef = "";
	del = "";
	tmpSpan = "<l>_w_</l>";	
	for (line of defArr) {		
		if (line.length > 0) {
			// Exclude explicitly predefined links and word class links e.g. "verb:"
			if (line[0].match(/[A-Z]/) != null || line.indexOf(":") != -1) {
				outDef += del + line;
				del = "<br>";
			} else {
				let tmp = line;
				tmp = tmp.substr(2);			

				// Strip away meta and grammer information
				let res = tmp.match(/(\[.*\])/);
				if (res) tmp = tmp.replace(res[0] + " ","");
				res = tmp.match(/(\(.*\))/);
				if (res) tmp = tmp.replace(res[0] + " ","");
				// Simple references to adjektives from substantive
				let ref = "det att vara ";
				if (tmp.indexOf(ref) === 0) tmp = tmp.replace(ref,"");
				ref = "det att ";
				// Simple references to verbs from substantive
				if (tmp.indexOf(ref) === 0) tmp = tmp.replace(ref,"");
				// Simple reference from adjektives to substantive
				ref = "som vållar ";
				if (tmp.indexOf(ref) === 0) tmp = tmp.replace(ref,"");
				ref = "som präglas av ";
				if (tmp.indexOf(ref) === 0) tmp = tmp.replace(ref,"");
				// Simple references to verbs from adjektive
				ref = "som ";
				if (tmp.indexOf(ref) === 0) {
					tmp = tmp.replace(ref,"");
					// remove trailing 'r' from verb conjugation
					if (tmp.slice(tmp.length-1) === 'r') {					
						tmp = tmp.slice(0,tmp.length-1);
					}
				}
				// What is this doing and why?
				let cnt = tmp.match(/ /g);				
				if (cnt === null) {					
					let offset = 0
					let word = tmp.substr(offset).replaceAll("­","");
					line = line.replace(word, tmpSpan.replaceAll("_w_",word));				
				} 
				
				outDef += del + line;
				del = "<br>";
			}
		}
	}
	return outDef;
}

function addLinks(refClass,def) {	
	if (DEBUG) log("addLinks(), refClass = " + refClass + ", def = " + def);
	if (def.indexOf(refClass) === -1) return def;
	// Easiest to handle line by line and skip the lines without links
	// Expectation is each link class (JFR, SE etc.) has its own new line.
	defArr = def.split("<br>");
	def = "";
	m = refClass + " ";
	delim = "";
	beginSpan = "<span onclick=followLink(this.innerText)";
	beginSpan += " onmouseover=highlight(this,event)";
	beginSpan += ">"
	spanTmp = beginSpan + "<b>_w_</b></span>";
	for (line of defArr) {		
		if (line.indexOf(m) != -1) {
			elArr = line.split(", ");
			for (el of elArr) {
				el = el.replaceAll("­","");
				if (el.includes(m)) {
					let rep = m + spanTmp.replaceAll("_w_",el.substr(m.length, el.length - m.length))
					line = line.replace(el, rep);
				} else {
					let rep = spanTmp.replaceAll("_w_", el);
					line = line.replace(", " + el, ", " + rep);
				}
			}
		}
		def += delim + line;
		delim = "<br>";
	}
	return def;
}

function followLink(word) {
    debug("followLink(" + word +  ")");
	LAST_SCROLL_Y = window.pageYOffset;	
	LAST_CLASS = CLASS;	
	LAST_DEF_ENUM = CUR_DEF_ENUM;	
	N_REGEX = 0;
	REGEX_WORDS = [];
    // Remove any soft hyphens in word
    word = word.replaceAll("\u00ad","");
	let rep = word.match(/\s/);
	if (rep != null) {
		word = word.replaceAll(rep[0], " ");
	}
    for (i = 0; i < 24; i++) {
		word = word.replace(i,"");
	}
	setCUR_WORD(word);
	wordFromAll(word);		
	let oldINC = INC;
}

function wordFromAll(word) {
	debug("wordFromAll(" + word + ")");	
	fetch('backend/getDefAll.php?word=' + word, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		if (Object.keys(json).length > 0) {
			let keys = Object.keys(json);	
            // Can only resolve link if a unique match is found
			if (keys.length === 1) {			
                if (keys[0] != CLASS) setClass(keys[0]);
                seekWordSingleClass(word);
			}
		} else {
			frasMatchFuzzy(word);
        }
	})
	.catch(error => {
		log(error);
	})
}

function getCompDef(meta, def) {
	if (DEBUG) log("getCompDef(def); def = " + def);
	// Compose and output string that combines definition of multiple (usually two)
	// component words
	words = getRefs(def);
	let complete = false;
	let res = "";
	let out = [];
	let done = 0;
	for (let i = 0; i < words.length; i++) {
		let w = words[i];
		w = w.replace("-","");
		// Dispatch n fetches to get definitions
		// add an identifier to each result to enable correct ordering 
		fetch('backend/getDef.php?class=' + guessClass(w) + '&word='+ removeClassDesc(w), {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json();
		})
		.then(json => {
			// def - the original reference definition
			// tmp - original ref + link to the referenced word
			// json - the referenced definition
			let tmp = "<span onclick=\"followLink(this.innerText)\"><b>_w_</b></span>:";
			tmp = tmp.replaceAll("_w_",removeClassDesc(w));
			tmp = tmp + "<br>";
			out[done] = makeLinks(tmp + json["def"]);
			done++;
			if (done >= words.length) {
				// Perform any required ordering
				let txt = def + "<br>";
				let del = "";
				for (let i = 0; i < done; i++) {
					if (i != 0) del = "<br>"
					txt = txt + del + out[i];
				}
				$('#iMeta').html(fmtMeta(meta));
				$('#iParDef').html(txt);
				
			}
		})
		.catch(error => {
			log(error);
		})
	}
}
function getRefs(def) {
	if (!def.includes("till ") || !def.includes("'")) {
		return "";
	}
	def = def.slice(2);
	def = def.replaceAll("till ", "");
	def = def.replaceAll("'","");
	arr = def.split(",");
	if (DEBUG) log("getRef(), arr = " + arr);
	return arr;
}

function onlineLookup(elHTML, ev) {	
	if (DEBUG) log("onlineLookup(elHTML, ev)");
	ev.preventDefault()
	word = elHTML.innerText;
	if (word.length === 0) word = elHTML.value;
	if (word.length === 0) word = CUR_WORD;
	if (word.length > 0) {
		let url = "https://svenska.se/tre?sok=" + word + "&pz=1";		
		// Rebust escaping of special characters		
		TAB_DUMMY = window.open("http://localhost/svenska/dummy?word=" + word,"","toolbar=no, menubar=no, location=no,popup=yes, left=0, top=0, width=1920,height=1200");				
		TAB_LOOKUP = window.open(bulletProofUrl(url), '_blank');						
		TAB_DUMMY.focus();
		
		setTimeout(switchTab, 1000);

	}
}

function switchTab() {	
	TAB_DUMMY.close()
	TAB_LOOKUP.focus();		
}

function wordCount() {
	// Hash to prevent cached result being returned.
	fetch('backend/wordCount.php?hash=' + makeHash(), {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		},
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		N_TOT = json["total"];
		N_ALL = json["all"];		
		N_ADJ = json["adj"];
		N_VERB = json["verb"];
		N_ADVERB = json["adverb"];
		N_FRASER = json["fraser"];
		N_EN = json["substantiv_en"];
		N_ETT = json["substantiv_ett"];		
		N_PLURAL = json["plural"];		
		N_PREPOSITION = json["preposition"];
		N_INTERJEKTION = json["interjektion"];
		N_PRONOMEN = json["pronomen"];
		N_PREFIX = json["prefix"];
		N_SLUTLED = json["slutled"];
		N_NUMMER = json["nummer"];
		N_KONJUNKTION = json["konjunktion"];
		N_SUBJUNKTION = json["subjunktion"];
		N_INFINITIV = json["infinitiv"];
		N_ARTIKEL = json["artikel"];
		setN_CUR();		
		$('#iCntTotal').html(N_TOT.toLocaleString('sv'));
	})
	.catch(error => {
		log(error);
	})
}

function showToggle() {
	if (CONTROLS_VISIBLE) {
		// Hide controls 
		$('#iControls').css("display", "none");
		$('#iShowToggle').text("__");
		CONTROLS_VISIBLE=false;
	} else {
		// Make visible class selector and word seeker controls
		$('#iControls').css("display", "block");
		$('#iShowToggle').text("HIDE");
		focusInput()
		CONTROLS_VISIBLE=true;
	}
	if (DEBUG) log("showToggle(); seek.v = " + $('#iInput').css("visibility") + ", sel.v = " + $('#iSelect').css("visibility"));
}

function getSummary() {
var tmpOut = [];
let done = 0;
let score_all = 0;
// for (let i = 0; i < CLASS_LIST.length; i++) {
// Only list the major class groups for brevity
let N = 6;
let N_DONE = CLASS_LIST.length;
let tmpTot = 0;
for (let i = 0; i < N; i++) {
	let c = CLASS_LIST[i];
	// ID used to get deterministic ordering of classes
	fetch('backend/getScore.php?class=' + c + '&id=' + i, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		done++;
		let id = json['id'];						
		tmpOut[id] = ": ";					
		tmpOut[id] += round(json["percent"],2) + "%";					
		score_all += parseInt(json["total"]);
		tmpTot += parseInt(json["count"]);
		let out = "<b>all: " + "score_all" + "%</b>";
		// All serial requests are done
		if (done === N) {
			let header = "Monday: " + TARGET_MONDAY.toLocaleString('sv') + "<br>";
			for (i = 0; i < N; i++) {
				out += "<br>" + CLASSES[i] + tmpOut[i];
			}						
			score_all = Math.round(score_all / tmpTot / 2 * 100 * 100) / 100;
			out = out.replace("score_all",score_all);
			out = header + out;
			// Append auxiliary classes in smaller text
			out += "<br>Aux classes:<br>";
			del = "";						
			for (i = N; i < N_DONE; i++) {
				out += del + CLASSES[i]		
				del = ", ";				
			}	
			$('#iSummary').html(out);
		}												
	})
	.catch(error => {
		log(error);
	})	
}			
}

function newInputWrapper(e) {
	if (DEBUG) log("newInputWrapper()");
	e.preventDefault();
	let word = getInput();
	// Navigation only to a given word class.
	if (word.indexOf("@") === 0) {
		let newClass  = fullClassName(word.substr(1));
		REGEX_WORDS = [];		
		N_REGEX = 0;
		if (newClass != "") {
			setClass(newClass);		
            clearInput();
            return;
		}
	// Navigate to word class + query
	} else if (word.indexOf("@") != -1) {
		// Add word
		let tmp  = word.split("@");
		let tmp2 = tmp[1].split(",");
		let newClass = tmp2[0];
		word = tmp[0]
		if (tmp[1].indexOf(",") != -1) word += ",";
		//setClass(fullClassName(newClass));
		setClass(fullClassName(newClass),word);
		//$('#iInput').val(word);
		//newInputWrapper(e);		
		return;
	} else if (word.indexOf(",") === word.length-1) {	
		// Trim query identifier
		word = word.substr(0,word.length-1)		
		$('#iInput').val(word);
		addWord();
		seekWordSingleClass(word);
		return;
	}
	seekWord(word);
}

function fmtUnit(val, unit) {
	if (DEBUG) log("fmtUnit()");
	let tmp = " (" + val + " " + unit + ")";
	return tmp;
}

function clearInput() {
    debug("clearInput()");
    $('#iInput').val(""); 
}
function handleNumericInput(key) {
	if (DEBUG) log("handleNumericInput(" + key + ")")
	let inc = parseInt(key);	
	setTimeout(clearInput,100);
	if (inc === 0) {
        SCROLL_INC++;		
    } else if (inc === 9) {
        SCROLL_INC--;
    } else {
		SCROLL_INC = key - 1;
	}
    if (SCROLL_INC < 0) SCROLL_INC = 0
    if (SCROLL_INC > 7) SCROLL_INC = 7
    moveSelected();
}

// Called internally when word class is known in advance
function seekWordSingleClass(word = CUR_WORD, last_enum = 1) {		
    debug("seekWordSingleClass(word = " + CUR_WORD + ", last_enum = " + last_enum + ")");
	//LAST_DEF_ENUM = CUR_DEF_ENUM;
	CUR_DEF_ENUM = last_enum; 	
	if (CLASS === "fraser") CUR_DEF_ENUM = 1;
	if (DEBUG) log("seekWordSingleClass(word, last_enum), word = " + word + ", last_enum = " + last_enum)		
	// Immediately play pronunciation if available
	if (word.length > 0) {
		// Any user supplied break breaks are discarded.
		word = word.replaceAll("­","");		
		fetch('backend/seekWord.php?class=' + CLASS + "&word=" + word + "&inc=" + INC, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json();
		})
		.then(json => {
			if (json > -1) {
				setCUR_WORD(word);
				// Put selected word in the middle of the word collection				
				INC = json - 3;
				let ind = 3;
				let mid = N_INC/2;
				if (json < mid - 1) {					
					INC = 0;
					ind = json;
				}
				getWords(ind);		
				getDefInd(last_enum);
			} else if (CLASS === "fraser") {
				frasMatchFuzzy(word);
			} else {
				noMatchSingleClass(word);			
			}
		})
		.catch(error => {
			log(error);
		})
	}
	focusInput();
	log(LAST_WORD);
	log(LAST_CLASS);
}

/* Priorities for search
 1) Regex/match score
 2) Exact match within class
 3) Matches conjugation within class
 4) Matches conjugation within any class (first found).
 */
// Link is set if this seek is called from a clickable link

// Called by user, prefer current class but allow for secondary matching in other word classes
// There is a recursion here somewhere, find it
function seekWord(word, link = false, lastEnum = false) {			
	if (DEBUG) log("seekWord(word, link = false), word = " + word + ", link = " + link);
	//LAST_DEF_ENUM = CUR_DEF_ENUM; // Don't think it is a problem to set this immediately. If no matches found then no harm done. It will be overwritten on next search			
	CUR_DEF_ENUM = 1; // Always show definition #1 for a newly found word
	LAST_CLASS = CLASS;
	// Consider avoid search when we already have a match in the current word class
	/*if (word === CUR_WORD) {
		$('#iInput').val("");
		return;
	}*/	
	// Cleanup
	$('#iAux').html("");	
	$('#iMoreTxt').html("");	
		
	// Any user supplied breaks are discarded.
	word = word.replaceAll("­","");	
	REGEX_WORDS = [];
	// Strip trailing white space	
	while (word.substr(word.length-1) === " ") {
		word = word.substr(0,word.length-1)
	}
	// (Nearly) Always regex for phrases
	if (CLASS === "fraser") {
		if (REGEX_MODE) {		
			word = word.replaceAll("/","\\/");
			word = word.replaceAll("(","\\(");
			word = word.replaceAll(")","\\)");
		}
	}
	$('#iCntRegex').html("");		
	scoreMatch = word.indexOf("redwords") != -1 || word.indexOf("bluewords") != - 1;
	if (REGEX_MODE) {				
		fetch('backend/regexSeek.php?class=' + CLASS + '&regex=' + word, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json()
		})
		.then(json => {
			REGEX_WORDS = json["matches"];			
			N_REGEX = json["count"];			
			$('#iScore').html("");
			$('#iCntRegex').html("*" + N_REGEX + "*");			
			if (N_REGEX > 0) {
				INC = 0;
				SCROLL_INC = -1;				
				getWords(INC)
			} else {
				for (i = 0; i < 8; i++) {
					id = "#w" + i;
					$(id).html("")					
				}				
			}
		})
		.catch(error => {
			log(error);
		})
	} else if (scoreMatch) {
		let score = 0;
		if (word === "bluewords") score = 1;		
		fetch('backend/scoreMatch.php?class=' + CLASS + '&score=' + score, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json();
		})
		.then(json => {
			REGEX_WORDS = json["matches"];			
			N_REGEX = json["cnt"];			
			$('#iScore').html("");
			$('#iCntRegex').html("****" + N_REGEX + "****");			
			if (N_REGEX > 0) {
				INC = 0;
				SCROLL_INC = -1;
				getWords(INC)
			}
		})
		.catch(error => {
			log(error);
		})
	} else {
		REGEX_WORDS = [];
		N_REGEX = 0;
				
		if (word === '') {
			word = LAST_WORD;
			$('#iInput').val(word);
			setClass(LAST_CLASS);
		}
		if (!link) {
			//LAST_WORD = CUR_WORD;
		}
		setCUR_WORD(word);
		// Special case of prefixes and suffices
		if (word.substr(word.length-1) === "-") {
			word = word.substr(0,word.length-1);
			setClass("förled");
		} else if (word.slice(0,1) === "-") {
			word = word.substr(1);
			setClass("slutled");
		}
		if (word.length > 0) {
			fetch('backend/seekWord.php?class=' + CLASS + "&word=" + word + "&inc=" + INC, {
				method: 'get',
				mode: 'cors',
				headers: {
					'Content-Type': 'application/json'
				}
			})
			.then(response => {
				return response.json();
			})
			.then(json => {
				if (json > -1) {
					// Put selected word in the middle of the word collection				
					INC = json - 3;
					let ind = 3;
					let mid = N_INC/2;
					if (json < mid - 1) {					
						INC = 0;
						ind = json;
					}
					getWords(ind);
				} else {
					if (CLASS === "fraser") {
						regexSearch(word);
						return;
					}					
					// If no exact match then check for matching conjugations within class
					fetch('backend/getConj.php?word=' + word + '&class=' + CLASS, {
						method: 'get',
						mode: 'cors',
						headers: {
							'Content-Type': 'application/json'
						}
					})
					.then(response => {
						return response.json()
					})
					.then(json => {
						let res = json["word"];							
						if (res != "") {								
							setClass(json["class"],res);
						} else {
							let follow = false;
							if (word.indexOf("\\") != -1 || word.indexOf("<") != -1) {
								word = word.replaceAll("\\","");
								word = word.replaceAll("<","");
								follow = true;
							}													
							// If no match in specific class useful to show matches in other classes.
							if (!wordFromAll(word)) {
									// If no match then try to find match in conjugations
									fetch('backend/getConj.php?word=' + word + "&class=all", {
										method: 'get',
										mode: 'cors',
										headers: {
											'Content-Type': 'application/json'							
										}
									})
									.then(response => {
										return response.json()
									})
									.then(json => {
										if (json["word"] != "") {									
											setClass(json["class"],json["word"]);
										} else {								
											noMatch(word);
										}
									})
									.catch(error => {
										log(error);
									})					
								}
							}
					})
					.catch(error => {
						log(error);
					})										
				}
			})
			.catch(error => {
				log(error);
			})
		}
	}
	if (DEBUG) log("END seekWord(); word = " + word + " -> INC = " + INC);			
	focusInput()
}

function noMatch(word) {
	$('#iParDef').html("No match in any word class: <b>" + word + "</b>");	
	$('#iMeta').html("");	
	$('#iInput').val(word);
}

function noMatchSingleClass(word) {
	$('#iMeta').html("");	
	$('#iParDef').html("No match: " + word + " in class: " + CLASS);	
	$('#iInput').val(word);
}

function regexSearch(word) {
	if (DEBUG) log("regexSearch()");
	toggleRegexMode(true);
	fetch('backend/regexSeek.php?class=' + CLASS + '&regex=' + word, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json()
	})
	.then(json => {
		REGEX_WORDS = json["matches"];			
		N_REGEX = json["count"];			
		$('#iScore').html("");
		$('#iCntRegex').html("*" + N_REGEX + "*");			
		if (N_REGEX > 0) {
			INC = 0;
			SCROLL_INC = -1;
			getWords(INC)
		} else {
			for (i = 0; i < 8; i++) {
				id = "#w" + i;
				$(id).html("")					
			}
			noMatch(word);
		}
	})
	.catch(error => {
		log(error);
	})
}

function drillDown() {
	if (DEBUG) log("drillDown()");
	// Take word from iWords to allow for special characters such as 'é'
	let id = "#w" + SCROLL_INC;
	let word = $(id).text()	
		
	fetch('backend/getDefAll.php?word=' + word, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		if (Object.keys(json).length > 0) {
			let keys = Object.keys(json);	
			if (keys.length === 1 && keys[0] != CLASS) {			
			// Go direct to class if no ambiguity in found word(s)
				setClass(keys[0]);
				seekWord(word);
				let def = "";
				let delim ="";									
				let tmp = "<span onmouseover=\"highlight(this,event)\"";
				tmp += "onclick=\"setClass(\'_k_\',\'_w_\')\"><i>_k_:</i></span><br>";						
				for (let i = 0; i < keys.length; i++) {			
				let compDef = json[keys[i]];															
				def += delim + tmp.replaceAll("_k_", keys[i]).replace("_w_",word) + makeLinks(compDef);
				delim="<br>";
				LAST_DEF = def;
				$('#iParDef').html("<b>" + word + ":</b><br>" + def);
				}
			}
		}
	})
	.catch(error => {
		log(error);
	})
}

function setClass(c, seek = "") {
    debug("setClass(" + c + ", seek = " + seek + ")");
	if (c === "all") clearRegexMode();	
	if (DEBUG) log("setClass(c, seek), c = " + c + ", seek = " + seek);
	$('#iAux').html("");	
	$('#iMeta').html("");	
	
	//wordCount(); // Think it is better to do word count only when there is an addition to the listing. This line was a previous hack.
	if (c != CLASS) {		
		REGEX_WORDS = [];
		N_REGEX = 0;
		$('#iCntRegex').html("");
		$('#iDefDiv').css("display", "none");
		$('#iWords').css("visibility", "visible");
		if (c != "all") {
			$('#iDefProgContainer').css("visibility","visible");
		} else {
			$('#iDefProgContainer').css("visibility","hidden");
		}
		CLASS = c;
		INC = 0;
		SCROLL_INC=-1;
		setN_CUR();	
	} else {
		getWords();
	}
	if (seek.length > 0) {
		seekWordSingleClass(seek, LAST_DEF_ENUM);
	} else {
		getWords();
	}
	updateScore();
}

function getLastWord() {
	debug("getLastWord()");
	if (LAST_WORD.length > 0 && LAST_CLASS != "all") {		
		let tmp = CLASS;
		setClass(LAST_CLASS,LAST_WORD);		
		LAST_CLASS = tmp;
	}
}

function countDefs() {
	N_LEMMAS = 0;
	// No sense in associating definitions with the 'all' word listing
	if (CLASS != "all") {
		fetch('backend/countDef.php?class=' + CLASS, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json();
		})
		.then(json => {
			if (json != "Failed to read definition file.") {	
				N_LEMMAS=json["cnt"];
				if (DEBUG) log("countDefs(); N_LEMMAS = " + N_LEMMAS);
				$('#iDefProg').css("width", N_LEMMAS/N_CUR * 100 + "%");
			} else {
				if (DEBUG) log("countDefs(); N_LEMMAS = " + N_LEMMAS);
			}
		})
	}
}

function editDef() {	
	debug("editDef()")	
	if ($('#iParDef').text() != "" || CLASS === "fraser") {
		showWords();
		$('#iDefDiv').css("display", "block");
		$('#iPutDef').css("display", "block");
		$('#iDivMore').css("display", "none");
		focusDef();
	}	
}

function editDefWrapper(e) {
	e.preventDefault()
	editDef()
}

function clearDef() {
	if (DEBUG) log("clearDef()");
	if ($('#iWords').css("visibility") === "hidden") {
		$('#iParDef').html("");
		$('#iWords').css("visibility", "visible");
		$('#iDefDiv').css("display", "none");
		SCROLL_INC = -1;
		for (let i = 0; i< N_FOUND; i++) {
			$('#w' + i).css("fontWeight", "");
		}
	}
}

function pretty(def) {
	if (DEBUG) log("pretty(def); def = " + def);
	let out = "";
	subdefs = def.split("<br>");
	for (let i = 0; i < subdefs.length; i++) {
		del = "<br>";
		if (i === 0) del="";
		s = subdefs[i];		
		pJFR = s.indexOf("JFR");
		pSE = s.indexOf("SE");
		pMOTS = s.indexOf("MOTSATS");
		pSYN = s.indexOf("SYN");
		let tot = pJFR + pSE + pMOTS + pSYN;
		if (tot === -4) {
			out = out + del + s;
		} else {
			// New line before the JFR, SE, MOTS indicators for styling
			if (pJFR === -1) pJFR = 999999;
			if (pSE === -1) pSE = 999999;
			if (pMOTS === -1) pMOTS = 999999;
			if (pSYN === -1) pSYN = 999999;
			let start = pSE;
			if (pJFR < start) start = pJFR;
			if (pMOTS < start) start = pMOTS;
			if (pSYN < start) start = pSYN;
			let def2 =  s.slice(start,s.length);
			s = s.slice(0,start) + "<br>"
			def2 = def2.replaceAll("1","").replaceAll("2","").replaceAll("3","").replaceAll("4","");
			def2 = def2.replaceAll(" ,",",").replaceAll("  ", " ");
			def2 = def2.replaceAll(" 1<br>","<br>");
			out = out + del + s + def2;
		}
	}
	out = out.replaceAll("<br><br>","<br>");
	for (let i = 1; i < 24; i++) {
		out = out.replaceAll(i + " " + i, i);
		out = out.replaceAll("<br>" + i + "<br>","<br>" );
		out = out.replaceAll("<br> " + i + "<br>","<br>" );
		out = out.replaceAll("<br>" + i + " <br>","<br>" );
	}
	// Strip any leading new line
	if (out.slice(0,3) === "<br>") {
		out = out.slice(4,out.length) 
	}
	const regex1 = /[a-z][1-9]/;
	match = out.match(regex1);
	if (match != null) {
		log(match);
		strMatch = match[0];
		rep = strMatch[0] + "<br> " + strMatch[1];
		out = out.replace(strMatch, rep);
	}
	if (out[0] === " ") out = out.slice(1,out.length);
	out = out.replace("partikelntill", "partikeln till;");
	if (out[out.length-1] === ",") out = out.slice(0,out.length-1)
	return out;
}

function fullClassName(name) {
	if (name === "a") return "all"
	if (name === "en") return "substantiv_en"
	if (name === "ett") return "substantiv_ett"
	if (name === "adj") return "adjektiv"
	if (name === "adv") return "adverb"
	if (name === "fra") return "fraser"
	if (name === "sub") return "subjunktion"	
	if (name === "plu") return "plural"
	if (name === "prep") return "preposition"
	if (name === "pro") return "pronomen"
	if (name === "for") return "förled"
	if (name === "för") return "förled"
	if (name === "slut") return "slutled"
	if (name === "slut") return "slutled"
	if (name === "räk") return "räkneord"
	if (name === "kon") return "konjunktion"
	if (name === "int") return "interjektion"
	if (name === "inf") return "infinitiv"
	if (name === "art") return "artikel"
	return name
}

function guessClass(word) {
	// Prefer explicit definition of class
	if (word.includes('(') && word.includes(')')) {
		// grab class	
		let start = word.indexOf('(')
		let end = word.indexOf(')')	
		if (start > end || start === -1) return 
		let c = word.slice(start+1,end);
		c = fullClassName(c);
		return c;
	} 
	// Otherwise try and semi-intelligently guess word class
	if (word.endsWith('a')) return "verb"
	if (word.endsWith('as')) return "verb"
	if (word.includes(' ')) return "verb"
	if (word.endsWith("ig")) return "adjektiv"
	if (word.endsWith("lös")) return "adjektiv"
	if (word.endsWith("sam")) return "adjektiv"
	if (word.endsWith("full")) return "adjektiv"
	if (word.endsWith("ell")) return "adjektiv"
	if (word.endsWith("isk")) return "adjektiv"
	if (word.endsWith("ad")) return "adjektiv"
	if (word.endsWith("en")) return "adjektiv"
	if (word.endsWith("p")) return "substantiv_ett"
	if (word.endsWith("ism")) return "substantiv_en"
	return "substantiv_en"
}

function removeClassDesc(word) {
	let start = word.indexOf('(');
	let end = word.indexOf(')');
	if (start > end || start === -1) return word 	
	return word.slice(0,start-1)
			
}

function removeWord() {
	if (DEBUG) log("removeWord()");
	addWord(true);
}

function addWord(remove = false) {	
	if (DEBUG) log("addWord()");	
	
	let word = $('#iInput').val();		
	let del = (word[word.length-1] === "." && word.indexOf("..") === -1) || remove;
	if (CLASS === "fraser" && !del) {
		editDef();
		return;
	}
	
	if (word[0] === '.') word = word.slice(1,word.length);
	word = word.replaceAll("/","\/");
	// Don't want characters in the storage key that the user would not enter
	word = word.replaceAll("­","");
	if (word[word.length-1] === '.' && del) word = word.slice(0,word.length-1);
	if (word.length > 0) {
		let op = "add"	
		if (del) op = "remove"
		fetch('backend/' + op + 'Word.php?class=' + CLASS + "&word=" + word, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			if (op === "remove") {
				// If this was the last listing of this word delete from "all" listing also
				fetch('backend/getDefAll.php?class=all&word=' + word, {
					method: 'get',
					mode: 'cors',
					headers: {
						'Content-Type': 'application/json'
					}
				})
				.then(response => {
					return response.json();
				})
				.then(json => {
					// It was last reference
					if (json.length < 1) {
						fetch('backend/removeWord.php?class=all&word=' + word, {
							method: 'get',
							mode: 'cors',
							headers: {
								'Content-Type': 'application/json'
							}
						})
						.catch(error => {
							log(error);
						})
						getWords();
						wordCount();
						
					}
				})
				.catch(error => {
					log(error);
				})
			// Navigate to newly added word for convenience.
			} else if (op === "add") {
				// Undesirable to have '­' character in word keys as user not expected to specifiy these. 
				word = word.replace("­","");
				seekWordSingleClass(word)
			}
		})
		.catch(error => {
			log(error);	
		})
	}	
}

function addWordWithEnum() {
	if (DEBUG) log("addWordWithEnum()");
	// Get enum index
	let word = $('#iInput').val();		
	if (word.length === 1) return;
	CUR_WORD = word.replace("#","");	
	fetch('backend/getIndEnum.php?word=' + CUR_WORD + '&class=' + CLASS, {
		nethod: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}	
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		let indEnum = json;
		CUR_WORD = CUR_WORD + "  " + indEnum;
		fetch('backend/addWord.php?class=' + CLASS + "&word=" + CUR_WORD, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		setTimeout(seekWordSingleClass, 500);
	})
	.catch(error => {
		log(error);
	})	
}

function addMeta(def) {
	// If a known meta phrase is identified at start of definition line then enclose it in square bracket formatting
	if (DEBUG) log("addMeta()");	
	regexArr = [
		/var­dagligt, skämtsamt/,
		/ålderdomligt el. ironiskt/,
		/sjö­fart/,
		/något ålderdomligt el. dialektalt/,
		/hög­tidligt el. skämtsamt/,
		/handels­namn/,
		/något ålderdomligt], ur­sprungligen bibliskt/,
		/sär­skilt i juridiska samman­hang/,
		/starkt ned­sättande; något ålderdomligt/,
		/ned­sättande, något ålderdomligt/,
		/något hög­tidligt; något ålderdomligt/,
		/var­dagligt el. i barn­språk/,
		/nästan en­bart i fack­språk/,
		/skämtsamt/,
		/dialektalt; något ned­sättande/,
		/kemi/,
		/var­dagligt, dialektalt/,
		/ekonomi, juridik/,
		/endast vid beskrivning av äldre förhållanden/,
		/ofta i natur­namn/,
		/mest i äldre tid/,
		/ofta i offentligt språk/,
		/ofta i politiska samman­hang/,
		/ej i fack­mässiga samman­hang/,
		/var­dagligt, kan upp­fattas som ned­sättande/,
		/var­dagligt, något ålderdomligt; kan upp­fattas som ned­sättande/,
		/var­dagligt; något ålderdomligt/,
		/ofta något hög­tidligt/,
		/något hög­tidligt el. ålderdomligt/,
		/något hög­tidligt; mindre brukligt/,
		/ofta i poetiska samman­hang/,
		/språk­vetenskap/,
		/sär­skilt i affärs­mässiga och vetenskapliga samman­hang/,
		/samman­fattande, formell beteckning/,
		/nu­mera ej officiell benämning/,
		/ofta i värderande ut­tryck/,
		/ofta statistik/,
		/ofta ironiskt/,
		/mest i vetenskapliga samman­hang/,
		/nu­mera sällan i fack­mässiga samman­hang/,
		/nu­mera mindre brukligt i fack­mässiga samman­hang/,
		/i fackspråkliga samman­hang/,
		/nu­mera mindre brukligt/,
		/ofta i religiösa samman­hang/,
		/sär­skilt bibliskt; något ålderdomligt ut­om i vissa ut­tryck/,
		/sär­skilt geometri/,
		/ofta i bild­konst/,
		/mest som marxistisk term/,
		/sär­skilt medicin, psykologi/,
		/sär­skilt medicin/,
		/sär­skilt i handels­språk/,
		/medicin/,
		/något hög­tidligt ut\u00ADom i sammansättn./,
		/hög­tidligt; mest bibliskt/,
		/något hög­tidligt el. formellt/,
		/något hög­tidligt el. skämtsamt/,
		/ibland något hög­tidligt/,
		/något hög­tidligt/,
		/hög­tidligt/,			
		/något var­dagligt/,
		/var­dagligt; dialektalt/,
		/var­dagligt; något ned­sättande/,
		/var­dagligt; ned­sättande/,
		/ibland något ned­sättande/,
		/något ned­sättande/,
		/ned­sättande; ålderdomligt/,
		/var­dagligt; vanligen något ned­sättande/,
		/var­dagligt; ned\u00ADsättande/,
		/var­dagligt, ibland något ned­sättande/,
		/var­dagligt; sär­skilt sport/,
		/starkt var­dagligt/,
		/var­dagligt/,
		/dialektalt/,
		/i fack­språk/,
		/ofta i fackspråkliga samman­hang/,
		/nu\u00ADmera ej i fack\u00ADmässiga samman\u00ADhang/,
		/nu­mera mindre brukligt i fack\u00ADmässiga samman\u00ADhang/,
		/mindre brukligt/,
		/sär­skilt ekonomi/,
		/sär­skilt i matematiskt fack­språk/,
		/sär­skilt matematik/,
		/matematisk/,
		/fysik, kemi m.m./,
		/fysik/,
		/sär­skilt i juridiska samman\u00ADhang/,
		/sär­skilt juridik/,
		/juridik/,
		/sär­skilt i lag­språk/,
		/sär­skilt psykologi/,
		/psykologi/,
		/informations­teknik/,
		/sär­skilt i fack­språk/,
		/ofta i fack­språk/,
		/mest i fack­mässiga samman­hang/,
		/ålderdomligt ut\u00ADom i bibliska samman\u00ADhang/,
		/ålderdomligt ut­om i vissa ut­tryck/,
		/delvis något ålderdomligt/,
		/något ålderdomligt/,
		/något ålderdomligt el. ironiskt/,
		/ålderdomligt/,
		/sär­skilt vid beskrivning av ut­ländska förhållanden/,
		/endast vid beskrivning av ut­ländska förhållanden/,
		/något formellt/,
		/formellt i konkret an­vändning/,
		/formellt/,
		/delvis historiskt/,
		/mest historiskt/,
		/historiskt i Sverige/,
		/historiskt/,
		/sär\u00ADskilt i barn\u00ADspråk och i imiterat barn\u00ADspråk/,
		/mest i fack\u00ADspråk/,
		/mest i sport­jargong/,
		/sär­skilt i vetenskapliga samman­hang/,
		/ofta i tekniska el. vetenskapliga samman­hang/,
		/i tekniska och vetenskapliga samman­hang/,
		/i vetenskapliga samman­hang/,
		/mest i tekniska samman­hang/,
		/mest i vetenskapliga samman\u00ADhang/,
		/sär­skilt i vetenskapliga samman\u00ADhang/,
		/i vetenskapliga samman\u00ADhang/,
		/ålderdomligt el. skämtsamt/,
		/ofta klandrande/,
		/mest vid beskrivning av äldre förhållanden/,
		/sär­skilt vid beskrivning av äldre förhållanden/,
		/äv. som musikalisk term/,
		/musikalisk/,
		/musik/,
		/sär­skilt meteorologi/,
		/sär­skilt i vänster­politisk debatt/,
		/ofta i vänster­politisk debatt/,
		/ofta ned­sättande/,
		/ofta något ned­sättande/,
		/ned­sättande; något ålderdomligt/,
		/ned­sättande/,
		/ibland skämtsamt/,
		/ibland något skämtsamt/,
		/sär­skilt statistik/,
		/sär­skilt filosofi, biologi/,
		/sär­skilt filosofi/,			
		/filosofi/,		
		/i allmän­språket/,
		/sär­skilt sport/,
		/sär­skilt militär­väsen och sport/,
		/sär­skilt militär­väsen/,
		/sär­skilt sjö­fart/,
		/ibland något ironiskt/,
		/sär­skilt arkeologi/,
		/ej officiell svensk beteckning/,
		/nu­mera ej officiell beteckning/,
		/förskönande om­skrivning/,
		/ur­sprungligen bibliskt/,
		/bibliskt/,
		/ofta fysik och teknik/,
	]
	if (def.length < 3 || def[0].match(/A-Z/)) return def
	// Only apply one meta tag
	if (def[2] === "[" && def.indexOf("]") > 2) return def;	
	// Probably don't actual need regex but leave "ias is" for now
	for (i = 0; i < regexArr.length; i++) {
		let rawStr = regexArr[i].source;	
		browserDependentDelim = "";
		if (navigator.userAgent.indexOf("Chrome") != -1 ) {
			browserDependentDelim = " ";
		}
		
		if (def.indexOf(rawStr) === 2) {
			def = def.replace(rawStr, "[" + rawStr + "]" + browserDependentDelim);
		}
	}
	return def;
}

function grammar(def) {	
	if (DEBUG) log("grammar()");
	// Only one grammer expression is permitted.
	gArr = [
	 "nästan en­bart presens particip",
	 "nästan en­bart perfekt particip",
	 "vanligen i nekande och frågande ut­tryck",
	 "endast obestämd form sing.; i mer el. mindre adjektivisk an­vändning",
	 "anv. som plur.",
	 "i negerade och frågande samman­hang",
	 "ofta i substantivisk an­vändning",
	 "nästan en­bart bestämd form sing.",
	 "vanligen i böjda former",
	 "nästan alltid bestämd form sing. och med versal",
	 "ofta bestämd form sing. och med versal",
	 "vanligen bestämd form sing. och med versal",
	 "med subst. som för­led",
	 "vanligen placerat efter huvud­ordet",
	 "ofta med versal",
	 "ofta med efter­följande bi­sats",
	 "sär­skilt i pass. konstruktioner",
	 "i konstruktion med komparativ",
	 "ofta substantiverat",
	 "ofta refl. el. perfekt particip",
	 "ofta refl. el. pass.",
	 "ofta refl."			,
	 "med konjunktionen",,
	 "vanligen pres.",
	 "endast pres. el. pret.",
	 "i bestämd form",
	 "vanligen bestämd form sing.",
	 "ofta bestämd form sing.",
	 "vanligen bestämd form",
	 "ofta plur.",
	 "knappast plur.; i vissa ut\u00ADtryck",
	 "knappast plur.",
	 "vanligen plur.",
	 "sällan plur.",
	 "vanligen part.",
	// ToDo regex to get word reference	,
	 "ofta i sammansättn."		,
	 "mest i sammansättn.",
	 "nu­mera vanligen i sammansätt."	,
	 "vanligen i sammansättn. och i vissa uttryck",
	 "vanligen i sammansättn.",
	"vanligen i vissa sammansätt."			,
	"i vissa ut­tryck och sammansättn."			,
	"i sammansättn.",
	// ToDo regex this one			,
	"vanligen i vissa ut\u00ADtryck",
	"utan böjning, i vissa ut\u00ADtryck",
	"sär­skilt i vissa ut­tryck",
	 "sär­skilt i ett ut­tryck",
	"vanligen i vissa ut\u00ADtryck",
	"i vissa ut\u00ADtryck",
	"vanligen i några ut\u00ADtryck",
	"i några ut\u00ADtryck",
	 "ofta pass. el. perfekt particip"			,
	"ofta pass."			,
	"vanligen pass. el. presens particip",
	"vanligen pass. el. perfekt particip",
	"vanligen pass. och perfekt particip",
	"vanligen pass. el. part.",
	"vanligen refl. el. pass.",
	"vanligen refl. el. perfekt particip.",
	"ofta bestämd form",
	"vanligen perfekt particip",
	"ofta i perfekt particip",
	"ofta perfekt particip",
	"ofta presens particip",
	 "nästan en­bart pres. el. pret.",
	"vanligen perfekt particip"			,
	"vanligen obestämd form sing.",
	"vanligen obestämd form",
	"ibl. två ord",
	"äv. två ord",
	"vanl. två ord",
	"äv. tre ord",
	"ofta tre ord",
	"vanl. tre ord",
	"nästan en\u00ADbart i sammansättn.",
	"nästan en­bart predikativt",
	"endast predikativt",
	"vanligen i konstruktioner"			,
	"vanligen i konstruktion",
	"vanligen i opersonlig konstruktion"			,
	"vanligen i opersonliga konstruktioner"			,
	"i opersonliga konstruktioner"			,
	"i opersonlig konstruktion"			,
	"vanligen opersonlig konstruktion",
	"vanligen koll.",
	 "ofta koll.",
	"ofta i nekande ut­tryck",
	"i nekande ut­tryck",
	"ofta i nekande el. frågande ut­tryck",
	"ofta i nekande konstruktion",
	"vanligen i nekande el. frågande ut­tryck",
	"ofta i nekande ut­tryck",
	"vanligen i nekande ut­tryck",
	"nästan en­bart plur.",
	"i plur.",
	"vanligen predikativt",
	"äv. två ord",
	"ofta två ord",
	"i negerade samman­hang",
	"ofta i negerade ut­tryck"	,
	"i negerade ut­tryck",
	 "i ett få­tal ut­tryck",
	 "i negerade el. frågande samman­hang",
	 "vanligen supinum",
	 "ofta best. form sing.",
	 "ej predikativt",
	 "vanligen pass.",
	 "vanligen presens particip",
	 "vanligen pret.",
	]
	for (i = 0; i < gArr.length; i++) {
		let rep = gArr[i];
		/*
		if (def.indexOf(rep) != -1) {
			end = def.indexOf(rep) + rep.length;
			let after = def.substring(end,end+1);
			if (after === ")")
		}
		*/
		def = def.replace(" " + rep, " (" + rep + ")");		
	}
	return def;
}

function preProc(def) {
	if (DEBUG) log("preProc(def(); def = '" + def + "'")
	// takes user input and splits into "meta", "def" and "more" components
	let meta = "";	
	
	// " ++" is a user-control, remove if present in definition
	def = def.replaceAll(" ++","");
		
	// Check if any meta information exists		
	if (def[0] === " ") def = def.slice(1);
	
	let defArr = def.split("\n");
	// Concenate if multiple spellings are present
	// *** META ***
	if (defArr.length > 3 && defArr[1] === "eller" || defArr[1] === "även" || defArr[1] === "även åld." || defArr[1] === "även vardagligt" || defArr[1] === "eller vardagligt") {
		defArr[0] = defArr[0] + " </i>" + defArr[1] + " <i>" + defArr[2];
		// Move remaining items up two elements
		for (i = 3; i < defArr.length; i++) {
			defArr[i-2] = defArr[i]
		}
		defArr.pop();
		defArr.pop();		
	}

	let firstLine = defArr[0];
	let opts = firstLine.split(" ");
	let firstWord = opts[0];
	let twoWords = "";
	let threeWords = "";
	let fourWords = "";
	// Longer matching only for phrases
	let fiveFras = "";
	let sixFras = "";
	let sevenFras = "";
	let eightFras = "";
	let nineFras = "";
	let tenFras = "";
	if (opts.length > 1) twoWords = firstWord + " " + opts[1];		
	if (opts.length > 2) threeWords = twoWords + " " + opts[2];
	if (opts.length > 3) fourWords = threeWords + " " + opts[3];
	if (opts.length > 4 && CLASS === "fraser") fiveFras = fourWords + " " + opts[4]; 
	if (opts.length > 5 && CLASS === "fraser") sixFras = fiveFras + " " + opts[5];
	if (opts.length > 6 && CLASS === "fraser") sevenFras = sixFras + " " + opts[6];
	if (opts.length > 7 && CLASS === "fraser") eightFras = sevenFras + " " + opts[7];
	if (opts.length > 8 && CLASS === "fraser") nineFras = eightFras + " " + opts[8];
	if (opts.length > 9 && CLASS === "fraser") tenFras = nineFras + " " + opts[9];
	
	var m;
	if (CLASS === "slutled") {
		m = "-" + CUR_WORD;
	} else if (CLASS === "förled") {
		m = CUR_WORD + "-";
	} else {
		m = CUR_WORD;
	}	
	// If the word differs only by conjugation from others in the word class then an additional enumeration is used.
	// Remove this enumeration when checking matching of root word for meta data extraction
	for (i = 2; i < 9; i++) {
		m = m.replace(" " + i, "");
	}
	/// *** META + DEF ****
	LongFrasMatch = fiveFras === m || sixFras === m || sevenFras === m || eightFras === m || nineFras === m || tenFras === m;	
	if (firstWord === m || twoWords === m || threeWords === m || fourWords === m || LongFrasMatch) {		
		meta = defArr[0].replaceAll("_"," ");		
		let del = "";
		def = "";
		for (let i = 1; i < defArr.length; i++) {		
			if (i < 3) {							
				if (defArr[i].indexOf('\u25cf') === 0) {
					def += del + defArr[i];
					del = "\n";
				} else {
					meta += "<br>" + defArr[i].replace("ORDKLASS: ","").replace("UTTAL: ","");
				}
			} else {
				def += del + defArr[i];
				del = "\n";
			}
		}
	}	
	/// *** DEF ***
	// Split definition
	def = def.replaceAll(" JFR", "\nJFR");
	def = def.replaceAll(" SE", "\nSE");
	def = def.replaceAll(" SYN.", "\nSYN.");
	def = def.replaceAll(" MOTSATS", "\nMOTSATS");	
	arr = def.split("\n");
	
	let tmpDef = "";
	let tmpMore = "";
	let del = "";	
	let delDef = "";
	for (i = 0; i < arr.length; i++) {
		// \u25cf or [1-20] is part of a definition
		// Also "JFR", "MOTSATS", "SE" are part of definition
		let cur = arr[i] // current
		let char1 = cur[0];
		let isLink = cur.slice(0,3) === "JFR" || cur.slice(0,6) === "MOTSATS" || cur.slice(0,2) === "SE" || cur.slice(0,3) === "SYN";
		let isNum = false;
		for (j = 1; j < 20; j++) {
			jStr = j.toString();
			n = jStr.length;			
			if (cur.slice(0,n) === jStr) {				
				isNum = true;				
				break;
			}
		}
		let isSingle = char1 === "\u25cf" || char1 === "\u2022"; // single definition		
		let isSamman = cur.slice(0,6) === "till '"// sammansättning
		if (isSingle || isLink || isNum || isSamman || CLASS === "fraser") {			
			tmpDef += delDef + cur;			
			delDef = "\n";			
		} else {			
			if (cur.length != 0) {
				if (cur.slice(0,6) === "belagt") cur = "HISTORIK:<br>" + cur
				tmpMore += del + cur;				
				del ="<br>"
			}
		}		
	}	
	arr = tmpDef.split("\n");
	let outDef = "";
	// Grammer information - Support for partikel parters
	// Can be between 1 and 3 suggested partner words
	let regex1 = /skilt[a-zäöå]+/;
	let regex1_alt = /partikeln[a-zäöå]+/;
	let regex2 = /skilt[a-zäöå]+, [a-zäöå]+/;
	let regex3 = /skilt[a-zäöå]+, [a-zäöå]+, [a-zäöå]+/;
	// Delimiter is blank on first line
	del = "";
	for (s of arr) {				
		if (s.length > 1) {
			// Remove any leading space(s)
			while (s[0] === " ") {
				s = s.slice(1,s.length)
			}
			// Defuault to "pretty" leading bullet point
			if (s[0].match(/[<a-zäöå([]+/) != null) {
				s = `\u25CF ` + s;
			}
			// Leading Meta tags
			// Beware the silent hyphens (\u00AD)			
			// ToDo Move the (many) regx definitions to the function body
			s = addMeta(s)
			
			// Remove any reference numbers other than that at line start
			let trail = s.slice(2,s.length);
			for (let i = 1; i < 24; i++) {				
				trail = trail.replaceAll(" " + i + " "," ");
				if (trail.indexOf(i) === 0) {
					trail = trail.replaceAll(i,"");
				}
			}
			trail = fmtParticles(trail);
			trail = fmtPrep(trail);
			s = s.slice(0,2) + trail;		
			s = s.replaceAll("  ", " ");
			s = s.replaceAll("  ", " ");
			
			if (s.includes("((")) s = s.replace("((", "(");
			// Trailing spaces (or non-breaking space) can break links, remove
			let lastCh = s.charAt(s.length-1);			
			if (lastCh.charCodeAt(0) === 32 || lastCh.charCodeAt(0) === 160) {								
				s = s.slice(0,s.length-1)
			}
			s = grammar(s)
			
			s = s.replace("vanligen med pronomenetsjälv","(vanligen med pronomenet själv)");
			// ToDo Regex this to include the multi-word verbs			
			s = fmtVerbApart(s,/(äv. lös förbindelse, se )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = s.replace("formerna", "formerna ");
			s = s.replace("formen", "formen ");
			s = fmtVerbApart(s,/(äv. lös förbindelse i formen )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = fmtVerbApart(s,/(äv. lös förbindelse, jfr )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = fmtVerbApart(s,/(ofta lös förbindelse i formen )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = fmtVerbApart(s,/(ofta lös förbindelse, se )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = fmtVerbApart(s,/(ofta lös förbindelse se )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = fmtVerbApart(s,/(ofta lös förbindelse, jfr )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = fmtVerbApart(s,/(vanligen lös förbindelse, se )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = fmtVerbApart(s,/(vanligen lös förbindelse, jfr )([a-zöäå]+)(\s[a-zöäå_]+)/);
			s = fmtVerbApart(s,/(äv. lös sammansättn., se )([a-zöäå]+)(\s[a-zöäå_]+)/);			
			// Format "fast sammansättn." grammer
			s = fmtVerbTogether(s,/(vanligen fast sammansättn., se )([a-zöäå_]+)/);
			s = fmtVerbTogether(s,/(vanligen fast sammansättn., jfr )([a-zöäå_]+)/);
			s = fmtVerbTogether(s,/(någon gång fast sammansättn., se )([a-zöäå_]+)/);
			s = fmtVerbTogether(s,/(ofta fast sammansättn., se )([a-zöäå_]+)/);
			s = fmtVerbTogether(s,/(ofta fast sammansättn., jfr )([a-zöäå_]+)/);
			s = fmtVerbTogether(s,/(äv. fast sammansättn., se )([a-zöäå_]+)/);			
			s = fmtVerbTogether(s,/(äv. fast sammansättn., jfr )([a-zöäå_]+)/);			
			s = simpleRef(s);		
			s = simpleBold(s);		
			// ToDo Regex this to include the verb
			//s = grammer(s,"vanligen i förbindelse");			
			s = s.replaceAll("_","");			
			outDef += del + s;			
			// HTML newline separator bon lines subsequent to the first
			del = "<br>";
		}
	}
	outDef = outDef.replace(",,","")
	
	// Get any "more" information that exists in the def
	
	var out = []
	out[0] = outDef;
	out[1] = meta;	
	out[2] = tmpMore;	
	// That's it!
	return out;
}

function fmtParticles(s) {
	if (DEBUG) log("fmtParticles(s)");
	// Particles appear comma delimited with space delimiter before the last particle.

	//const regex1 = /.*med partikel(?: eller dylikt),(sär­skilt)(([a-zöäå]+, )*[a-zöäå]+).*/;		
	const regex1 = /.*med partikel(?: eller dylikt)?(?:, )(sär­skilt)(([a-zöäå]+, )*[a-zöäå]+).*/;		
	match = s.match(regex1);
	
	if (match) s = "(" + s.replace(match[1] + match[2], match[1] + " <b>" + match[2] + "</b>)"); 
	
	const regex2 = /.*med partikel[n]?[,]? t.ex.(([a-zöäå]+, )*[a-zöäå]+).*/;
	match = s.match(regex2);	
	if (match) s = "(" + s.replace(match[1]," <b>" + match[1] + "</b>)");

	const regex3 = /.*med partikeln([a-zöäå]+).*/;
	match = s.match(regex3);
	if (match) s = "(" + s.replace(match[1]," <b>" + match[1] + "</b>)");
	
	const regex4 = /.*med partik[elnarn]+ som an.ger (?:rörelse)?riktning.*(t(?:ill)?\.ex\.|sär.skilt)/;
	match = s.match(regex4);
	
	const regex5 = /.*med partik[elnarn]+ som betecknar riktning.*(t(?:ill)?\.ex\.|sär.skilt)/;
	match = s.match(regex5);
	
	if (match) {
		let tmp = s.replace(match[0],"");
		let tmpArr = tmp.split(",");
		let old = "";
		let rep = "";
		let d = ""
		for(i = 0; i < tmpArr.length; i++) {
			let t = tmpArr[i]
			
			if (t.indexOf(" ") != -1) {
				if (t.indexOf(" ") === 0) t = t.substr(1);				
				old += d + t.split(" ")[0];
				if (t.indexOf(" ") != -1) break;
			} else {
				old += d + tmpArr[i];
			}
			d = ", "
		}
		rep = " <b>" + old + "</b>)";
		s = "(" + s.replace(match[0] + old,match[0] + rep);
	}
		
	const regex6 = /.*med någon av partiklarna(([a-zöäå]+, )*[a-zöäå]+).*/;
	match = s.match(regex6);	
	if (match) s = "(" + s.replace(match[1]," <b>" + match[1] + "</b>)");		
	
	s = s.replace("utan</b>) större betydelse­skillnad", "</b> utan större betydelse­skillnad)");
	s = s.replace("), utan större betydelse­skillnad",", utan större betydelse­skillnad)");
	// Ugly hack for now
	if (s.indexOf("([") != -1) {
		s = s.replace("([","[");
		s = s.replace("]","] (");
		s = s.replace("( ","(");
	}
	return s;
}

function fmtPrep(s) {
	const regex1 = /.*med prep.(([a-zöäå]+, )*[a-zöäå]+).*/;
	match = s.match(regex1);
	// Includes prep in replace for case where 'med' is the preposition
	if (match) s = "(" + s.replace("prep." + match[1],"prep. <b>" + match[1] + "</b>)");	
	return s;
}

function fmtVerbTogether(s,regx) {
	if (DEBUG) log("fmtVerbTogether(s,regx), s = " + s + ", regx = " + regx);	
	m = s.match(regx);
	
	if (m != null) {
		if (m.length === 3) {			
			let link = "<l>_w_</l>".replaceAll("_w_",m[2]);				
			// Allow user to extend the verb to include another partikel e.g. "sig"
			link = link.replaceAll("__"," ");
			s = s.replace(m[0],"(" + m[1] + link + ")");
		}
	}
	return s
}

function  fmtVerbApart(s,regx) {
	if (DEBUG) log("fmtVerbApart(s,regx), s = " + s + ", regx = " + regx);
	m = s.match(regx);
	if (m != null) {
		if (DEBUG) log("fmtVerbApart: Match!");
		if (m.length === 4) {		
			let repWord = m[2] + " " + m[3].substring(1);			
			// remove leading space from second word and replace with regular space.
			let link = "<l>_w_</l>";
			link = link.replaceAll("_w_", repWord);
			// Allow user to match only a single verb word
			link = link.replaceAll(" __","");
			link = link.replaceAll("___", " ");
			s = s.replace(m[0],"(" + m[1] + link + ")");			
		}
	}
	return s	
}
function simpleRef(s) {
	regx = "/\(se äv. ([a-zöäå]+)\)/"
	let link = "<l>_w_</l>";		
	m = s.match(regx);
	if (m) {
		s = s.replace(m[0],"(se äv. " + link.replaceAll("_w_",m[2]) + ")");
	}
	return s;
}

function simpleBold(s) {
	regx = "((vanligen (?:med )?komparativ)([a-zöäå]+))"
	let bold = "<b>_w_</b>";
	m = s.match(regx);
	if (m) {
		s = s.replace(m[0],"(" + m[2] + " " + bold.replaceAll("_w_"," " + m[3]) + ")");
	}	
	return s;
}

function withParticle(s) {
	rep = "ibland with partikel";
	s = s.replace(rep, "(" + rep);
	rep = "ofta with partikel";
	s = s.replace(rep, "(" + rep)
	rep = "vanligen with partikel";
	s = s.replace(rep, "(" + rep);
	repo = "vanligen med någon av partiklarna";
	s = s.replace(rep, "(" + rep);
	return s;
}

// Toggle visibility of word list on right hand side of screen
function showWords() {
	if (DEBUG) log("showWords");
	if ($('#iWords').css("visibility") == "hidden") {
		$('#iWords').css("visibility", "visible");
	}
}

function highlight(el,event) {
	if (event.type === "mouseover") {
		el.style.cursor = "pointer";
	} else {
		el.style.cursor = "";
	}
}

function editCursor(event,el) {
	if (event.type === "mouseover") {
		el.style.cursor = "text";
	} else {
		el.style.cursor = "";
	}
}

function toggleDebugEv(e) {
	e.preventDefault();
	toggleDebug();
}

function toggleDebug() {
	DEBUG = !DEBUG;
	if (DEBUG) {
		log("Entering debug mode...");
		$('#iDebugTxt').text("DEBUG");
		$('#iDebug').css("color","gray");
	}  else {
		$('#iDebug').css("color","");
		$('#iDebugTxt').text("");
		log("Leaving debug mode...");
	}
}
function setClassGuessWrapper(ev) {
	ev.preventDefault();
	let word = $('#iInput').val();
	setClassGuess();	
	seekWord(word);
}
function setClassGuess() {
	let word = $('#iInput').val();
	let c = guessClass(word);
	if (DEBUG) log("setClassGuess, Class guessed as " + c)
	setClass(c);
	seekWord(CUR_WORD);
}
function lookupManyWords() {	
	// Clear existing tabs collection
	TABS.length = 0;
	let n = 8;			
	let start = parseInt(INC) + parseInt(SCROLL_INC);	
	if (start === -1) start = 0
	fetch('backend/getWords.php?&class=' + CLASS + "&start=" + start.toString() + "&num=" + n, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json()
	})
	.then(json => {
		if (json.length < n) n = json.length
		for (let i = 0; i < n; i++) {			
			let word = json[i]
			let url = "https://svenska.se/tre?sok=" + word + "&pz=1";
			// Manual unicode percentage escaping as some browsers misbehave here	
			TABS.push(window.open(bulletProofUrl(url), '_blank'));		
		}	
	})
	.catch(error => {
		log(error);
	})
}

function fmtMeta(meta) {	
	let rep = "<span id='iWordRoot'"
	rep += " onmouseover=highlight(this,event)";
	rep += " oncontextmenu='changeScore(event,-1)'";	
	rep += " onclick='changeScore(event,1)'";	
	// Remove any disambiguation suffix when more than one entry exists for root key
	tmpCUR_WORD = CUR_WORD
	for (i = 2; i < 9; i++) {
		tmpCUR_WORD = tmpCUR_WORD.replace("-" + i, "");		
	}
	rep += "><b>" + tmpCUR_WORD + "</b></span>"
	if (CLASS === "fraser") {
		let tmpMeta = rep = "<i>" + rep + "</i><br>"
		return tmpMeta
	}
	meta = meta.replace(tmpCUR_WORD,rep);
	metaArr = meta.split("<br>");
	let tmpMeta = "";
	delMeta = "";	
	for (let i = 0; i < metaArr.length; i++) {						
		if (i == 0) {
			delMeta = "";
		} else if (i === 1) {
			delMeta = "<br>ORDKLASS: ";
		} else if (i === 2) {
			delMeta = "<br>UTTAL: ";
		} else {
			delMeta = "<br>";
		}
		tmpMeta += delMeta + metaArr[i];
	}
	tmpMeta = "<i>" + tmpMeta + "</i><br>"
	// Multi-line meta information get visual divider from the following definition text.
	if (tmpMeta.indexOf("<br>") != tmpMeta.length - 4) tmpMeta += "---------------------<br>";
	return tmpMeta;
}
function ScrollViewDownWrapper() {

	if (false && $('#iDefDiv').css("display") === "none") {
		scrollViewDown();
	}
}

function bulletProofUrl(url) {
	// Manually do escaping of Swedish unicode characters as browsers can misbehave here
	
	url = url.replaceAll("ä","%C3%A4");			
	url = url.replaceAll("å","%C3%A5");			
	url = url.replaceAll("ö","%C3%B6");	
	url = url.replaceAll("é","%C3%A9");
	return url
}
function closeDefs() {
	if (TABS.length === 0) {
		setClass("all");
	}
	for (i = 0; i < TABS.length; i++) {
		TABS[i].close();
	}
	TABS.length = 0;
}
function keyNav(ev) {
	ev.preventDefault();
	log("nav");
}

function editNext() {
	if (DEBUG) log("editNext()")
	if (SCROLL_INC < N_FOUND-1) {
		SCROLL_INC++;
	}
	let cur = "#w" + SCROLL_INC;
	setCUR_WORD($(cur).text());
	editDef();
	// ToDo show any current definition
}
function displaySelection() {
	for (let i = 0; i < N_FOUND; i++) {
		let tmp = "#w" + i;
		$(tmp).css("font-weight", "")
	}
	let cur = "#w" + SCROLL_INC;
	$(cur).css("font-weight", "bold");
}
function clickMiddle(ev) {
	if (DEBUG) log("clickMiddle()");
	ev.preventDefault();			
	if (ev.target.style.cursor != "pointer" && ev.target.className != "redWord" && ev.target.className != "blueWord") {
		if ($('#iDefDiv').css("display") === "none" && $('#iParDef').text() === "") { 
			let btn = ev.button;
			if (btn === 0) {
				scrollViewDown()
			} else {
				scrollViewUp(ev)
			}	
		}
	}
}
function getCurr() {
	if (SCROLL_INC === -1) {
		return INC
	} else {
		return (parseInt(INC) + parseInt(SCROLL_INC))
	}
}
function nextWord(el,ev) {
	ev.preventDefault();
	if (DEBUG) log("nextWord()")
	// Find the next word with the relevant score
	updateScore();
	let score = 0;
	if (el.className === "blueWord") score = 1
	let back = ev.button === 2;
	fetch('backend/getNextWord.php?class=' + CLASS + '&start=' + getCurr() + '&score=' + score + '&back=' + back, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json()
	})
	.then(json => {
		seekWord(json);
	})
	.catch(error => {
		log(error)
	})		
}
function putMore() {
	if (DEBUG) log("putMore()")	
	let more = $('#iDefText').val();
	more = more.replaceAll("\n","<br>");	
	if (more.substring(0,4) === "<br>") {
		more = more.substring(4);
	}
	if (more.indexOf("HISTORIK") == -1) {
		if (more.indexOf("<h>") != -1) {
			more = more.replace("<h>","HISTORIK:");
		} else {
			more = more.replace("belagt","HISTORIK: belagt");
		}
	}
	let key = CUR_WORD.replaceAll(" ","-") + "_" + CUR_DEF_ENUM;	
	fetch('backend/putMore.php?key=' + key.replace("-1","0") + '&class=' + CLASS + '&more=' + more, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		//Done
		$('#iDefText').val("");
		$('#iDefDiv').css("display", "none");
		$('#iDivMore').css("display", "none");
		toggleMore(key,true)
		$('#iInput').focus();
	})
	.catch(error => {
		log(error)
	})
}
// 1-based indices instead of 0-based for storage
function keyForUser(key) {
	start = key.indexOf("_");
	let res = key;
	if (start === -1) return key
	zero_based_ind = parseInt(key.substring(start+1));
	one_based_ind = zero_based_ind + 1
	res = key.replace("_" + zero_based_ind, "_" + one_based_ind);	
	res = res.replaceAll("-"," ");
	res = res.replaceAll("_", " (");
	res = res + "/" + N_DEF;
	res = res + ")";
	return res
}

function getMore(ind) {		
	if (CLASS === "fraser") return;
	if (!isNumeric(ind)) {
		log("getMore(ind), ind is NaN");
		return;
	}
	
	if (DEBUG) log("getMore(ind), ind = " + ind);			
	ind--;
	if (ind > N_DEFS) return;
	let key = CUR_WORD.replaceAll(" ","-") + "_" + ind;	
	fetch('backend/showMore.php?class=' + CLASS + '&word=' + key, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json()
	})
	.then(json => {								
		if (json.length === 0) {
			$('iMoreTxt').html("");
		} else {												
			// Add links
			moreArr = json.split("<br>");
			let del = "";
			let tmpMore = "<br>";
			for (i = 0; i < moreArr.length; i++) {
				tmpMore += del + moreArr[i];
				moreArr[i];					
				del = "<br>";					
			}
			let tmp = "*********************<br>"
			//let tmp = "---------------------<br>"
			tmp += "<span id='iMore' oncontextmenu=editMore(event,'" + key + "')";						
			tmp += " onmouseover='highlight(this,event)'" + tmpMore;

			tmp = tmp.replaceAll("KONSTRUKTION: ", "<b>KONSTRUKTION:</b>");
			tmp = tmp.replaceAll("SAMMANSÄTTN./AVLEDN.:","<b>SAMMANSÄTTN./AVLEDN.:</b>");
			tmp = tmp.replaceAll("EXEMPEL:","<b>EXEMPEL:</b>");
			tmp = tmp.replaceAll("HISTORIK:","<b>HISTORIK:</b>");
			// Use displayDef to to dynamise word links
			// Dynamise links
			tmp = tmp.replaceAll("<l>","<span onclick=followLink(this.innerText) onmouseover=highlight(this,event)><b>");
			tmp = tmp.replaceAll("</l>","</b></span>");
			$('#iMoreTxt').html(tmp);
			let moreHeight = parseInt($('#iMoreTxt').css("height").replace("px",""));
			MORE_LIM = 350; // If bigger than this then scrolling is required
			if (moreHeight > MORE_LIM) {			
				$('body').css("overflow-y", "scroll");														
				window.scrollTo(0,LAST_SCROLL_Y);
			} else {			
				$('body').css("overflow-y", "hidden");
			}
												
		}				
	})
	.catch(error => {
		log(error);
	})
}



function editMore(ev,key) {
	if (DEBUG) log(ev,key)	
	ev.preventDefault();
	let tmp = $('#iParDef').html();
	if (tmp.indexOf(" --") === -1 && tmp.indexOf(" ++") != -1) {
		CACHED_DEF_HTML = $('#iParDef').html();		
	}
	$("#iPutDef").css("display", "none");
	$('#iDefDiv').css("display", "block");
	$("#iDivMore").css("display", "block");	
	$("#iPutMore").css("display", "block");	
	focusDef();
}

function processKeyDown(ev) {
		
	if (DEBUG) log("processKeyDown(ev), ev.key = " + ev.key)	
	
	if (ev.key === "Escape") {
		$('#iInput').val("");
	}
	if (ev.key === "!") {
		ev.preventDefault();
		$('#iInput').val($('#iInput').val() + "!");
	}
	if (ev.key === "ArrowUp") {
		let el = document.getElementById("iInput");
		onlineLookup(el,ev);
		// ?!
		focusDef()
	} else if (ev.key === "ArrowDown" && CLASS === "all") {
		drillDown()
	} else if (ev.key === "Insert") {
		addWord();	
	} else if (ev.key === "Delete") {
		removeWord();
	} else if (ev.key === "F1") {
		//showHelp
	} else if (ev.key === "*" || ev.key === "(") {
		if (!REGEX_MODE) {
			ev.preventDefault();
			fromEnglish();
		}
	} else if (ev.key === "ArrowDown") {
		fetchDef();
	} else if (ev.key === "F6") {
		walkListing();
	} else if (ev.key === "#") {
		addWordWithEnum();
	} else if (ev.key === '"') {
		defaultMeta();
	} else if (ev.key === "¤") {
		togglePlural();
		ev.preventDefault();
	} else if (ev.key === '!') {
		defaultMeta(false);
	} else if (ev.key === "ArrowLeft" || ev.key === "ArrowRight") {		
		navDef(ev);
	}
	
	if (ev.location === 2) {
		if (ev.key === "Control") {			
			if (CLASS != "all") {				
				setClass("all");
				randomWord();
			} else {
				$('#iInput').val("");
				REGEX_WORDS = [];
			}
		}
	}
	if (ev.key === "PageDown") {
		ev.preventDefault();
		scrollViewDown();
	} else if (ev.key === "PageUp") {
		scrollViewUp(ev);
	} else if (ev.key === '§' || ev.key === '`') {
		ev.preventDefault();
		getLastWord();	
	}	
    let regexNumeric = /^\d*$/
	if (ev.key.match(regexNumeric)) {		
		if (ev.key === "0" || ev.key === "9" || ev.location === 3) {			
			ev.preventDefault();	
			handleNumericInput(ev.key);
		}
        
    }
}

function navDef(ev) {
	if (DEBUG) log("navDef(ev)");
	let tmp = $('#iInput').val();
	
	if (tmp.length === 0) {
		if (ev.key === "ArrowLeft") {			
			CUR_DEF_ENUM--;
			if (CUR_DEF_ENUM < 1) CUR_DEF_ENUM = 1;
		} else if (ev.key === "ArrowRight") {
			CUR_DEF_ENUM++;
			if (CUR_DEF_ENUM > N_DEFS) CUR_DEF_ENUM = N_DEFS;
		}
		def = getDefInd(CUR_DEF_ENUM);
		displayDef(def,CUR_WORD);
		getMore(CUR_DEF_ENUM);
	}	
}

function clearMore() {
	let key = CUR_WORD.replaceAll(" ","-") + "_" + CUR_DEF_ENUM;
	if (DEBUG) log("clearMore(key), key = " + key)
	fetch('backend/clearMore.php?key=' + key + '&class=' + CLASS, {
		method: 'get',
		mode: 'cors',
		heaaders: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		
	})
	.catch(error => {
		log(error)
	})
	toggleMore(key,true);
	$('#iDefDiv').css("display", "none");
	$('#iDivMore').css("display", "none");
}
function hack(ev) {
	if (DEBUG) log("hack()");
	ev.preventDefault();
	$('#iDefDiv').css("display","block");
}

function defEntry(ev) {
	if (ev.location === 2) {
		if (ev.key === "Control") {			
			if ($('#iPutDef').css("display") === "block") {
				putDef('',2);
				$('#iInput').val("");
				focusInput()
				seekWord(CUR_WORD);
			}
			if ($('#iPutMore').css("display") === "block") { 
				putMore()
			}
		}
	} else if (ev.location === 3) {
		if (ev.key === "0") {
			ev.preventDefault();
			putDef('',0);
			$('#iInput').val("");
			focusInput()
			seekWord(CUR_WORD);
		} else if (ev.key === "1") {
			ev.preventDefault();
			putDef('',1);
			$('#iInput').val("");
			focusInput()
			seekWord(CUR_WORD);
		}
	}	
	if (ev.key === "Escape") {		
		$('#iDefDiv').css("display","none");
	}
}

function showCachedDef(el) {
	if (DEBUG) log("showCachedDef(el), el = " + el);
	$('#iParDef').html(CACHED_DEF_HTML);	
	$('#iParDef').css("display","block");
}

function changeScore(ev,diff) {
	ev.preventDefault();
	ev.stopPropagation();
	$('#iDefDiv').css("display","none");
	fetch('backend/changeScore.php?word=' + CUR_WORD + '&class=' + CLASS + '&diff=' + diff, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-type': 'application/json'
		}		
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		if (json["res"] === "success") {		
			let newScore = json["new"];
			let id = "#w" + parseInt(SCROLL_INC);
			$(id).css("color",SCORE_COLOURS[newScore]);			
			updateScore();
		}
	})
}
function randomWord() {
	// Hash is to prevent caching of the url by the browser. Server ignores the hash	
	fetch('backend/randomWord.php?class=verb&hash=' + makeHash(), {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}		
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		INC = json["ind"]-4;
		setCUR_WORD(json["word"]);		
		getWords(3);		
	})
	.catch(error => {
		log(error);
	})	
}

function makeHash() {
	let dt = new Date();
	let hash = dt.getDate() + "/" + dt.getMonth() + "/" + dt.getFullYear() + " " + dt.getHours() + ":" + dt.getMinutes() + ":" + dt.getSeconds();
	return hash;
}

function toggleRegexMode(force = false) {
	if (DEBUG) log("toggleRegexMode()")
	REGEX_MODE = !REGEX_MODE
	if (REGEX_MODE || force) {
		$('#iInput').css("background", "navajowhite")
	} else {
		$('#iInput').css("background", "beige")
	}
}

function clearRegexMode() {
	if (DEBUG) log("clearRegexMode()");
	REGEX_MODE = false;
	$('#iInput').css("background", "")
}

function bodyListener(ev) {
	if (ev.key === "Home") {
        focusInput();
    } else if (ev.key === "F2") {
        toggleScores();
    } else if (ev.key === "v") {
        if (! $('#iInput').is(":focus")) {
			if(! $('#iDefText').is(":focus")) {
				ev.preventDefault();
				setClass("verb");
			}
        }
    } else if (ev.key === "d") {
        if (! $('#iInput').is(":focus")) {
			if(! $('#iDefText').is(":focus")) {
				ev.preventDefault();
				setClass("adjektiv");
			}
        }
    } else if (ev.key === "n") {
        if (! $('#iInput').is(":focus")) {
			if(! $('#iDefText').is(":focus")) {
				ev.preventDefault();
				setClass("substantiv_en");
			}
        }
    } else if (ev.key === "t") {
        if (! $('#iInput').is(":focus")) {
			if(! $('#iDefText').is(":focus")) {
				ev.preventDefault();
				setClass("substantiv_ett");
			}
        }
    } else if (ev.key === "a") {
        if (! $('#iInput').is(":focus")) {
			if(! $('#iDefText').is(":focus")) {
				ev.preventDefault();
				setClass("adverb");
			}
        }
    } 
}

function defaultMeta(hasPlural = true) {
	let meta = "";
	let len = CUR_WORD.length;
	let lastChar = CUR_WORD.slice(-1)
	if (CLASS === "substantiv_en") {
		meta = CUR_WORD + " ~en"
		if (hasPlural) meta += " ~ar"
		meta += "<br>substantiv";			
		if (CUR_WORD.slice(-3) === "het") meta = meta.replace("~ar","~er");
		if (lastChar === "e" || lastChar === "a") {
			meta = meta.replace("~en","~n").replace(" ~ar","");
		}
	} else if (CLASS === "substantiv_ett") {
		meta = CUR_WORD + " ~et"
		if (hasPlural) meta += " ~en"
		meta += "<br>substantiv";
		if (CUR_WORD.slice(-4) === "ande" || lastChar === "e") {
			meta = meta.replace("~et","~t");
			meta = meta.replace("~en","~n");
		}
	} else if (CLASS === "adjektiv") {
		meta = CUR_WORD + " ~t ~a<br>adjektiv";
		if (CUR_WORD.slice(-2) === "ad") meta = CUR_WORD + " " + CUR_WORD.slice(len - 2) + "at" + " " + CUR_WORD + "e<br>adjektiv";
	} else if (CLASS === "verb") {
		meta = CUR_WORD + " ~de ~t<br>verb";
	}
	// So far only support for "en" words
	if (CLASS != "substantiv_en" && CLASS != "adjektiv" && CLASS != "verb" && CLASS != "substantiv_ett") return;
	fetch('backend/putDef.php?score=&def=' + '&meta=' + meta + '&class=' + CLASS + '&word=' + CUR_WORD, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		seekWordSingleClass();
	})
	.catch(error => {
		log(error);
	})
}

function togglePlural() {
	if (DEBUG) log("togglePlural()");
	// Go direct to the backend to make the change.	
	// Only support "en" words for now.
	if (CLASS === "substantiv_en" || CLASS === "substantiv_ett") {
		fetch('backend/togglePlural.php?word=' + CUR_WORD + "&class=" + CLASS, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json();
		})
		.then(json => {
			if (json["status"] === "updated") {
				updateDef();
			}
		})
		.catch(error => {
			log(error);
		})
	}
	
}


// Gamificiation of progress, show daily and weekly goal + end date
function setTargets() {
	if (DEBUG) log("setTargets()");
	fetch('backend/setTargets.php?cur_score=' + TOTAL_SCORE, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		RATE = json["rate"];
		TARGET_DAILY = json["targetDaily"];		TARGET_MONDAY = json["targetWeekly"];
		getDiff();
	})
	.catch(error => {
		log(error);
	})
}

function getDiff() {
	if (DEBUG) log("getDiff()");
	let diff = "";
	let fmt = "";
	if (TARGET_DAILY != 0) {		
		// Express diff as a percentage of the intended rate
		diff = ((TOTAL_SCORE - TARGET_DAILY) / RATE * 100);		
		diff = Math.round(diff);
		if (diff > 0) {
			fmt = " <span class='diffPlus'>_diff_</span>";
		} else {
			fmt = " <span class='diffMinus'>_diff_</span>";
		}
		fmt = fmt.replace("_diff_",diff);
	}
	$('#iTotalScore').html(TOTAL_SCORE.toLocaleString('sv') + fmt);
}

function round(dec, places) {
	let mult = 10 ** places;	
	let res = Math.round(dec * mult) / mult;
	return res;
}

function fetchDef() {
	if (DEBUG) log("fetchDef()");
	$('#iMeta').html("searching for '<b>" + CUR_WORD + "</b>' ... ");
	$('#iParDef').html("");
	$('#iMore').html("");
	let backend = 'backend/ScrapeDef.php?word=' + CUR_WORD + '&class=' + CLASS
	if (CLASS === "fraser") {	
		let query = $('#iInput').val();
		query = query.replaceAll("­",""); // No invisible chars to user present in keys
		backend = 'backend/scrapeIdiom.php?query=' + query
	}
	fetch(backend, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})	
	.then(json => {		
		if (CLASS === "fraser") {			
			let tmp ="";
			let keys = Object.keys(json);
			del = "";
			for(let i = 0; i < keys.length; i++) {
				tmp += del + keys[i] + "%% " + json[keys[i]];
				del = "\n";
			}			
			$('#iDefDiv').css("display", "block");
			$('#iPutDef').css("display", "block");
			$('#iDivMore').css("display", "none");
			focusDef();
			$('#iDefText').val(tmp);					
			
		} else {
			if (! json.hasOwnProperty("error")) {
				addDef(json['key'],json['meta'],json['def'],json['more']);		
			} else {
				$('#iMeta').html("Failed to find match");
			}
		}
	})
	.catch(error => {
		log(error);
	})
}

function getRaw() {
	if (DEBUG) log("getRaw()")
	fetch('backend/scrapeRaw.php?word=' + CUR_WORD + "&class=" + CLASS, {
		nethod: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}		
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		let url = json;
		window.open(url)
	})
	.catch(error => {
		log(error);
	})
	
	// Make this more intelligent so that it resolves the work class if multiple matches
}

function shortenClass() {
	// easier to handle short file names
	let res = CLASS;
	if (CLASS === "substantiv_en") {
		res = "en";
	} else if (CLASS === "substantiv_ett") {
		res = "ett";
	} else if (CLASS === "adjektiv") {
		res = "adj";
	} else if (CLASS === "interjektion") {
		res = "int";
	} else if (CLASS === "räkneord") {
		res = "räk";
	} else if (CLASS === "slutled") {
		res = "slut";
	} else if (CLASS === "förled") {
		res = "för";
	} else if (CLASS === "adverb") {
		res = "adv";
	} else if (CLASS === "preposition") {
		res = "prep";
	} else if (CLASS === "pronomen") {
		res = "pro";
	} else if (CLASS === "plural") {
		res = "plu";
	}
	return res;
}

function pronounce(word) {
	if (DEBUG) log("pronounce()");
	if (SOUNDS && CLASS != "all") {				
		let shortClass = shortenClass(CLASS);
		let path = "sounds/" + shortClass + "/";
		//word = word.replaceAll(" ", "_");
		fetch('backend/existsAudio.php?class=' + shortClass + '&word=' + word, {			
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
			
		})
		.then(response => {
			return response.json();
		})
		.then(json => {			
			if (json === "exists") {
				//var audio = new Audio(path + word + ".mp3");
				var audio = new Audio(path + word);
				audio.play();
			} else {
                // Try and fetch audio
				if (CLASS != "fraser") {
					fetch('backend/fetchAudio.php?word=' + word + '&class=' + CLASS, {
						method: 'get',
						mode: 'cors',
						headers: {
							'Content-Type': 'application/json'
						}
					})
					.then(response => {
						return response.json();
					})
					.then(json => {
						if (json["status"] === "Found") {
							pronounce(word);
						}
					})
					.catch(error => {
						log(error);
					})
				}
            }
		})
		.catch(error => {
			log(error);
		})		
	}
}

function nDefs() {
	if (DEBUG) log("nDefs(def)")
	let n = 0;	
	let regex = /^\d+/;
	let tmpArr = CUR_DEF.split("<br>");
	
	for (let i =0; i < tmpArr.length; i++) {		
		if (regex.test(tmpArr[i])) n++;
	}
	if (n === 0) n = 1;
	return n;
}

// Pick out a single definition based on index
function getDefInd(ind) {		
	if (CLASS === "fraser") return CUR_DEF;
	if (DEBUG) log("getDefInd(ind), ind = " + ind)	
	let out = "";
	regex = /^\d+/;
	let tmpArr = CUR_DEF.split("<br>");
	let n = 0;
	del = "";	
	for (let i = 0; i < tmpArr.length; i++) {
		if (regex.test(tmpArr[i])) n++
		if (n > ind) break;
		if (n === ind || N_DEFS === 1) {
			out += del + tmpArr[i];
			del = "<br>";
		}
	}		
	
	return out;
}

function isNumeric(value) {
    return /^-?\d+$/.test(value);
}

function walkListing() {
	if (DEBUG) log("walkListing()");
	fetch('backend/getListing.php', {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();	
	})
	.then(json => {
		let arr = json;
		let last_inc
		for (let i = 0; i < arr.length - 1; i++) {
		
			let word = arr[i];
			if (word.length > 0) {
				let inc = i * 6000;			
				setTimeout(fillInput,inc,word);						
				//setTimeout(rand,inc);
			}
		}
		setTimeout(fillInput, arr.length * 6000, "DONE");
	})
	.catch(error => {
		log(error);
	})
}

function fillInput(text) {	
	if (DEBUG) log("fillInput(text), text = " + text)
	$('#iInput').val(text);
}

function rand() {
	$('#iInput').val(Math.random());
}

function toggleSounds() {
	SOUNDS = !SOUNDS
	if (SOUNDS) {
		$('#iToggleSounds').attr("src", "img/Volume.jpg")
	} else {
		$('#iToggleSounds').attr("src", "img/Mute.png")
	}
}

function resetFilter() {
    debug("resetFilter()");
    N_REGEX = 0;
	updateScore();
	$('#iCntRegex').html("");
    IND = 0;
    getWords();
}

function debug(txt) {
    if (DEBUG) console.log(txt);
}

function toggleScores() {
	debug("toggleScores()");
    let len = $('#iSummary').text().length;
    if (len > 0) {
        $( "#dialog" ).dialog('close');
    } else {
        $( function() {
            $( "#dialog" ).dialog({title: "Summary",width: "100%", position: 'top', maxheight: '1200pt'});
        } );
        $('#dialog').on("dialogclose", clearSummary);
        getSummary();
    }
}

function log(txt) {
    console.log(txt);
}

function fromEnglish() {
	let src = $('#iInput').val();	
	if (src.length > 0) {
		let url = "https://translate.google.com/?sl=en&tl=sv&text=<src>&op=translate"
		url = url.replace("<src>", src);
		window.open(url);
	}
}

function frasMatchFuzzy(key) {
	debug("frasMatchFuzzy(" + key + ")");	
	let res = false;
	fetch('backend/fuzzyFrasMatch.php?key=' + key, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		if (json["match"].length > 0) {
			setClass("fraser");
			seekWordSingleClass(json["match"]);
		
		} else {
			
		}
	})
	.catch(error => {
		log(error);
	})	
}
</script>
</html>

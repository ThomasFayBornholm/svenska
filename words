<!DOCTYPE html>
<head>
	<link rel="stylesheet" href="svenska.css">
	<script src="jquery-3.4.1.min.js"></script>
	<meta char="UTF-8" name="viewport" content="width=device-width, initial-scale=1">
</head>
<body onload="startup()">
<!--progress bar-->
<div onwheel="scrollView(event)">
<button id="iShowToggle" onclick="showToggle()">HIDE</button>
<span class="progressContainer">
	<span class="progress" id="iProg"></span>
</span>
<span class="progressContainer" onclick="lookupAll()">
	<span class="progress" id="iDefProg"></span>
</span>
<span id="iCnt">test</span>
<span id="iCntTotal">Total</span>
<div>
<div class="dropdown">
	<img id="iSelect" class="dropdown b2" src="img/Dalarna.jpg">
	<div class="dropdown-content">
		<p onclick="setClass('adjektiv')">Adjektiv</p>
		<p onclick="setClass('verb')">Verb</p>
		<p onclick="setClass('adverb')">Adverb</p>
		<p onclick="setClass('substantiv_en')">En</p>
		<p onclick="setClass('substantiv_ett')">Ett</p>
		<p onclick="setClass('test')">Test</p>
	</div>
</div>
<img class="b2" src="img/add.svg" id="iAdd" onclick="addWord()">
</div>
<form onsubmit="seekWordWrapper(event)">
	<input id="iSeek">
</form>
</div>
<div class="row columns_4">
	<div id="iWordBox" class="wordBox column" onwheel="scrollWords(event)">
		<p id="iWords" class="fmtWords">Test<br>Words</p>
	</div>
	<div class="column" onwheel="scrollView(event)">
		<div id="iDefDiv">
			 <textarea class="defBox" id="iDefText"></textarea>
			 <button onclick="putDef('')">Put</button>
			 <button onclick="cleanUp()">Clean up</button>
		</div>
		<p class="pDef" id="iParDef" onclick="clearDef()" oncontextmenu="editDef(event)"></p>
	</div>
	<div class="column" onwheel="scrollView(event)">
	</div>
</div>

<div id="iOutsideBottom" class="outside" onwheel="scrollView(event)" style="height: 1200px">
	<p></p>
</div>
</body>
<script>

let INC = 0;
let N_INC= 8;
let SCROLL_INC=0
let N_FOUND=0;

let N_TOT=0;
let N_ADJ=0;
let N_VERB=0;
let N_ADVERB=0;
let N_EN=0;
let N_ETT=0;
let N_TEST=0;
let N_CUR=0;
let N_DEFS = 0;

let LAST_WORD="";
let CLASS = "verb";
var LAST_OBJ;
let DEBUG=false;
let LAST_DEF = "";
function startup() {
	wordCount();
	getWords();
}

function setN_CUR() {
	if (CLASS === "test") {
		N_CUR = N_TEST;
	} else if (CLASS === "adjektiv") {
		N_CUR = N_ADJ;
	} else if (CLASS === "verb") {
		N_CUR = N_VERB;
	} else if (CLASS === "adverb") {
		N_CUR = N_ADVERB;
	} else if (CLASS === "substantiv_en") {
		N_CUR = N_EN;
	} else if (CLASS === "substantiv_ett") {
		N_CUR = N_ETT;
	}
	$('#iCnt').text(N_CUR);
	$('#iCntTotal').text('[' + N_TOT + ']');
	if (DEBUG) console.log("setN_CUR(); N_CUR = " + N_CUR);
}
function getProgress() {
	var proj;
	if (N_CUR != 0) {
		prog = parseInt(INC/N_CUR *100);
	} else {
		prog = 0;
	}
	$('#iProg').css("width", prog + "%");	
	if (DEBUG) console.log("getProgress(); prog = " + prog); 
}
function fmtDef(def) {
	for (i = 0; i < 24; i++) {
		let old = " " + i + " ";
		let rep = "<br>" + i + " ";
		def = def.replace(old,rep)
	}
	return def;
}
function putDef(def) {
	if (def.length === 0) {
		def = $('#iDefText').val();
	}
	if (DEBUG) console.log("START putDef(def); def = " + def + "; SCROLL_INC = " + SCROLL_INC);
	def = preProc(def);
	fetch('backend/putDef.php?class=' + CLASS + '&word=' + LAST_WORD + '&def=' + def, {
		method: 'get',
		mode:	'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		$('#iDefText').val("");
		$('#iDefDiv').css("display", "none");
		// Reset highlighting of missing definition
		LAST_OBJ.innerHTML = LAST_OBJ.innerText;
		scrollDown();
		updateDef();
		// Race condition here between file write and def display	
		if (SCROLL_INC === (N_FOUND - 1)) {
			lookupWord(LAST_OBJ,true,true);
		}
	})
}
function changeInc(delta) {
	if (INC + delta > N_CUR) {
		INC = INC;
	} else {
		INC += delta
	}
	if (INC < 0) {
		INC = 0;
	}
	if (DEBUG) console.log("changeInc(" + delta + ") -> INC: " + INC);
}
function nextID(id) {
	let num = id.replace("w","");
	if (++num < N_FOUND) {
		return "w" + num;
	} else {
		return id;
	}
}
function advance() {
	changeInc(N_INC)
	getWords()
}
function retreat(e) {
	e.preventDefault()
	changeInc(-N_INC)
	getWords()
}
function getWords() {
	SCROLL_INC=-1;
	N_FOUND=0;
	$('#iParDef').text("");
	fetch("backend/getWords.php?class=" + CLASS + "&start=" + INC + "&num=" + N_INC, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json',
		}
	})
	.then(response => {
		return response.json()
	})
	.then(json => {
		let lastJson = json;
		let out = ""
		N_FOUND=json.length;
		if (N_FOUND > 0) {
			let list = json[0];
			for (i = 1; i < N_FOUND; i++) {
				list += "," + json[i];	
			}
			fetch('backend/existsDef.php?class=' + CLASS + "&words=" + list, {
				method: 'get',
				mode: 'cors',
				headers: {
					'Content-Type': 'application/json'
				}
			})
			.then(response => {
				return response.json();
			})
			.then(json => {
				res = json;
				console.log("res = " + res);
				for (let i = 0; i < N_FOUND; i++) {
					let del = "<br>"
					if (i === 0) { 
						del = ""
					}
					let tmp = 1 << i;
					let hasDef = (res & tmp);
					out += del + popSpan(i, lastJson[i],hasDef) 
				}
				$('#iWords').html(out);
				getProgress();
				countDefs();
				if (DEBUG) console.log("getWords(); N_FOUND = " + N_FOUND);
			})
			.catch(error => {
				console.log(error);
			})
		}
	})
}

function existsDef(wordList) {
	let res = 0;

	
}

function scrollView(e) {
	e.preventDefault();
	$('#iWords').css("visibility", "visible");
	if (e.deltaY > 0) {
		changeInc(N_INC);
	} else {
		changeInc(-N_INC);
	}
	getWords();
}

function scrollWords(e) {
	e.preventDefault();
	if (event.deltaY > 0) {
		scrollDown();
	} else {
		scrollUp();
	}
	// Show local definition if available
	updateDef();
	if (DEBUG) console.log("scrollWords() -> SCROLL_INC = " + SCROLL_INC);
}

function scrollDown() {
	if (SCROLL_INC < N_FOUND-1) {
		SCROLL_INC++;
	}
	if (DEBUG) console.log("scrollDown(); SCROLL_INC = " + SCROLL_INC);
}
function scrollUp() {
	if (SCROLL_INC > 0) {
		SCROLL_INC--;
	} else if (SCROLL_INC == -1) {
		SCROLL_INC = N_FOUND - 1;
	}
	if (DEBUG) console.log("scrollUp(); SCROLL_INC = " + SCROLL_INC);
}
function updateDef() {
	if (DEBUG) console.log("updateDef()");
	let id = "w" + SCROLL_INC;
	let el = document.getElementById(id);
	lookupWord(el,true,true);
}
function popSpan(i, w, hasDef) {
	tmp = "<span id='w<i>' onclick='lookupWord(this,false,false)' oncontextmenu='onlineLookup(this,event)'><w></span>"
	if (DEBUG) console.log("popSpan(i=" + i + ",w=" + w + ",hasDef=" + hasDef + ")");
	tmp = tmp.replace("<i>",i)
	if (hasDef) {
		tmp = tmp.replaceAll("<w>",w);
	} else { 
		tmp = tmp.replaceAll("<w>","<i>" + w + "</i>");
	}
	return tmp
}

function lookupWord(el,onlyLocal,inline) {
	if (LAST_OBJ) {
		LAST_OBJ.style.fontWeight="";
	}
	el.style.fontWeight="bold";
	let word = el.innerText;
	LAST_WORD=word;
	LAST_OBJ = el;
	scroll_inc = el.id.replace("w","");
	if (scroll_inc > -1 && scroll_inc < N_INC) {
		SCROLL_INC = scroll_inc; 
	}
	fetch('backend/getDef.php?class=' + CLASS + '&word='+ word, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json()
	})
	.then(json => {
		def = json;
		LAST_DEF = json;
		// Prefer local definition over 3rd party dictionary
		if (def != "No definition found" && def != "Could not read json") {
			if (json.includes("till '")) {
				getCompDef(def);
				return;
			}
			$('#iParDef').html("<b>" + word + ":</b><br>" + def);
			$('#iDefDiv').css("display", "none");
			if (!inline) {
				$('#iWords').css("visibility", "hidden");
			}
		} else {
			if (!onlyLocal) {
				let url = "https://svenska.se/tre?sok=" + word + "&pz=1";
				window.open(url, '_blank');
			}
			$('#iParDef').html("");
			$('#iDefDiv').css("display", "block");
			$('#iDefText').focus();
		}
	})
	.catch(error => {
		console.log(error)
	})
	if (DEBUG) console.log("lookupWord(" +  word + ")");
}
function getCompDef(def) {
	if (DEBUG) console.log("getCompDef(def); def = " + def);
	// Compose and output string that combines definition of multiple (usually two)
	// component words
	words = getRefs(def);
	let complete = false;
	let res = "";
	let out = [];
	let done = 0;
	for (let i = 0; i < words.length; i++) {
		let w = words[i];
		// Dispatch n fetches to get definitions
		// add an identifier to each result to enable correct ordering 
		fetch('backend/getDef.php?class=' + guessClass(w) + '&word='+ removeClassDesc(w), {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json();
		})
		.then(json => {
			out[done] = w + ":<br>" + json;
			done++;
			if (done >= words.length) {
				// Perform any required ordering
				let txt = def + "<br>";
				console.log(txt);
				let del = "";
				console.log(out);
				for (let i = 0; i < done; i++) {
					if (i != 0) del = "<br>"
					txt = txt + del + out[i];
				}
				console.log(txt);	
				$('#iParDef').html(txt);
			}
		})
		.catch(error => {
			console.log(error);
		})
	}
}
function getRefs(def) {
	if (!def.includes("till ") || !def.includes("'")) {
		return "";
	}
	def = def.replaceAll("till ", "");
	def = def.replaceAll("'","");
	arr = def.split(",");
	return arr;
	if (DEBUG) console.log("getRef()");
}

function onlineLookup(el, e) {
	e.preventDefault()
	word = el.innerText;
	let url = "https://svenska.se/tre?sok=" + word + "&pz=1";
	window.open(url, '_blank');
}

function wordCount() {
	fetch('backend/wordCount.php', {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		},
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		N_TOT = json["total"];
		N_ADJ = json["adj"];
		N_VERB = json["verb"];
		N_ADVERB = json["adverb"];
		N_EN = json["substantiv_en"];
		N_ETT = json["substantiv_ett"];
		N_TEST= json["test"];
		setN_CUR();
		getProgress();
	})
	.catch(error => {
		console.log(error);
	})
}

function showToggle() {
	let hide= $('#iShowToggle').text() === "HIDE";
	if (hide) {
		// Hide controls 
		$('#iSeek').css("visibility", "hidden");
		$('#iSelect').css("visibility", "hidden");
		$('#iAdd').css("visibility", "hidden");
		$('#iShowToggle').text("__");
	} else {
		// Make visible class selector and word seeker controls
		$('#iSeek').css("visibility", "visible");
		$('#iSelect').css("visibility", "visible");
		$('#iAdd').css("visibility", "visible");
		$('#iShowToggle').text("HIDE");
		$('#iSeek').focus();
	}
	if (DEBUG) console.log("showToggle(); seek.v = " + $('#iSeek').css("visibility") + ", sel.v = " + $('#iSelect').css("visibility"));
}
function seekWordWrapper(e) {
	e.preventDefault();
	seekWord();
}
function seekWord() {
	let word = $('#iSeek').val();
	if (word.length > 0) {
		fetch('backend/seekWord.php?class=' + CLASS + "&word=" + word, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json();
		})
		.then(json => {
			INC = json;			
			getWords();
		})
		.catch(error => {
			console.log(error);
		})
	}
	if (DEBUG) console.log("seekWord(); word = " + word + " -> INC = " + INC);
}
function setClass(c) {
	CLASS = c;
	INC = 0;
	SCROLL_INC=-1;
	countDefs();
	setN_CUR();
	getProgress();
	countDefs();
	getWords();
	if (DEBUG) console.log("setClass(c); CLASS = " + CLASS + ", INC = " + INC + ", SCROLL_INC = " + SCROLL_INC + ", N_CUR = " + N_CUR);
}
function countDefs() {
	N_DEFS = 0;
	fetch('backend/countDef.php?class=' + CLASS, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		if (json != "Failed to read definition file.") {	
			N_DEFS=json;
			if (DEBUG) console.log("countDefs(); N_DEFS = " + N_DEFS);
			$('#iDefProg').css("width", N_DEFS/N_CUR * 100 + "%");
		} else {
			if (DEBUG) console.log("countDefs(); N_DEFS = " + N_DEFS);
		}
	})
}
function lookupAll() {
	let url_base="https://svenska.se/tre?sok="
	let word = $('#w0').text();	
	let w = window.open(url_base + word + "&pz=1");
	w.focus();
	for (let i = 1; i < N_FOUND; i++) {
		let id = "w" + i;
		let id2 = "#" + id;
		let word = $(id2).text();
		let url = url_base + word + "&pz=1";
		window.open(url,id);
	}
	$('#iDefText').focus();
	w.focus();
	if (DEBUG) console.log("lookupAll(); N_FOUND = " + N_FOUND);
}
function editDef(e) {
	e.preventDefault();
	$('#iDefDiv').css("display", "block");
	$('#iDefText').focus();
}
function clearDef() {
	if (DEBUG) console.log("clearDef()");
	$('#iParDef').html("");
	$('#iWords').css("visibility", "visible");
	$('#iDefDiv').css("display", "none");
}
function pretty(def) {
	if (DEBUG) console.log("pretty(def); def = " + def);
	let out = "";
	subdefs = def.split("<br>");
	for (let i = 0; i < subdefs.length; i++) {
		del = "<br>";
		if (i === 0) del="";
		s = subdefs[i];		
		pJFR = s.indexOf("JFR");
		pSE = s.indexOf("SE");
		pMOTS = s.indexOf("MOTSATS");
		pSYN = s.indexOf("SYN");
		let tot = pJFR + pSE + pMOTS + pSYN;
		if (tot === -4) {
			out = out + del + s;
		} else {
			// New line before the JFR, SE, MOTS indicators for styling
			if (pJFR === -1) pJFR = 999999;
			if (pSE === -1) pSE = 999999;
			if (pMOTS === -1) pMOTS = 999999;
			if (pSYN === -1) pSYN = 999999;
			let start = pSE;
			if (pJFR < start) start = pJFR;
			if (pMOTS < start) start = pMOTS;
			if (pSYN < start) start = pSYN;
			let def2 =  s.slice(start,s.length);
			s = s.slice(0,start) + "<br>"
			def2 = def2.replaceAll("1","").replaceAll("2","").replaceAll("3","").replaceAll("4","");
			def2 = def2.replaceAll(" ,",",").replaceAll("  ", " ");
			def2 = def2.replaceAll(" 1<br>","<br>");
			out = out + del + s + def2;
		}
	}
	out = out.replaceAll("<br><br>","<br>");
	for (let i = 1; i < 24; i++) {
		out = out.replaceAll(i + " " + i, i);
		out = out.replaceAll("<br>" + i + "<br>","<br>" );
		out = out.replaceAll("<br> " + i + "<br>","<br>" );
		out = out.replaceAll("<br>" + i + " <br>","<br>" );
	}
	// Strip any leading new line
	if (out.slice(0,3) === "<br>") {
		out = out.slice(4,out.length) 
	}
	const regex1 = /[a-z][1-9]/;
	match = out.match(regex1);
	if (match != null) {
		console.log(match);
		strMatch = match[0];
		rep = strMatch[0] + "<br> " + strMatch[1];
		out = out.replace(strMatch, rep);
	}
	if (out[0] === " ") out = out.slice(1,out.length);
	out = out.replace("partikelntill", "partikeln till;");
	if (out[out.length-1] === ",") out = out.slice(0,out.length-1)
	return out;
}
function fullClassName(name) {
	if (name === "en") return "substantiv_en"
	if (name === "ett") return "substantiv_ett"
	return name
}
function guessClass(word) {
	// Prefer explicit definition of class
	if (word.includes('(') && word.includes(')')) {
		// grab class	
		let start = word.indexOf('(')
		let end = word.indexOf(')')	
		if (start > end || start === -1) return 
		let c = word.slice(start+1,end);
		c = fullClassName(c);
		return c;
	} 
	// Otherwise try and semi-intelligently guess word class
	if (word.endsWith('a')) return "verb"
	if (word.includes(' ')) return "verb"
	if (word.endsWith("ig")) return "adjektiv"
	fetch('backend/existsWord.php?class=substantiv_ett&word=' + word, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
	})
	.then(json => {
	})
	.catch(error => {
		console.log(error);
	})
	return "substantiv_en"
}
function removeClassDesc(word) {
	let start = word.indexOf('(');
	let end = word.indexOf(')');
	if (start > end || start === -1) return word 
	console.log(word.slice(0,start-1))
	return word.slice(0,start-1)	
			
}
function addWord() {
	if (DEBUG) console.log("addWord()");
	let word = $('#iSeek').val();	
	let del = word[0] === '.';
	if (del) word = word.slice(1,word.length);
	if (word.length > 0) {
		fetch ('backend/existsWord.php?class=' + CLASS + '&word=' + word, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})	
		.then(response => {
			return response.json();
		})
		.then(json => {
			if (json !== -1 || (del && json === -1)) {	
				let op = "add"	
				if (del) op = "remove"
				fetch('backend/' + op + 'Word.php?class=' + CLASS + "&word=" + word, {
					method: 'get',
					mode: 'cors',
					headers: {
						'Content-Type': 'application/json'
					}
				})
				.then(response => {
					wordCount();
				})
				.catch(error => {
					console.log(error);	
				})

			}
		})
		.catch(error => {
			console.log(error);
		})
	}
}
function preProc(def) {
	if (DEBUG) console.log("preProc(def(); def = " + def)
	// Split definition
	arr = def.split("\n");
	let s = "";
	let outDef = "";
	// Support for partikel parters
	// Can be between 1 and 3 suggested partner words
	let regex1 = /skilt[a-zäöå]+/;
	let regex1_alt = /partikeln[a-zäöå]+/;
	let regex2 = /skilt[a-zäöå]+, [a-zäöå]+/;
	let regex3 = /skilt[a-zäöå]+, [a-zäöå]+, [a-zäöå]+/;
	for (let i = 0; i < arr.length; i++) {
		s = arr[i];
		if (s.length > 1) {
			// Remove any leading space
			if (s[0] === " ") s = s.slice(1,s.length)
			let del = "<br>";
			if (i === 0) del = ""
			// Remove any reference numbers other than that at line start
			let trail = s.slice(2,s.length);
			for (let i = 1; i < 24; i++) {
				trail = trail.replaceAll(" " + i + " "," ");
				trail = trail.replaceAll(i,"");
			}
			s = s.slice(0,2) + trail;
			s = s.replaceAll("  ", "");
			s = s.replaceAll(" , ", ", ");
			s = s.replaceAll("ibland med partikel","(ibland med partikel");
			s = s.replaceAll("vanligen med partikel","(ibland med partikel");
			s = s.replaceAll("ofta med partikel","(ofta med partikel");

			s = s.replaceAll("vanligen i sammansätt.",")vanligen i sammansättn.)");
			s = s.replaceAll("vanligen i vissa sammansätt.",")vanligen i vissa sammansättn.)");
			let m = s.match(regex1);
			let m_alt = s.match(regex1_alt);
			let m2 = s.match(regex2);
			let m3 = s.match(regex3);
			let rep = ""
			if (m3 != null) {
				let strMatch = m3[0];
				let rep = strMatch.slice(0,5) + " " + strMatch.slice(5,strMatch.length) + ")";
				s = s.replace(strMatch, rep);
			} else if (m2 != null) {
				let strMatch = m2[0];
				rep = strMatch.slice(0,5) + " " + strMatch.slice(5,strMatch.length) + ")";
				s = s.replace(strMatch, rep);
			} else if (m != null) {
				let strMatch = m[0];
				let rep = strMatch.slice(0,5) + " " + strMatch.slice(5,strMatch.length) + ")";
				s = s.replace(strMatch, rep);
			} else if (m_alt != null) {
				let strMatch = m_alt[0];
				let rep = strMatch.slice(0,9) + " " + strMatch.slice(9,strMatch.length) + ")";
				s = s.replace(strMatch, rep);
			}
			let f1 = "utan) större betydelse­skillnad";
			let f2 = "), utan större betydelse­förändring";
			let f3 = "), utan större betydelse­skillnad";
			let f4 = "utan) större betydelse­förändring";
			s = s.replace(f1, f1.replace(")","") + ")");
			s = s.replace(f2,f2.replace(")","") + ")");
			s = s.replace(f3,f3.replace(")","") + ")");
			s = s.replace(f4,f4.replace(")","") + ")");
			if (s.includes("((")) s = s.replace("((", "(");
			outDef = outDef + del + s;
		}
	}
	// That's it!
	return outDef;
}
function cleanUp() {
	if (DEBUG) console.log("cleanUp(); LAST_DEF = " + LAST_DEF);
	let def = LAST_DEF
	if (def.slice(0,4) === "<br>") def = def.substr(4)
	def = def.replaceAll("<br>","\n");
	def = def.replaceAll(" JFR","\nJFR");
	def = def.replaceAll(" SE","\nSE");
	def = def.replaceAll(" SYN","\nSYN");
	def = def.replaceAll(" MOTSATS","\nMOTSATS");
	putDef(def);
}
</script>
</html>

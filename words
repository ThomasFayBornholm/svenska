<!DOCTYPE html>
<head>
	<link rel="stylesheet" href="svenska.css">
	<script src="jquery-3.4.1.min.js"></script>
	<meta char="UTF-8" name="viewport" content="width=device-width, initial-scale=1">
</head>
<body onload="startup()">
<div class="row columns_4">
<!--progress bar-->
	<div title="Scroll to navigate individual words&#10;Left click word = get definition&#10;Right click word = lookup@svensk.se " id="iWordBox" class="wordBox column" onwheel="scrollWords(event)">
		<span title="Toggle control view" class="progressContainer" onclick="showToggle()" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">
			<span class="progress progressBar" id="iProg"></span>
		</span>
		<span id="iDefProgContainer" class="progressContainer">
			<span class="progress progressBar hidden" id="iDefProg"></span>
		</span>
		<div id="iControls">
			<div class="dropdown">
				<img title="Class selector. Right click to go to debug mode" id="iSelect" class="dropdown b2" src="img/Dalarna.jpg" onclick="setClass('all')" oncontextmenu="toggleDebugEv(event)" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">				
				<div class="dropdown-content">
					<p onclick="setClass('substantiv_en')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">En</p>
					<p onclick="setClass('verb')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Verb</p>
					<p onclick="setClass('adjektiv')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Adjektiv</p>
					<p onclick="setClass('substantiv_ett')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Ett</p>
					<p onclick="setClass('adverb')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Adverb</p>
				</div>
			</div>
			<div class="dropdown">
				<img title="Class selector #2 (rarer classes)" id="iSelectRare" class="dropdown b2" src="img/Oresundsbron.jpg" onclick="setClass('all')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">
				<div class="dropdown-content">
					<p onclick="setClass('preposition')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Preposition</p>
					<p onclick="setClass('interjektion')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Interjektion</p>					
					<p onclick="setClass('pronomen')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Pronomen</p>
					<p onclick="setClass('förled')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Förled</p>
				</div>
			</div>		
			<p class="debug" id="iDebugTxt"></p>
			<form onsubmit="seekWordWrapper(event)">
				<input title="Search for word in current class" id="iSeek" oncontextmenu="onlineLookup(this,event)" class="inputSearch">		
				<img title="Left click: add word to store*&#10;Right click: guess class&#10;*(prefix with '.' to delete" class="b2" src="img/add.svg" id="iAdd" onclick="addWord()" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)" oncontextmenu="setClassGuessWrapper(event)">
				<img title="Back to last view" class="b2" src="img/leftArrow.png" id="iLast" onclick="seekWord('')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">
			</form>				
		</div>
		<p id="iWords" class="fmtWords">Test<br>Words</p>
	</div>
	<div title="Mouse wheel/ or click left/right to navigate&#10;Right click definition to edit.&#10;Double left click definition to hide def&#10;Words referenced as SE, JFR, MOTSATS etc can be clicked for instant navigation&#10;Word classes in italics can also be clicked to change class selection directly"class="column" onwheel="scrollView(event)">
		<span class="counts" id="iCnt">test</span>
		<span class="counts" id="iCntTotal">Total</span>
		<div  id="iDefDiv">
			 <textarea  class="defBox" id="iDefText"></textarea>
			 <button onclick="putDef('')">Put</button>
			 <button onclick="cleanUp()">Clean up</button>
		</div>
		<p class="pDef" id="iParDef" ondblclick="clearDef()" oncontextmenu="editDef(event)"></p>
		<div id="iNavDiv" onclick="scrollViewDown()" oncontextmenu="scrollViewUp(event)"></div>
	</div>	
	<div title="Navigation: left/scroll down = forward, right click/scroll up = back" class="column" onwheel="scrollView(event)" onclick="scrollViewDown()" oncontextmenu="scrollViewUp(event)"></div>	
</div>
</body>
<script>

let INC = 0;
let N_INC= 8;
let SCROLL_INC=0
let N_FOUND=0;

let N_TOT=0;
let N_ADJ=0;
let N_VERB=0;
let N_ADVERB=0;
let N_EN=0;
let N_ETT=0;
let N_TEST=0;
let N_PREPOSITION = 0;
let N_INTERJEKTION = 0;
let N_PRONOMEN = 0;
let N_PREFIX = 0;
let N_CUR=0;
let N_DEFS = 0;

let LAST_WORD="";
let CUR_WORD="";
let CLASS = "all";
var LAST_OBJ;
let DEBUG=false;
let LAST_DEF = "";
let LAST_CLASS = "all";
let CONTROLS_VISIBLE=true;
function startup() {
	wordCount();
	getWords(-1);
}

function setN_CUR() {
	if (CLASS === "test") {
		N_CUR = N_TEST;
	} else if (CLASS === "adjektiv") {
		N_CUR = N_ADJ;
	} else if (CLASS === "verb") {
		N_CUR = N_VERB;
	} else if (CLASS === "adverb") {
		N_CUR = N_ADVERB;
	} else if (CLASS === "substantiv_en") {
		N_CUR = N_EN;
	} else if (CLASS === "substantiv_ett") {
		N_CUR = N_ETT;
	} else if (CLASS === "preposition") {
		N_CUR = N_PREPOSITION;
	} else if (CLASS === "interjektion") {
		N_CUR = N_INTERJEKTION;
	} else if (CLASS === "pronomen") {
		N_CUR = N_PRONOMEN;
	} else if (CLASS === "förled") {
		N_CUR = N_PREFIX;
	} else if (CLASS === "all") {
		N_CUR = N_TOT;
	}
	$('#iCnt').text(N_CUR);
	$('#iCntTotal').text(' [' + N_TOT + ']');
	if (DEBUG) console.log("setN_CUR(); N_CUR = " + N_CUR);
}
function getProgress() {
	var proj;
	if (N_CUR != 0) {
		prog = parseInt(INC/N_CUR *100);
	} else {
		prog = 0;
	}
	$('#iProg').css("width", prog + "%");	
	if (DEBUG) console.log("getProgress(); prog = " + prog); 
}
function fmtDef(def) {
	for (i = 0; i < 24; i++) {
		let old = " " + i + " ";
		let rep = "<br>" + i + " ";
		def = def.replace(old,rep)
	}
	return def;
}
function putDef(def) {
	if (def.length === 0) {
		def = $('#iDefText').val();
	}
	if (DEBUG) console.log("START putDef(def); def = " + def + "; SCROLL_INC = " + SCROLL_INC);
	def = preProc(def);
	console.log(def);
	fetch('backend/putDef.php?class=' + CLASS + '&word=' + CUR_WORD + '&def=' + def, {
		method: 'get',
		mode:	'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		$('#iDefText').val("");
		$('#iDefDiv').css("display", "none");
		// Reset highlighting of missing definition
		LAST_OBJ.innerHTML = LAST_OBJ.innerText;
		scrollDown();
		updateDef();
		// Race condition here between file write and def display	
		if (SCROLL_INC === (N_FOUND - 1)) {
			lookupWord(LAST_OBJ,true,true);
		}
	})
}
function changeInc(delta) {
	if (INC + delta > N_CUR) {
		INC = INC;
	} else {
		INC += delta
	}
	if (INC < 0) {
		INC = 0;
	}
	if (DEBUG) console.log("changeInc(" + delta + ") -> INC: " + INC);
}
function nextID(id) {
	let num = id.replace("w","");
	if (++num < N_FOUND) {
		return "w" + num;
	} else {
		return id;
	}
}
function advance() {
	changeInc(N_INC)
	getWords(-1)
}
function retreat(e) {
	e.preventDefault()
	changeInc(-N_INC)
	getWords(-1)
}
function getWords(ind) {
	SCROLL_INC=-1;
	N_FOUND=0;
	$('#iParDef').text("");
	fetch("backend/getWords.php?class=" + CLASS + "&start=" + INC + "&num=" + N_INC, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json',
		}
	})
	.then(response => {
		return response.json()
	})
	.then(json => {
		let lastJson = json;
		let out = ""
		N_FOUND=json.length;
		if (N_FOUND > 0) {
			let list = json[0];
			for (i = 1; i < N_FOUND; i++) {
				list += "," + json[i];	
			}
			fetch('backend/existsDef.php?class=' + CLASS + "&words=" + list, {
				method: 'get',
				mode: 'cors',
				headers: {
					'Content-Type': 'application/json'
				}
			})
			.then(response => {
				return response.json();
			})
			.then(json => {
				res = json;
				for (let i = 0; i < N_FOUND; i++) {
					let del = "<br>"
					if (i === 0) { 
						del = ""
					}
					let tmp = 1 << i;
					let hasDef = (res & tmp);
					out += del + popSpan(i, lastJson[i],hasDef) 
				}
				$('#iWords').html(out);
				showWords();
				getProgress();
				countDefs();
				if (ind > -1) {
					let el = document.getElementById("w" + ind);
					lookupWord(el,false,true);
				}
				if (DEBUG) console.log("getWords(ind); ind = " + ind + ", N_FOUND = " + N_FOUND);
			})
			.catch(error => {
				console.log(error);
			})
		}
	})
}

function scrollViewDown() {
	if (DEBUG) console.log("scrollViewDown() begin");
	changeInc(N_INC);
	$('iDefDiv').css("display", "none");
	getWords(-1);
	showWords();
}
function scrollViewUp(e) {
	e.preventDefault();
	if (DEBUG) console.log("scrollViewUp() begin");
	changeInc(-N_INC);
	getWords(-1);
	showWords();
}
function scrollView(e) {
	if (DEBUG) console.log("scrollView() begin");
	e.preventDefault();
	showWords();
	if (e.deltaY > 0) {
		scrollViewDown();
	} else {
		scrollViewUp(e);
	}
	if (DEBUG) console.log("scrollView(); INC = " + INC)
}

function scrollWords(e) {
	e.preventDefault();
	if (event.deltaY > 0) {
		scrollDown();
	} else {
		scrollUp();
	}
	// Show local definition if available
	updateDef();
	if (DEBUG) console.log("scrollWords() -> SCROLL_INC = " + SCROLL_INC);
}

function scrollDown() {
	if (SCROLL_INC < N_FOUND-1) {
		SCROLL_INC++;
	}
	if (DEBUG) console.log("scrollDown(); SCROLL_INC = " + SCROLL_INC);
}
function scrollUp() {
	if (SCROLL_INC > 0) {
		SCROLL_INC--;
	} else if (SCROLL_INC == -1) {
		SCROLL_INC = N_FOUND - 1;
	}
	if (DEBUG) console.log("scrollUp(); SCROLL_INC = " + SCROLL_INC);
}
function updateDef() {
	if (DEBUG) console.log("updateDef()");
	let id = "w" + SCROLL_INC;
	let el = document.getElementById(id);
	lookupWord(el,true,true);
}
function popSpan(i, w, hasDef) {
	tmp = "<span id='w<i>' onclick='lookupWord(this,false,false)' oncontextmenu='onlineLookup(this,event)'><w></span>"
	if (DEBUG) console.log("popSpan(i=" + i + ",w=" + w + ",hasDef=" + hasDef + ")");
	tmp = tmp.replace("<i>",i)
	if (hasDef || CLASS === "all") {
		tmp = tmp.replaceAll("<w>",w);
	} else { 
		tmp = tmp.replaceAll("<w>","<i>" + w + "</i>");
	}
	return tmp
}

function lookupWord(el,onlyLocal,inline) {
	if (LAST_OBJ) {
		LAST_OBJ.style.fontWeight="";
	}
	el.style.fontWeight="bold";
	let word = el.innerText;
	CUR_WORD=word;
	LAST_OBJ = el;
	if (DEBUG) console.log("lookupWord(), CUR_WORD = " + CUR_WORD);
	scroll_inc = el.id.replace("w","");
	if (scroll_inc > -1 && scroll_inc < N_INC) {
		SCROLL_INC = scroll_inc; 
	}
	if (CLASS === "all") {
		fetch('backend/getDefAll.php?word=' + word, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json();
		})
		.then(json => {
			let keys = Object.keys(json);						
			let def = "";
			let delim ="";
			let tmp = "<span onclick=\"setClass(\'_k_\',\'_w_\')\"><i>_k_:</i><br></span>";
			for (let i = 0; i < keys.length; i++) {			
				def += delim + tmp.replaceAll("_k_", keys[i]).replace("_w_",word) + makeLinks(json[keys[i]]);
				delim="<br>";
			}
			LAST_DEF = def;
			$('#iParDef').html("<b>" + word + ":</b><br>" + def);
			return;
		})
		.catch(error => {
			console.log(error);
		})
	} else {
		fetch('backend/getDef.php?class=' + CLASS + '&word='+ word, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json()
		})
		.then(json => {
			console.log(json);
			def = json;
			LAST_DEF = json;
			// Prefer local definition over 3rd party dictionary
			if (def != "No definition found" && def != "Could not read json") {
				if (json.includes("till '")) {
					getCompDef(def);
					return;
				}
				def = makeLinks(def);
				console.log(def);
				$('#iParDef').html("<b>" + word + ":</b><br>" + def);
				$('#iDefDiv').css("display", "none");
				if (!inline) {
					$('#iWords').css("visibility", "hidden");
				}
			} else {
				if (!onlyLocal) {
					let url = "https://svenska.se/tre?sok=" + word + "&pz=1";
					window.open(url, '_blank');
				}
				$('#iParDef').html("");
				$('#iDefDiv').css("display", "block");
				$('#iDefText').focus();
			}
		})
		.catch(error => {
			console.log(error)
		})
	}
	
	if (DEBUG) {
		if (word.length === 0) word = "__empty__";
		console.log("lookupWord(" +  word + ")");
	}
}
// Make links to referenced words
function makeLinks(def) {
	if (DEBUG) console.log("makeLinks()")
	if (def.split("<br>").length == 1) {
		return def;
	}
	def = addLinks("MOTSATS", def);
	def = addLinks("JFR", def);
	def = addLinks("SYN.", def);
	def = addLinks("SE", def);
	return def;
}
function addLinks(refClass,def) {
	if (DEBUG) console.log("addLinks(), refClass = " + refClass + ", def = " + def);
	// Easiest to handle line by line and skip the lines without links
	// Expectation is each link class (JFR, SE etc.) has its own new line.
	defArr = def.split("<br>");
	def = "";
	m = refClass + " ";
	delim = "";
	beginSpan = "<span onclick=followLink(this)";
	beginSpan += " onmouseover=highlight(this,event)";
	beginSpan += " title='Navigate to \"_w_\"'";
	beginSpan += ">"
	spanTmp = beginSpan + "_w_</span>";
	for (line of defArr) {
		
		if (line.indexOf(m) != -1) {
			elArr = line.split(", ");
			for (el of elArr) {
				if (el.includes(m)) {
					line = line.replace(el, m + spanTmp.replaceAll("_w_",el.substr(m.length, el.length - m.length)));
				} else {
					line = line.replace(el, spanTmp.replaceAll("_w_",el));
				}
			}
		}
		def += delim + line;
		delim = "<br>";
	}
	return def;
}
function followLink(el) {
	let word = el.innerText;
	if (DEBUG) console.log("followLink(" + word + ")");
	$('#iSeek').val(word);	
	setClass("all");
	seekWord(word);
}

function getCompDef(def) {
	if (DEBUG) console.log("getCompDef(def); def = " + def);
	// Compose and output string that combines definition of multiple (usually two)
	// component words
	words = getRefs(def);
	let complete = false;
	let res = "";
	let out = [];
	let done = 0;
	for (let i = 0; i < words.length; i++) {
		let w = words[i];
		// Dispatch n fetches to get definitions
		// add an identifier to each result to enable correct ordering 
		fetch('backend/getDef.php?class=' + guessClass(w) + '&word='+ removeClassDesc(w), {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json();
		})
		.then(json => {
			// def - the original reference definition
			// tmp - original ref + link to the referenced word
			// json - the referenced definition
			let tmp = "<span onclick=\"followLink(this)\"><b>_w_</b></span>:";
			tmp = tmp.replaceAll("_w_",removeClassDesc(w));
			tmp = tmp + "<br>";
			out[done] = makeLinks(tmp + json);
			done++;
			if (done >= words.length) {
				// Perform any required ordering
				let txt = def + "<br>";
				let del = "";
				for (let i = 0; i < done; i++) {
					if (i != 0) del = "<br>"
					txt = txt + del + out[i];
				}
				$('#iParDef').html(txt);
			}
		})
		.catch(error => {
			console.log(error);
		})
	}
}
function getRefs(def) {
	if (!def.includes("till ") || !def.includes("'")) {
		return "";
	}
	def = def.replaceAll("till ", "");
	def = def.replaceAll("'","");
	arr = def.split(",");
	if (DEBUG) console.log("getRef()");
	return arr;
}

function onlineLookup(el, e) {
	e.preventDefault()
	word = el.innerText;
	if (word.length === 0) word = el.value;
	let url = "https://svenska.se/tre?sok=" + word + "&pz=1";
	window.open(url, '_blank');
}

function wordCount() {
	fetch('backend/wordCount.php', {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		},
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		N_TOT = json["total"];
		N_ADJ = json["adj"];
		N_VERB = json["verb"];
		N_ADVERB = json["adverb"];
		N_EN = json["substantiv_en"];
		N_ETT = json["substantiv_ett"];
		N_TEST= json["test"];
		N_PREPOSITION = json["preposition"];
		N_INTERJEKTION = json["interjektion"];
		N_PRONOMEN = json["pronomen"];
		N_PREFIX = json["prefix"];
		setN_CUR();
		getProgress();
	})
	.catch(error => {
		console.log(error);
	})
}

function showToggle() {
	if (CONTROLS_VISIBLE) {
		// Hide controls 
		$('#iControls').css("display", "none");
		$('#iShowToggle').text("__");
		CONTROLS_VISIBLE=false;
	} else {
		// Make visible class selector and word seeker controls
		$('#iControls').css("display", "block");
		$('#iShowToggle').text("HIDE");
		$('#iSeek').focus();
		CONTROLS_VISIBLE=true;
	}
	if (DEBUG) console.log("showToggle(); seek.v = " + $('#iSeek').css("visibility") + ", sel.v = " + $('#iSelect').css("visibility"));
}
function seekWordWrapper(e) {
	e.preventDefault();
	let word = $('#iSeek').val();
	seekWord(word);
}
function seekWord(word) {
	if (word === '') {
		word = LAST_WORD;
		setClass(LAST_CLASS);
		$('#iSeek').val(word);
	}
	LAST_WORD = CUR_WORD;
	CUR_WORD = word;
	if (DEBUG) console.log("seekWord(): LAST_WORD = " + LAST_WORD + ", CUR_WORD = " + CUR_WORD);
	if (word.length > 0) {
		fetch('backend/seekWord.php?class=' + CLASS + "&word=" + word + "&inc=" + INC, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json();
		})
		.then(json => {
			if (json > -1) {
				INC = json - 3;			
				let ind = 3;
				if (INC < 0)  {
					INC = 0;
					let ind = 0;
				}
				getWords(ind);
			}
		})
		.catch(error => {
			console.log(error);
		})
	}
	if (DEBUG) console.log("seekWord(); word = " + word + " -> INC = " + INC);
}

function setClass(c, seek = "") {
	LAST_CLASS = CLASS;
	$('#iDefDiv').css("display", "none");
	$('#iWords').css("visibility", "visible");
	if (c != "all") {
		$('#iDefProgContainer').css("visibility","visible");
	} else {
		$('#iDefProgContainer').css("visibility","hidden");
	}
	CLASS = c;
	INC = 0;
	SCROLL_INC=-1;
	setN_CUR();
	getProgress();
	countDefs();
	getWords(-1);
	if (seek.length > 0) seekWord(seek);
	if (DEBUG) console.log("setClass(c, seek); CLASS = " + CLASS + ", seek = " + seek + ", INC = " + INC + ", SCROLL_INC = " + SCROLL_INC + ", N_CUR = " + N_CUR);
}
function countDefs() {
	N_DEFS = 0;
	fetch('backend/countDef.php?class=' + CLASS, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		if (json != "Failed to read definition file.") {	
			N_DEFS=json;
			if (DEBUG) console.log("countDefs(); N_DEFS = " + N_DEFS);
			$('#iDefProg').css("width", N_DEFS/N_CUR * 100 + "%");
		} else {
			if (DEBUG) console.log("countDefs(); N_DEFS = " + N_DEFS);
		}
	})
}

function editDef(e) {
	e.preventDefault();
	showWords();
	$('#iDefDiv').css("display", "block");
	$('#iDefText').focus();
}
function clearDef() {
	if (DEBUG) console.log("clearDef()");
	$('#iParDef').html("");
	$('#iWords').css("visibility", "visible");
	$('#iDefDiv').css("display", "none");
}
function pretty(def) {
	if (DEBUG) console.log("pretty(def); def = " + def);
	let out = "";
	subdefs = def.split("<br>");
	for (let i = 0; i < subdefs.length; i++) {
		del = "<br>";
		if (i === 0) del="";
		s = subdefs[i];		
		pJFR = s.indexOf("JFR");
		pSE = s.indexOf("SE");
		pMOTS = s.indexOf("MOTSATS");
		pSYN = s.indexOf("SYN");
		let tot = pJFR + pSE + pMOTS + pSYN;
		if (tot === -4) {
			out = out + del + s;
		} else {
			// New line before the JFR, SE, MOTS indicators for styling
			if (pJFR === -1) pJFR = 999999;
			if (pSE === -1) pSE = 999999;
			if (pMOTS === -1) pMOTS = 999999;
			if (pSYN === -1) pSYN = 999999;
			let start = pSE;
			if (pJFR < start) start = pJFR;
			if (pMOTS < start) start = pMOTS;
			if (pSYN < start) start = pSYN;
			let def2 =  s.slice(start,s.length);
			s = s.slice(0,start) + "<br>"
			def2 = def2.replaceAll("1","").replaceAll("2","").replaceAll("3","").replaceAll("4","");
			def2 = def2.replaceAll(" ,",",").replaceAll("  ", " ");
			def2 = def2.replaceAll(" 1<br>","<br>");
			out = out + del + s + def2;
		}
	}
	out = out.replaceAll("<br><br>","<br>");
	for (let i = 1; i < 24; i++) {
		out = out.replaceAll(i + " " + i, i);
		out = out.replaceAll("<br>" + i + "<br>","<br>" );
		out = out.replaceAll("<br> " + i + "<br>","<br>" );
		out = out.replaceAll("<br>" + i + " <br>","<br>" );
	}
	// Strip any leading new line
	if (out.slice(0,3) === "<br>") {
		out = out.slice(4,out.length) 
	}
	const regex1 = /[a-z][1-9]/;
	match = out.match(regex1);
	if (match != null) {
		console.log(match);
		strMatch = match[0];
		rep = strMatch[0] + "<br> " + strMatch[1];
		out = out.replace(strMatch, rep);
	}
	if (out[0] === " ") out = out.slice(1,out.length);
	out = out.replace("partikelntill", "partikeln till;");
	if (out[out.length-1] === ",") out = out.slice(0,out.length-1)
	return out;
}
function fullClassName(name) {
	if (name === "en") return "substantiv_en"
	if (name === "ett") return "substantiv_ett"
	return name
}
function guessClass(word) {
	// Prefer explicit definition of class
	if (word.includes('(') && word.includes(')')) {
		// grab class	
		let start = word.indexOf('(')
		let end = word.indexOf(')')	
		if (start > end || start === -1) return 
		let c = word.slice(start+1,end);
		c = fullClassName(c);
		return c;
	} 
	// Otherwise try and semi-intelligently guess word class
	if (word.endsWith('a')) return "verb"
	if (word.endsWith('as')) return "verb"
	if (word.includes(' ')) return "verb"
	if (word.endsWith("ig")) return "adjektiv"
	if (word.endsWith("lös")) return "adjektiv"
	if (word.endsWith("sam")) return "adjektiv"
	if (word.endsWith("full")) return "adjektiv"
	if (word.endsWith("ad")) return "adjektiv"
	if (word.endsWith("en")) return "adjektiv"
	if (word.endsWith("p")) return "substantiv_ett"
	return "substantiv_en"
}
function removeClassDesc(word) {
	let start = word.indexOf('(');
	let end = word.indexOf(')');
	if (start > end || start === -1) return word 
	console.log(word.slice(0,start-1))
	return word.slice(0,start-1)	
			
}
function addWord() {
	if (DEBUG) console.log("addWord()");
	let word = $('#iSeek').val();	
	let del = word[0] === '.';
	if (del) word = word.slice(1,word.length);
	if (word.length > 0) {
		let op = "add"	
		if (del) op = "remove"
		fetch('backend/' + op + 'Word.php?class=' + CLASS + "&word=" + word, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			wordCount();
		})
		.catch(error => {
			console.log(error);	
		})
	}
}

function addMeta(def, regx) {
	if (DEBUG) console.log("addMeta(), regx =´" + regx);
	// Only apply one meta tag
	if (def[2] === "[" && def.indexOf("]") > 2) return def;
	if (!def[0].match(/A-Z/)) {			
		m = def.match(regx)
		if (m) {
			def = def.replace(m[0], "[" + m[0] + "]");
		}		
	}
	return def;
}

function preProc(def) {
	if (DEBUG) console.log("preProc(def(); def = " + def)
	// Split definition
	def = def.replaceAll(" JFR", "\nJFR");
	arr = def.split("\n");
	let outDef = "";
	// Grammer information - Support for partikel parters
	// Can be between 1 and 3 suggested partner words
	let regex1 = /skilt[a-zäöå]+/;
	let regex1_alt = /partikeln[a-zäöå]+/;
	let regex2 = /skilt[a-zäöå]+, [a-zäöå]+/;
	let regex3 = /skilt[a-zäöå]+, [a-zäöå]+, [a-zäöå]+/;
	// Delimiter is blank on first line
	let del = "";
	for (s of arr) {			
		if (s.length > 1) {
			// Remove any leading space(s)
			while (s[0] === " ") {
				s = s.slice(1,s.length)
			}
			
			// Leading Meta tags
			var regx;
			regx = /(något hög\u00AD+tidligt)/g;
			s = addMeta(s,regx);			
			regx = /(något var\u00AD+dagligt)/g;
			s = addMeta(s,regx);		
			regx = /(var\u00AD+dagligt)/g;		
			s = addMeta(s,regx);
			regx = /(dialektalt)/g;		
			s = addMeta(s,regx);
								
			// Remove any reference numbers other than that at line start
			let trail = s.slice(2,s.length);
			for (let i = 1; i < 24; i++) {
				trail = trail.replaceAll(" " + i + " "," ");
				trail = trail.replaceAll(i,"");				
			}
			s = s.slice(0,2) + trail;		
			s = s.replaceAll("  ", " ");
			s = s.replaceAll("  ", " ");
			let match = s.match(/[\s]+[,]+/i);
			if (match) {
				s = s.replaceAll(match[0],",");				
			}
			
			let m = s.match(regex1);
			let m_alt = s.match(regex1_alt);
			let m2 = s.match(regex2);
			let m3 = s.match(regex3);
			let rep = ""
			if (m3 != null) {
				let strMatch = m3[0];
				let rep = strMatch.slice(0,5) + " " + strMatch.slice(5,strMatch.length) + ")";
				s = s.replace(strMatch, rep);
			} else if (m2 != null) {
				let strMatch = m2[0];
				rep = strMatch.slice(0,5) + " " + strMatch.slice(5,strMatch.length) + ")";
				s = s.replace(strMatch, rep);
			} else if (m != null) {
				let strMatch = m[0];
				let rep = strMatch.slice(0,5) + " " + strMatch.slice(5,strMatch.length) + ")";
				s = s.replace(strMatch, rep);
			} else if (m_alt != null) {
				let strMatch = m_alt[0];
				let rep = strMatch.slice(0,9) + " " + strMatch.slice(9,strMatch.length) + ")";
				s = s.replace(strMatch, rep);
			}
			let f1 = "utan) större betydelse­skillnad";
			let f2 = "), utan större betydelse­förändring";
			let f3 = "), utan större betydelse­skillnad";
			let f4 = "utan) större betydelse­förändring";
			s = s.replace(f1, f1.replace(")","") + ")");
			s = s.replace(f2,f2.replace(")","") + ")");
			s = s.replace(f3,f3.replace(")","") + ")");
			s = s.replace(f4,f4.replace(")","") + ")");
			if (s.includes("((")) s = s.replace("((", "(");
			// Trailing spaces (or non-breaking space) can break links, remove
			let lastCh = s.charAt(s.length-1);			
			if (lastCh.charCodeAt(0) === 32 || lastCh.charCodeAt(0) === 160) {								
				s = s.slice(0,s.length-1)
			}
						
			// grammar information
			s = s.replace("ofta refl.", "(ofta refl.)");
			s = s.replace("med prep.", "( med prep. ");
			s = s.replace("vanligen pres.", "(vanligen pres.)");			
			s = s.replace("ofta plur.", "(ofta plur.)");			
			s = s.replace("kanppast plur.", "(knappast plur.)");
			s = s.replaceAll("ibland med partikel","(ibland med partikel");
			s = s.replaceAll("vanligen med partikel","(vanligen med partikel");
			s = s.replaceAll("ofta med partikel","(ofta med partikel");
			s = s.replaceAll("vanligen i sammansätt.","(vanligen i sammansättn.)");
			s = s.replaceAll("vanligen i vissa sammansätt.",")vanligen i vissa sammansättn.)");			
			//outDef = "";
			outDef += outDef + del + s;			
			// HTML newline separator bon lines subsequent to the first
			del = "<br>";
		}
	}
	// That's it!
	return outDef;
}
function cleanUp() {
	if (DEBUG) console.log("cleanUp(); LAST_DEF = " + LAST_DEF);
	let def = LAST_DEF
	if (def.slice(0,4) === "<br>") def = def.substr(4)
	def = def.replaceAll("<br>","\n");
	def = def.replaceAll(" JFR","\nJFR");
	def = def.replaceAll(" SE","\nSE");
	def = def.replaceAll(" SYN","\nSYN");
	def = def.replaceAll(" MOTSATS","\nMOTSATS");
	putDef(def);
}
function showWords() {
	if ($('#iWords').css("visibility") == "hidden") {
		$('#iWords').css("visibility", "visible");
	}
}
function highlight(el,event) {
	if (event.type === "mouseover") {
		el.style.cursor = "pointer";
		el.style.borderColor = "blue";
		if (el.nodeName === "P") el.style.backgroundColor="gray" 
	} else {
		el.style.cursor = "";
		el.style.borderColor = "";
		if (el.nodeName === "P") el.style.backgroundColor=""
	}
}
function toggleDebugEv(e) {
	e.preventDefault();
	toggleDebug();
}
function toggleDebug() {
	DEBUG = !DEBUG;
	if (DEBUG) {
		console.log("Entering debug mode...");
		$('#iDebugTxt').text("DEBUG");
		$('#iDebug').css("color","gray");
	}  else {
		$('#iDebug').css("color","");
		$('#iDebugTxt').text("");
		console.log("Leaving debug mode...");
	}
}
function setClassGuessWrapper(ev) {
	ev.preventDefault();
	let word = $('#iSeek').val();
	setClassGuess();	
	seekWord(word);
}
function setClassGuess() {
	let word = $('#iSeek').val();
	let c = guessClass(word);
	if (DEBUG) console.log("setClassGuess, Class guessed as " + c)
	setClass(c);
	seekWord(CUR_WORD);
}
</script>
</html>

<!DOCTYPE html>
<head>
	<link rel="stylesheet" href="svenska.css">
	<script src="jquery-3.4.1.min.js"></script>
	<meta char="UTF-8" name="viewport" content="width=device-width, initial-scale=1">
</head>
<body onload="startup()">
<div class="row columns_4">
<!--progress bar-->
	<div title="Scroll to navigate individual words&#10;Left click word = get definition&#10;Right click word = lookup@svensk.se " id="iWordBox" class="wordBox column" onwheel="scrollWords(event)">
		<div id="iControls">
			<div class="dropdown">
				<img title="Class selector. Left click to select all. Right click to go to debug mode" id="iSelect" class="dropdown b2" src="img/Sandhammaren.jpg" onclick="setClass('all')" oncontextmenu="toggleDebugEv(event)" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">				
				<div class="dropdown-content">
					<p onclick="setClass('substantiv_en')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">En</p>
					<p onclick="setClass('verb')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Verb</p>
					<p onclick="setClass('adjektiv')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Adjektiv</p>
					<p onclick="setClass('substantiv_ett')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Ett</p>
					<p onclick="setClass('adverb')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Adverb</p>
				</div>
			</div>
			<div class="dropdown">
				<img title="Class selector #2 (rarer classes), left click to select all" id="iSelectRare" class="dropdown b2" src="img/Oresundsbron.jpg" onclick="setClass('all')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">
				<div class="dropdown-content">
					<p onclick="setClass('plural')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Plural</p>
					<p onclick="setClass('superlativ')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Superlativ</p>
					<p onclick="setClass('preposition')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Preposition</p>					
					<p onclick="setClass('pronomen')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Pronomen</p>
					<p onclick="setClass('interjektion')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Interjektion</p>										
				</div>
			</div>						
			<div class="dropdown">
				<img title="Class selector #3 (rarer classes), left click to select all" id="iSelectRare" class="dropdown b2" src="img/TurningTorso.jpg" onclick="setClass('all')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">
				<div class="dropdown-content">		
					<p onclick="setClass('förled')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Förled</p>
					<p onclick="setClass('slutled')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Slutled</p>
					<p onclick="setClass('räkneord')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Räkneord</p>
					<p onclick="setClass('konjunktion')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Konjunktion</p>
					<p onclick="setClass('subjunktion')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">Subjunktion</p>
				</div>
			</div>		
			<p class="debug" id="iDebugTxt"></p>
			<form onsubmit="seekWordWrapper(event)">
				<input title="Search for word in current class" id="iSeek" oncontextmenu="onlineLookup(this,event)" class="inputSearch">		
				<img title="Left click: add word to store*&#10;Right click: guess class&#10;*(prefix with '.' to delete" class="b2" src="img/add.svg" id="iAdd" onclick="addWord()" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)" oncontextmenu="setClassGuessWrapper(event)">
				<img title="Back to last view" class="b2" src="img/leftArrow.png" id="iLast" onclick="seekWord('')" onmouseover="highlight(this,event)" onmouseout="highlight(this,event)">
			</form>				
		</div>
		<p id="iWords" class="fmtWords">Test<br>Words</p>
	</div>
	<div title="Mouse wheel/ or click left/right to navigate&#10;Right click definition to edit.&#10;Double left click definition to hide def&#10;Words referenced as SE, JFR, MOTSATS etc can be clicked for instant navigation&#10;Word classes in italics can also be clicked to change class selection directly"class="column" onwheel="scrollView(event)">
		<span class="counts" id="iCnt" onclick="showToggle()">test</span>
		<span class="counts" id="iCntTotal" onclick="showToggle()">Total</span>
		<div  id="iDefDiv">
			 <textarea  class="defBox" id="iDefText"></textarea>
			 <button onclick="putDef('')">Put</button>
			 <button onclick="cleanUp()">Clean up</button>
		</div>
		<p class="pDef" id="iParDef" ondblclick="clearDef()" oncontextmenu="editDef(event)"></p>
		<div id="iNavDiv" onclick="scrollViewDown()" oncontextmenu="scrollViewUp(event)"></div>
	</div>	
	<div title="Navigation: left/scroll down = forward, right click/scroll up = back" class="column" onwheel="scrollView(event)" onclick="scrollViewDown()" oncontextmenu="scrollViewUp(event)"></div>	
</div>
</body>
<script>

let INC = 0;
let N_INC= 8;
let SCROLL_INC=0
let N_FOUND=0;

let N_TOT=0;
let N_ADJ=0;
let N_VERB=0;
let N_ADVERB=0;
let N_EN=0;
let N_ETT=0;
let N_PLURAL=0;
let N_PREPOSITION = 0;
let N_INTERJEKTION = 0;
let N_PRONOMEN = 0;
let N_PREFIX = 0;
let N_SUPERLATIV = 0;
let N_SLUTLED = 0;
let N_NUMMER = 0;
let N_SUBJUNKTION = 0;
let N_CUR=0;
let N_DEFS = 0;

let LAST_WORD="";
let CUR_WORD="";
let CLASS = "all";
var LAST_OBJ;
let DEBUG=false;
let LAST_DEF = "";
let LAST_CLASS = "all";
let CONTROLS_VISIBLE=true;
function startup() {
	wordCount();
	getWords(-1);
}

function setN_CUR() {
	if (CLASS === "adjektiv") {
		N_CUR = N_ADJ;
	} else if (CLASS === "verb") {
		N_CUR = N_VERB;
	} else if (CLASS === "adverb") {
		N_CUR = N_ADVERB;
	} else if (CLASS === "substantiv_en") {
		N_CUR = N_EN;
	} else if (CLASS === "substantiv_ett") {
		N_CUR = N_ETT;
	} else if (CLASS === "preposition") {
		N_CUR = N_PREPOSITION;
	} else if (CLASS === "interjektion") {
		N_CUR = N_INTERJEKTION;
	} else if (CLASS === "pronomen") {
		N_CUR = N_PRONOMEN;
	} else if (CLASS === "förled") {
		N_CUR = N_PREFIX;
	} else if (CLASS === "plural") {
		N_CUR = N_PLURAL;
	} else if (CLASS === "superlativ") {
		N_CUR = N_SUPERLATIV;
	} else if (CLASS === "slutled") {
		N_CUR = N_SLUTLED;
	} else if (CLASS === "räkneord") {
		N_CUR = N_NUMMER;
	} else if (CLASS === "konjunktion") {
		N_CUR = N_KONJUNKTION;
	} else if (CLASS === "subjunktion") {
		N_CUR = N_SUBJUNKTION;
	} else if (CLASS === "all") {
		N_CUR = N_TOT;
	}
	if (CLASS === "all") {
		$('#iCnt').text("");
	} else {
		$('#iCnt').text(N_CUR.toLocaleString('sv'));
	}
	$('#iCntTotal').text(' [' + N_TOT.toLocaleString('sv') + ']');
	if (DEBUG) console.log("setN_CUR(); N_CUR = " + N_CUR);
}
function getProgress() {
	var proj;
	if (N_CUR != 0) {
		prog = parseInt(INC/N_CUR *100);
	} else {
		prog = 0;
	}
	$('#iProg').css("width", prog + "%");	
	if (DEBUG) console.log("getProgress(); prog = " + prog); 
}
function fmtDef(def) {
	for (i = 0; i < 24; i++) {
		let old = " " + i + " ";
		let rep = "<br>" + i + " ";
		def = def.replace(old,rep)
	}
	return def;
}
function putDef(def) {
	if (def.length === 0) {
		def = $('#iDefText').val();
	}
	if (DEBUG) console.log("START putDef(def); def = " + def + "; SCROLL_INC = " + SCROLL_INC);
	def = preProc(def);	
	fetch('backend/putDef.php?class=' + CLASS + '&word=' + CUR_WORD + '&def=' + def, {
		method: 'get',
		mode:	'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		$('#iDefText').val("");
		$('#iDefDiv').css("display", "none");
		// Reset highlighting of missing definition
		LAST_OBJ.innerHTML = LAST_OBJ.innerText;
		updateDef();
		// Race condition here between file write and def display	
		if (SCROLL_INC === (N_FOUND - 1)) {
			lookupWord(LAST_OBJ,true,true);
		}
	})
}
function changeInc(delta) {
	if (INC + delta > N_CUR) {
		INC = INC;
	} else {
		INC += delta
	}
	if (INC < 0) {
		INC = 0;
	}
	if (DEBUG) console.log("changeInc(" + delta + ") -> INC: " + INC);
}
function nextID(id) {
	let num = id.replace("w","");
	if (++num < N_FOUND) {
		return "w" + num;
	} else {
		return id;
	}
}
function advance() {
	changeInc(N_INC)
	getWords(-1)
}
function retreat(e) {
	e.preventDefault()
	changeInc(-N_INC)
	getWords(-1)
}
function getWords(ind) {
	// Ind is used to highlight and lookup a given word index from the returned list
	// Global INC is used to get the starting index of the returned list
	if (DEBUG) console.log("getWords(), ind = " + ind + ", INC = ", + INC);
	SCROLL_INC=-1;
	N_FOUND=0;
	$('#iParDef').text("");
	fetch("backend/getWords.php?class=" + CLASS + "&start=" + INC + "&num=" + N_INC, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json',
		}
	})
	.then(response => {
		return response.json()
	})
	.then(json => {
		let lastJson = json;
		let out = ""
		N_FOUND=json.length;
		if (N_FOUND > 0) {
			let list = json[0];
			for (i = 1; i < N_FOUND; i++) {
				list += "," + json[i];	
			}
			fetch('backend/existsDef.php?class=' + CLASS + "&words=" + list, {
				method: 'get',
				mode: 'cors',
				headers: {
					'Content-Type': 'application/json'
				}
			})
			.then(response => {
				return response.json();
			})
			.then(json => {
				res = json;
				for (let i = 0; i < N_FOUND; i++) {
					let del = "<br>"
					if (i === 0) { 
						del = ""
					}
					let tmp = 1 << i;
					let hasDef = (res & tmp);
					out += del + popSpan(i, lastJson[i],hasDef) 
				}
				$('#iWords').html(out);
				showWords();
				getProgress();
				countDefs();
				if (ind > -1) {
					let el = document.getElementById("w" + ind);
					lookupWord(el,false,true);
				}
				if (DEBUG) console.log("getWords(ind); ind = " + ind + ", N_FOUND = " + N_FOUND);
			})
			.catch(error => {
				console.log(error);
			})
		}
	})
}

function scrollViewDown() {
	if (DEBUG) console.log("scrollViewDown() begin");
	changeInc(N_INC);
	$('iDefDiv').css("display", "none");
	getWords(-1);
	showWords();
}
function scrollViewUp(e) {
	e.preventDefault();
	if (DEBUG) console.log("scrollViewUp() begin");
	changeInc(-N_INC);
	getWords(-1);
	showWords();
}
function scrollView(e) {
	if (DEBUG) console.log("scrollView() begin");
	e.preventDefault();
	showWords();
	if (e.deltaY > 0) {
		scrollViewDown();
	} else {
		scrollViewUp(e);
	}
	if (DEBUG) console.log("scrollView(); INC = " + INC)
}

function scrollWords(e) {
	e.preventDefault();
	if (event.deltaY > 0) {
		scrollDown();
	} else {
		scrollUp();
	}
	// Show local definition if available
	updateDef();
	if (DEBUG) console.log("scrollWords() -> SCROLL_INC = " + SCROLL_INC);
}

function scrollDown() {
	if (SCROLL_INC < N_FOUND-1) {
		SCROLL_INC++;
	}
	if (DEBUG) console.log("scrollDown(); SCROLL_INC = " + SCROLL_INC);
}
function scrollUp() {
	if (SCROLL_INC > 0) {
		SCROLL_INC--;
	} else if (SCROLL_INC == -1) {
		SCROLL_INC = N_FOUND - 1;
	}
	if (DEBUG) console.log("scrollUp(); SCROLL_INC = " + SCROLL_INC);
}
function updateDef() {
	if (DEBUG) console.log("updateDef()");
	let id = "w" + SCROLL_INC;
	let el = document.getElementById(id);
	lookupWord(el,true,true);
}
function popSpan(i, w, hasDef) {
	tmp = "<span id='w<i>' onclick='lookupWord(this,false,false)' oncontextmenu='onlineLookup(this,event)'><w></span>"
	if (DEBUG) console.log("popSpan(i=" + i + ",w=" + w + ",hasDef=" + hasDef + ")");
	tmp = tmp.replace("<i>",i)
	if (hasDef || CLASS === "all") {
		tmp = tmp.replaceAll("<w>",w);
	} else { 
		tmp = tmp.replaceAll("<w>","<i>" + w + "</i>");
	}
	return tmp
}

function lookupWord(el,onlyLocal,inline) {
	if (LAST_OBJ) {
		LAST_OBJ.style.fontWeight="";
	}
	el.style.fontWeight="bold";
	let word = el.innerText;
	CUR_WORD=word;
	LAST_OBJ = el;
	if (DEBUG) console.log("lookupWord(), CUR_WORD = " + CUR_WORD);
	scroll_inc = el.id.replace("w","");
	if (scroll_inc > -1 && scroll_inc < N_INC) {
		SCROLL_INC = scroll_inc; 
	}
	if (CLASS === "all") {
		fetch('backend/getDefAll.php?word=' + word, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json();
		})
		.then(json => {
			let keys = Object.keys(json);						
			let def = "";
			let delim ="";			
			let tmp = "<span onmouseover=highlight(this,event) onclick=\"setClass(\'_k_\',\'_w_\')\"><i>_k_:</i><br></span>";			
			for (let i = 0; i < keys.length; i++) {		
				def += delim + tmp.replaceAll("_k_", keys[i]).replace("_w_",word) + makeLinks(json[keys[i]]);
				delim="<br>";
			}
			LAST_DEF = def;
			$('#iParDef').html("<b>" + word + ":</b><br>" + def);
			return;
		})
		.catch(error => {
			console.log(error);
		})
	} else {
		fetch('backend/getDef.php?class=' + CLASS + '&word='+ word, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json()
		})
		.then(json => {
			def = json;
			LAST_DEF = json;
			// Prefer local definition over 3rd party dictionary
			if (def != "No definition found" && def != "Could not read json") {
				if (json.includes("till '")) {
					getCompDef(def);
					return;
				}
				def = makeLinks(def);
				$('#iParDef').html("<b>" + word + ":</b><br>" + def);
				$('#iDefDiv').css("display", "none");
				if (!inline) {
					$('#iWords').css("visibility", "hidden");
				}
			} else {
				if (!onlyLocal) {
					let url = "https://svenska.se/tre?sok=" + word + "&pz=1";
					window.open(url, '_blank');
				}
				$('#iParDef').html("");
				$('#iDefDiv').css("display", "block");
				$('#iDefText').focus();
			}
		})
		.catch(error => {
			console.log(error)
		})
	}
	
	if (DEBUG) {
		if (word.length === 0) word = "__empty__";
		console.log("lookupWord(" +  word + ")");
	}
}
// Make links to referenced words
function makeLinks(def) {
	if (DEBUG) console.log("makeLinks()")
	def = linkSingleWord(def);
	if (def.split("<br>").length == 1) {
		return def;
	}
	
	def = addLinks("MOTSATS", def);
	def = addLinks("JFR", def);
	def = addLinks("SYN.", def);
	def = addLinks("SE", def);	
	return def;
}
function linkSingleWord(def) {
	if (DEBUG) console.log("linkSingleWord(def), def " + def);
	if (def.substr(0,6) === "till '") return def;
	defArr = def.split("<br>");
	outDef = "";
	del = "";
	tmpSpan = "<span onclick=followLink(this) onmouseover=highlight(this,event) title='Navigate to \"_w_\"'>_w_</span>";
	for (line of defArr) {		
		// Excluse explicitly predefined links and word class links e.g. "verb:"
		if (line[0].match(/[A-Z]/) != null || line.indexOf(":") != -1) {
			outDef += del + line;
			del = "<br>";
		} else {
			let tmp = line;
			tmp = tmp.substr(2);			

			// Strip away meta and grammer information
			let res = tmp.match(/(\[.*\])/);
			if (res) {
				tmp = tmp.replace(res[0] + " ","");
			}
			res = tmp.match(/(\(.*\))/);
			if (res) {
				tmp = tmp.replace(res[0] + " ","");
			}
			let ref = "det att ";
			// Simple references to verbs
			if (tmp.indexOf(ref) === 0) tmp = tmp.replace(ref,"");
			let cnt = tmp.match(/ /g);
			if (cnt === null) {
				let offset = 1;
				if (cnt === null) offset = 0
				let word = tmp.substr(offset).replaceAll("­","");
				line = line.replace(word, tmpSpan.replaceAll("_w_",word));				
			} 
			
			outDef += del + line;
			del = "<br>";
		}
	}
	return outDef;
}

function addLinks(refClass,def) {
	if (DEBUG) console.log("addLinks(), refClass = " + refClass + ", def = " + def);
	if (def.indexOf(refClass) === -1) return def;
	// Easiest to handle line by line and skip the lines without links
	// Expectation is each link class (JFR, SE etc.) has its own new line.
	defArr = def.split("<br>");
	def = "";
	m = refClass + " ";
	delim = "";
	beginSpan = "<span onclick=followLink(this)";
	beginSpan += " onmouseover=highlight(this,event)";
	beginSpan += " title='Navigate to \"_w_\"'";
	beginSpan += ">"
	spanTmp = beginSpan + "_w_</span>";
	for (line of defArr) {
		
		if (line.indexOf(m) != -1) {
			elArr = line.split(", ");
			for (el of elArr) {
				el = el.replaceAll("­","");
				if (el.includes(m)) {
					let rep = m + spanTmp.replaceAll("_w_",el.substr(m.length, el.length - m.length))
					line = line.replace(el, rep);
				} else {
					let rep = spanTmp.replaceAll("_w_", el);
					line = line.replace(", " + el, ", " + rep);
				}
			}
		}
		def += delim + line;
		delim = "<br>";
	}
	return def;
}
function followLink(el) {
	let word = el.innerText;
	if (DEBUG) console.log("followLink(" + word + ")");
	$('#iSeek').val(word);	
	setClass("all");
	seekWord(word);
}

function getCompDef(def) {
	if (DEBUG) console.log("getCompDef(def); def = " + def);
	// Compose and output string that combines definition of multiple (usually two)
	// component words
	words = getRefs(def);
	let complete = false;
	let res = "";
	let out = [];
	let done = 0;
	for (let i = 0; i < words.length; i++) {
		let w = words[i];
		// Dispatch n fetches to get definitions
		// add an identifier to each result to enable correct ordering 
		fetch('backend/getDef.php?class=' + guessClass(w) + '&word='+ removeClassDesc(w), {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json();
		})
		.then(json => {
			// def - the original reference definition
			// tmp - original ref + link to the referenced word
			// json - the referenced definition
			let tmp = "<span onclick=\"followLink(this)\"><b>_w_</b></span>:";
			tmp = tmp.replaceAll("_w_",removeClassDesc(w));
			tmp = tmp + "<br>";
			out[done] = makeLinks(tmp + json);
			done++;
			if (done >= words.length) {
				// Perform any required ordering
				let txt = def + "<br>";
				let del = "";
				for (let i = 0; i < done; i++) {
					if (i != 0) del = "<br>"
					txt = txt + del + out[i];
				}
				$('#iParDef').html(txt);
			}
		})
		.catch(error => {
			console.log(error);
		})
	}
}
function getRefs(def) {
	if (!def.includes("till ") || !def.includes("'")) {
		return "";
	}
	def = def.replaceAll("till ", "");
	def = def.replaceAll("'","");
	arr = def.split(",");
	if (DEBUG) console.log("getRef(), arr = " + arr);
	return arr;
}

function onlineLookup(el, e) {
	e.preventDefault()
	word = el.innerText;
	if (word.length === 0) word = el.value;
	let url = "https://svenska.se/tre?sok=" + word + "&pz=1";
	window.open(url, '_blank');
}

function wordCount() {
	fetch('backend/wordCount.php', {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		},
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		N_TOT = json["total"];
		N_ADJ = json["adj"];
		N_VERB = json["verb"];
		N_ADVERB = json["adverb"];
		N_EN = json["substantiv_en"];
		N_ETT = json["substantiv_ett"];		
		N_PLURAL = json["plural"];
		N_SUPERLATIV = json["superlativ"];
		N_PREPOSITION = json["preposition"];
		N_INTERJEKTION = json["interjektion"];
		N_PRONOMEN = json["pronomen"];
		N_PREFIX = json["prefix"];
		N_SLUTLED = json["slutled"];
		N_NUMMER = json["nummer"];
		N_KONJUNKTION = json["konjunktion"];
		N_SUBJUNKTION = json["subjunktion"];
		setN_CUR();
		getProgress();
	})
	.catch(error => {
		console.log(error);
	})
}

function showToggle() {
	if (CONTROLS_VISIBLE) {
		// Hide controls 
		$('#iControls').css("display", "none");
		$('#iShowToggle').text("__");
		CONTROLS_VISIBLE=false;
	} else {
		// Make visible class selector and word seeker controls
		$('#iControls').css("display", "block");
		$('#iShowToggle').text("HIDE");
		$('#iSeek').focus();
		CONTROLS_VISIBLE=true;
	}
	if (DEBUG) console.log("showToggle(); seek.v = " + $('#iSeek').css("visibility") + ", sel.v = " + $('#iSelect').css("visibility"));
}
function seekWordWrapper(e) {
	e.preventDefault();
	let word = $('#iSeek').val();
	seekWord(word);
}
function seekWord(word) {
	if (word === '') {
		word = LAST_WORD;
		setClass(LAST_CLASS);
		$('#iSeek').val(word);
	}
	word = word.toLowerCase();
	LAST_WORD = CUR_WORD;
	CUR_WORD = word;
	if (DEBUG) console.log("seekWord(): LAST_WORD = " + LAST_WORD + ", CUR_WORD = " + CUR_WORD);
	// Special case of prefixes and suffices
	if (word.substr(word.length-1) === "-") {
		word = word.substr(0,word.length-1);
		setClass("förled");
	} else if (word.slice(0,1) === "-") {
		word = word.substr(1);
		setClass("slutled");
	}
	if (word.length > 0) {
		fetch('backend/seekWord.php?class=' + CLASS + "&word=" + word + "&inc=" + INC, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			return response.json();
		})
		.then(json => {
			if (json > -1) {
				// Put selected word in the middle of the word collection				
				INC = json - 3;
				let ind = 3;
				let mid = N_INC/2;
				if (json < mid - 1) {					
					INC = 0;
					ind = json;
				}
				getWords(ind);
			} else {
				// If no match in specific class useful to show matches in other classes.
				fetch('backend/getDefAll.php?word=' + word, {
					method: 'get',
					mode: 'cors',
					headers: {
						'Content-Type': 'application/json'
					}
				})
				.then(response => {
					return response.json();
				})
				.then(json => {
					if (Object.keys(json).length > 0) {
						let keys = Object.keys(json);						
						let def = "";
						let delim ="";
						let tmp = "<span title='Navigate to class \"_k_\"' onclick=\"setClass(\'_k_\',\'_w_\')\"><i>_k_:</i><br></span>";
						for (let i = 0; i < keys.length; i++) {			
							let compDef = json[keys[i]];															
							def += delim + tmp.replaceAll("_k_", keys[i]).replace("_w_",word) + makeLinks(compDef);
							delim="<br>";
						}
						LAST_DEF = def;
						$('#iParDef').html("<b>" + word + ":</b><br>" + def);
					} else {
						$('#iParDef').html("No matches in any word class.");
					}
				})
				.catch(error => {
					console.log(error);
				})
			}
		})
		.catch(error => {
			console.log(error);
		})
	}
	if (DEBUG) console.log("seekWord(); word = " + word + " -> INC = " + INC);
}

function setClass(c, seek = "") {
	LAST_CLASS = CLASS;
	$('#iDefDiv').css("display", "none");
	$('#iWords').css("visibility", "visible");
	if (c != "all") {
		$('#iDefProgContainer').css("visibility","visible");
	} else {
		$('#iDefProgContainer').css("visibility","hidden");
	}
	CLASS = c;
	INC = 0;
	SCROLL_INC=-1;
	setN_CUR();
	getProgress();
	countDefs();
	getWords(-1);
	if (seek.length > 0) seekWord(seek);
	if (DEBUG) console.log("setClass(c, seek); CLASS = " + CLASS + ", seek = " + seek + ", INC = " + INC + ", SCROLL_INC = " + SCROLL_INC + ", N_CUR = " + N_CUR);
}
function countDefs() {
	N_DEFS = 0;
	fetch('backend/countDef.php?class=' + CLASS, {
		method: 'get',
		mode: 'cors',
		headers: {
			'Content-Type': 'application/json'
		}
	})
	.then(response => {
		return response.json();
	})
	.then(json => {
		if (json != "Failed to read definition file.") {	
			N_DEFS=json;
			if (DEBUG) console.log("countDefs(); N_DEFS = " + N_DEFS);
			$('#iDefProg').css("width", N_DEFS/N_CUR * 100 + "%");
		} else {
			if (DEBUG) console.log("countDefs(); N_DEFS = " + N_DEFS);
		}
	})
}

function editDef(e) {
	e.preventDefault();
	showWords();
	$('#iDefDiv').css("display", "block");
	$('#iDefText').focus();
}
function clearDef() {
	if (DEBUG) console.log("clearDef()");
	$('#iParDef').html("");
	$('#iWords').css("visibility", "visible");
	$('#iDefDiv').css("display", "none");
}
function pretty(def) {
	if (DEBUG) console.log("pretty(def); def = " + def);
	let out = "";
	subdefs = def.split("<br>");
	for (let i = 0; i < subdefs.length; i++) {
		del = "<br>";
		if (i === 0) del="";
		s = subdefs[i];		
		pJFR = s.indexOf("JFR");
		pSE = s.indexOf("SE");
		pMOTS = s.indexOf("MOTSATS");
		pSYN = s.indexOf("SYN");
		let tot = pJFR + pSE + pMOTS + pSYN;
		if (tot === -4) {
			out = out + del + s;
		} else {
			// New line before the JFR, SE, MOTS indicators for styling
			if (pJFR === -1) pJFR = 999999;
			if (pSE === -1) pSE = 999999;
			if (pMOTS === -1) pMOTS = 999999;
			if (pSYN === -1) pSYN = 999999;
			let start = pSE;
			if (pJFR < start) start = pJFR;
			if (pMOTS < start) start = pMOTS;
			if (pSYN < start) start = pSYN;
			let def2 =  s.slice(start,s.length);
			s = s.slice(0,start) + "<br>"
			def2 = def2.replaceAll("1","").replaceAll("2","").replaceAll("3","").replaceAll("4","");
			def2 = def2.replaceAll(" ,",",").replaceAll("  ", " ");
			def2 = def2.replaceAll(" 1<br>","<br>");
			out = out + del + s + def2;
		}
	}
	out = out.replaceAll("<br><br>","<br>");
	for (let i = 1; i < 24; i++) {
		out = out.replaceAll(i + " " + i, i);
		out = out.replaceAll("<br>" + i + "<br>","<br>" );
		out = out.replaceAll("<br> " + i + "<br>","<br>" );
		out = out.replaceAll("<br>" + i + " <br>","<br>" );
	}
	// Strip any leading new line
	if (out.slice(0,3) === "<br>") {
		out = out.slice(4,out.length) 
	}
	const regex1 = /[a-z][1-9]/;
	match = out.match(regex1);
	if (match != null) {
		console.log(match);
		strMatch = match[0];
		rep = strMatch[0] + "<br> " + strMatch[1];
		out = out.replace(strMatch, rep);
	}
	if (out[0] === " ") out = out.slice(1,out.length);
	out = out.replace("partikelntill", "partikeln till;");
	if (out[out.length-1] === ",") out = out.slice(0,out.length-1)
	return out;
}
function fullClassName(name) {
	if (name === "en") return "substantiv_en"
	if (name === "ett") return "substantiv_ett"
	return name
}
function guessClass(word) {
	// Prefer explicit definition of class
	if (word.includes('(') && word.includes(')')) {
		// grab class	
		let start = word.indexOf('(')
		let end = word.indexOf(')')	
		if (start > end || start === -1) return 
		let c = word.slice(start+1,end);
		c = fullClassName(c);
		return c;
	} 
	// Otherwise try and semi-intelligently guess word class
	if (word.endsWith('a')) return "verb"
	if (word.endsWith('as')) return "verb"
	if (word.includes(' ')) return "verb"
	if (word.endsWith("ig")) return "adjektiv"
	if (word.endsWith("lös")) return "adjektiv"
	if (word.endsWith("sam")) return "adjektiv"
	if (word.endsWith("full")) return "adjektiv"
	if (word.endsWith("ad")) return "adjektiv"
	if (word.endsWith("en")) return "adjektiv"
	if (word.endsWith("p")) return "substantiv_ett"
	return "substantiv_en"
}
function removeClassDesc(word) {
	let start = word.indexOf('(');
	let end = word.indexOf(')');
	if (start > end || start === -1) return word 	
	return word.slice(0,start-1)
			
}
function addWord() {
	if (DEBUG) console.log("addWord()");
	let word = $('#iSeek').val();	
	let del = word[0] === '.';
	if (del) word = word.slice(1,word.length);
	if (word.length > 0) {
		let op = "add"	
		if (del) op = "remove"
		fetch('backend/' + op + 'Word.php?class=' + CLASS + "&word=" + word, {
			method: 'get',
			mode: 'cors',
			headers: {
				'Content-Type': 'application/json'
			}
		})
		.then(response => {
			wordCount();
		})
		.catch(error => {
			console.log(error);	
		})
	}
}

function addMeta(def, regx) {
	// If a known meta phrase is identified at start of definition line then enclose it in square bracket formatting
	if (DEBUG) console.log("addMeta(), regx =´" + regx);
	if (def.length < 3 || def[0].match(/A-Z/)) return def
	// Only apply one meta tag
	if (def[2] === "[" && def.indexOf("]") > 2) return def;	
	// Probably don't actual need regex but leave "ias is" for now
	let rawStr = regx.source;
	if (def.indexOf(rawStr) === 2) {
		def = def.replace(rawStr, "[" + rawStr + "]");
	}
	return def;
}
function grammer(def, rep) {
	return def.replace(" " + rep, " (" + rep + ")");
}
function preProc(def) {
	if (DEBUG) console.log("preProc(def(); def = " + def)
	// Split definition
	def = def.replaceAll(" JFR", "\nJFR");
	def = def.replaceAll(" SE", "\nSE");
	def = def.replaceAll(" SYN.", "\nSYN.");
	def = def.replaceAll(" MOTSATS", "\nMOTSATS");	
	arr = def.split("\n");
	let outDef = "";
	// Grammer information - Support for partikel parters
	// Can be between 1 and 3 suggested partner words
	let regex1 = /skilt[a-zäöå]+/;
	let regex1_alt = /partikeln[a-zäöå]+/;
	let regex2 = /skilt[a-zäöå]+, [a-zäöå]+/;
	let regex3 = /skilt[a-zäöå]+, [a-zäöå]+, [a-zäöå]+/;
	// Delimiter is blank on first line
	let del = "";
	for (s of arr) {			
		if (s.length > 1) {
			// Remove any leading space(s)
			while (s[0] === " ") {
				s = s.slice(1,s.length)
			}
			// Defuault to "pretty" leading bullet point
			if (s[0].match(/[a-zäöå]+/) != null) {
				s = `\u25CF ` + s;
			}
			// Leading Meta tags
			// Beware the silent hyphens (\u00AD)
			s = addMeta(s,/något hög­tidligt ut\u00ADom i sammansättn./);
			s = addMeta(s, /hög­tidligt; mest bibliskt/);
			s = addMeta(s,/något hög­tidligt el. formellt/);			
			s = addMeta(s,/något hög­tidligt el. skämtsamt/);
			s = addMeta(s,/något hög­tidligt/);		
			s = addMeta(s,/hög­tidligt/);					
			s = addMeta(s,/något var­dagligt/);		
			s = addMeta(s,/var­dagligt; dialektalt/);
			s = addMeta(s,/var­dagligt; ned\u00ADsättande/);
			s = addMeta(s,/starkt var­dagligt/);
			s = addMeta(s,/var­dagligt/);
			s = addMeta(s,/dialektalt/);
			s = addMeta(s,/nu­mera mindre brukligt i fack\u00ADmässiga samman\u00ADhang/);
			s = addMeta(s,/mindre brukligt/);
			s = addMeta(s,/sär­skilt ekonomi/);
			s = addMeta(s,/sär­skilt i matematiskt fack­språk/);
			s = addMeta(s,/matematisk/);
			s = addMeta(s,/fysik/);		
			s = addMeta(s,/sär­skilt i juridiska samman\u00ADhang/);
			s = addMeta(s,/sär­skilt juridik/);
			s = addMeta(s,/juridik/);	
			s = addMeta(s,/psykologi/);
			s = addMeta(s,/informations­teknik/);
			s = addMeta(s,/sär­skilt i fack­språk/);
			s = addMeta(s,/ofta i fack­språk/);
			s = addMeta(s,/mest i fack­mässiga samman­hang/);
			s = addMeta(s,/ålderdomligt ut\u00ADom i bibliska samman\u00ADhang/);
			s = addMeta(s,/något ålderdomligt/);
			s = addMeta(s,/ålderdomligt/);
			s = addMeta(s,/sär\u00ADskilt vid beskrivning av ut\u00ADländska förhållanden/);
			s = addMeta(s,/något formellt/);
			s = addMeta(s,/formellt/);
			s = addMeta(s,/delvis historiskt/);
			s = addMeta(s,/mest historiskt/);
			s = addMeta(s,/historiskt/);
			s = addMeta(s,/sär\u00ADskilt i barn\u00ADspråk och i imiterat barn\u00ADspråk/);
			s = addMeta(s, /nu\u00ADmera ej i fack\u00ADmässiga samman\u00ADhang/);
			s = addMeta(s, /mest i fack\u00ADspråk/);
			s = addMeta(s, /sär­skilt i vetenskapliga samman­hang/);
			s = addMeta(s, /ofta i vetenskapliga el. tekniska samman\u00ADhang/);
			s = addMeta(s, /i vetenskapliga samman­hang/);
			s = addMeta(s, /mest i tekniska samman­hang/);
			s = addMeta(s,/mest i vetenskapliga samman\u00ADhang/);
			s = addMeta(s,/sär­skilt i vetenskapliga samman\u00ADhang/);
			s = addMeta(s, /i vetenskapliga samman\u00ADhang/);
			s = addMeta(s, /ålderdomligt el. skämtsamt/);
			s = addMeta(s,/mest vid beskrivning av äldre förhållanden/);
			s = addMeta(s,/äv. som musikalisk term/);
			s = addMeta(s,/musik/);
			s = addMeta(s,/sär­skilt meteorologi/);
			s = addMeta(s,/ofta i vänster­politisk debatt/);
			s = addMeta(s,/ned­sättande/);
			s = addMeta(s,/ibland något skämtsamt/);
			s = addMeta(s,/sär­skilt statistik/);
			s = addMeta(s,/sär­skilt filosofi, biologi/);
			s = addMeta(s,/sär­skilt filosofi/);			
			s = addMeta(s,/filosofi/);			
			s = addMeta(s,/i allmän­språket/);
			s = addMeta(s,/sär­skilt militär­väsen/);
			s = addMeta(s,/sär­skilt sjö­fart/);
			s = addMeta(s,/ibland något ironiskt/);
			// Remove any reference numbers other than that at line start
			let trail = s.slice(2,s.length);
			for (let i = 1; i < 24; i++) {
				trail = trail.replaceAll(" " + i + " "," ");
				trail = trail.replaceAll(i,"");				
			}
			s = s.slice(0,2) + trail;		
			s = s.replaceAll("  ", " ");
			s = s.replaceAll("  ", " ");
			let match = s.match(/[\s]+[,]+/i);
			if (match) {
				s = s.replaceAll(match[0],",");				
			}
			
			let m = s.match(regex1);
			let m_alt = s.match(regex1_alt);
			let m2 = s.match(regex2);
			let m3 = s.match(regex3);
			let rep = ""
			if (m3 != null) {
				let strMatch = m3[0];
				let rep = strMatch.slice(0,5) + " " + strMatch.slice(5,strMatch.length) + ")";
				s = s.replace(strMatch, rep);
			} else if (m2 != null) {
				let strMatch = m2[0];
				rep = strMatch.slice(0,5) + " " + strMatch.slice(5,strMatch.length) + ")";
				s = s.replace(strMatch, rep);
			} else if (m != null) {
				let strMatch = m[0];
				let rep = strMatch.slice(0,5) + " " + strMatch.slice(5,strMatch.length) + ")";
				s = s.replace(strMatch, rep);
			} else if (m_alt != null) {
				let strMatch = m_alt[0];
				let rep = strMatch.slice(0,9) + " " + strMatch.slice(9,strMatch.length) + ")";
				s = s.replace(strMatch, rep);
			}
			s = s.replace("ibland med partikeln","(ibland med partikeln");
			s = s.replace("vanligen med partikeln","(vanligen med partikeln");
			let f1 = "utan) större betydelse­skillnad";
			let f2 = "), utan större betydelse­förändring";
			let f3 = "), utan större betydelse­skillnad";
			let f4 = "utan) större betydelse­förändring";
			s = s.replace(f1, f1.replace(")","") + ")");
			s = s.replace(f2,f2.replace(")","") + ")");
			s = s.replace(f3,f3.replace(")","") + ")");
			s = s.replace(f4,f4.replace(")","") + ")");
			if (s.includes("((")) s = s.replace("((", "(");
			// Trailing spaces (or non-breaking space) can break links, remove
			let lastCh = s.charAt(s.length-1);			
			if (lastCh.charCodeAt(0) === 32 || lastCh.charCodeAt(0) === 160) {								
				s = s.slice(0,s.length-1)
			}
						
			// grammer information
			s = grammer(s,"ofta refl.");
			s = grammer(s,"med prep.");
			s = grammer(s,"med konjunktionen",);
			s = grammer(s,"vanligen pres.");
			s = grammer(s,"vanligen bestämd form sing.");
			s = grammer(s,"vanligen bestämd form");
			s = grammer(s,"ofta plur.");
			s = grammer(s,"knappast plur.; i vissa ut\u00ADtryck");
			s = grammer(s,"knappast plur.");
			s = grammer(s,"vanligen plur.");
			s = grammer(s,"vanligen part.");
			// ToDo regex to get word reference
			s = grammer(s,"ofta fast sammansättn., jfr");
			s = grammer(s,"mest i sammansättn.");
			s = grammer(s,"nu­mera vanligen i sammansätt.");	
			s = grammer(s,"vanligen i sammansättn.");
			s = grammer(s,"vanligen i vissa sammansätt.");			
			// ToDo regex this one
			s = grammer(s,"äv. fast sammansättn., se");
			s = grammer(s,"vanligen i vissa ut\u00ADtryck");
			s = grammer(s,"i vissa ut\u00ADtryck");
			s = grammer(s,"ofta pass.");
			s = grammer(s,"vanligen pass. el. part.");
			s = grammer(s,"ofta bestämd form");
			s = grammer(s,"ofta perfekt particip");
			s = grammer(s,"ofta presens particip");
			s = grammer(s,"vanligen perfekt particip");
			s = grammer(s,"vanligen obestämd form sing.");
			s = grammer(s,"äv. två ord");
			s = grammer(s,"nästan en\u00ADbart i sammansättn.");
			s = grammer(s,"endast predikativt");
			s = grammer(s,"vanligen i konstruktioner");
			s = grammer(s,"vanligen i konstruktion");
			s = grammer(s,"vanligen i opersonliga konstruktioner");			
			s = grammer(s,"i opersonliga konstruktioner");			
			s = grammer(s,"vanligen opersonlig konstruktion");
			s = grammer(s,"vanligen koll.");
			s = grammer(s,"ofta i nekande el. frågande ut­tryck");
			s = grammer(s,"vanligen i nekande el. frågande ut­tryck");
			s = grammer(s,"ofta i nekande ut­tryck");
			s = grammer(s,"vanligen i nekande ut­tryck");
			s = grammer(s,"nästan en­bart plur.");
			s = grammer(s,"i plur.");
			s = grammer(s,"vanligen predikativt");
			s = grammer(s,"äv. två ord");
			s = grammer(s,"ofta två ord");
			// ToDo Regex this to include the partikel verk
			//s = grammer(s,"ofta lös förbindelse, se");
			// ToDo Regex this to include the verb
			//s = grammer(s,"vanligen i förbindelse");
			//outDef = "";
			outDef += del + s;			
			// HTML newline separator bon lines subsequent to the first
			del = "<br>";
		}
	}
	// That's it!
	return outDef;
}
function cleanUp() {
	if (DEBUG) console.log("cleanUp(); LAST_DEF = " + LAST_DEF);
	let def = LAST_DEF
	if (def.slice(0,4) === "<br>") def = def.substr(4)
	def = def.replaceAll("<br>","\n");
	def = def.replaceAll(" JFR","\nJFR");
	def = def.replaceAll(" SE","\nSE");
	def = def.replaceAll(" SYN","\nSYN");
	def = def.replaceAll(" MOTSATS","\nMOTSATS");
	putDef(def);
}
function showWords() {
	if ($('#iWords').css("visibility") == "hidden") {
		$('#iWords').css("visibility", "visible");
	}
}
function highlight(el,event) {
	if (event.type === "mouseover") {
		el.style.cursor = "pointer";
		el.style.borderColor = "blue";
		if (el.nodeName === "P") el.style.backgroundColor="gray" 
	} else {
		el.style.cursor = "";
		el.style.borderColor = "";
		if (el.nodeName === "P") el.style.backgroundColor=""
	}
}
function toggleDebugEv(e) {
	e.preventDefault();
	toggleDebug();
}
function toggleDebug() {
	DEBUG = !DEBUG;
	if (DEBUG) {
		console.log("Entering debug mode...");
		$('#iDebugTxt').text("DEBUG");
		$('#iDebug').css("color","gray");
	}  else {
		$('#iDebug').css("color","");
		$('#iDebugTxt').text("");
		console.log("Leaving debug mode...");
	}
}
function setClassGuessWrapper(ev) {
	ev.preventDefault();
	let word = $('#iSeek').val();
	setClassGuess();	
	seekWord(word);
}
function setClassGuess() {
	let word = $('#iSeek').val();
	let c = guessClass(word);
	if (DEBUG) console.log("setClassGuess, Class guessed as " + c)
	setClass(c);
	seekWord(CUR_WORD);
}
</script>
</html>